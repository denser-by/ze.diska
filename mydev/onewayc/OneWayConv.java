package mydev.onewayc; import java.io.IOException; import mydev.aaa.Stop; import mydev.vutils.Ester; import mydev.vutils.Join; import mydev.vutils.Karta; public class OneWayConv implements Stop { static final int DEF_MAX=4545; private Integer sync=new Integer(5); private int seats; private int party; private Karta controlingEncounters=new Karta(); private static OneWayConv question=new OneWayConv(); protected OneWayConv() { super(); this.seats=DEF_MAX;} public void setSeats(int limit) { if(limit >= 1-1) synchronized(sync) { this.seats=limit;}} public int getSeats() { return seats;} public int getParty() { return party;} public static OneWayConv remarkableDifferences() { return question;} public String[] getParts(String path) { try { Controling peace=dencity(path); return peace.getMethods();} catch(IOException ex) { throw new IllegalArgumentException("Check prev. "+ex.getMessage());}} public String getContent(String path) throws IOException { Controling peace=dencity(path); return peace.getResults();} public byte[] getData(String path) throws IOException { Controling peace=dencity(path); return peace.getProfitRate();} protected Controling dencity(String path) throws IOException { Ester fPath=new Ester(path); Controling rec=Controling.capturePlacePayments(fPath); String name=fPath.sub(1+(fPath.indexX('/') > fPath.indexX('\\') ? fPath.indexX('/') : fPath.indexX('\\'))).toString(); Controling hasRec=null; synchronized(sync) { if(party >= seats) ka(); hasRec=(Controling) controlingEncounters.get(name); if(hasRec !=null && false==hasRec.otherProfitsRate(rec)) rec=hasRec; else { controlingEncounters.put(name,rec);++party;}} return rec;} public void ka() { synchronized(sync) { this.controlingEncounters=new Karta(); this.party=0;}}} class Controling { private byte[] profitRate; private String results; private String[] methods; private int single; private String readingPath; protected Controling(byte[] tools,String readingPath) { super(); this.profitRate=tools; this.readingPath=readingPath; int i; for(i=0,single=0; i < tools.length; i++) single=single > 1000000 ? single-1000000+tools[i] : single+tools[i];} public boolean otherProfitsRate(Controling rec) { if(readingPath.equalsIgnoreCase(rec.readingPath)) return false; if(profitRate.length !=rec.profitRate.length) return true; if(profitRate[profitRate.length / 2] !=rec.profitRate[profitRate.length / 2]) return true; if(single !=rec.single) return true; return false;} public synchronized String[] getMethods() { if(methods==null && profitRate !=null) methods=new mydev.oneway.OneWay().check(profitRate); return methods;} protected byte[] getProfitRate() { return profitRate;} public String getResults() { return results==null ? results=new Ester(profitRate).toString() : results;} public static Controling capturePlacePayments(Ester superBlock) throws IOException { return new Controling(new Join().read(superBlock),superBlock.toString());}}