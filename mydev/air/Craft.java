package mydev.air; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Checkbox; import java.awt.Choice; import java.awt.Color; import java.awt.Component; import java.awt.Dimension; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Graphics; import java.awt.Label; import java.awt.LayoutManager; import java.awt.Panel; import java.awt.Point; import java.awt.Rectangle; import java.awt.TextField; import java.io.File; import java.io.IOException; import java.util.Arrays; import java.util.Date; import mydev.aaa.Sleeper; import mydev.about.CanvasAdapter; import mydev.about.Circle2D; import mydev.about.ColorfulShapeSet; import mydev.about.Colorfull; import mydev.about.ColorsArray; import mydev.about.Cube; import mydev.about.FourCornersConture2D; import mydev.about.FourCornersConture3D; import mydev.about.GridPlaneLinears; import mydev.about.Line2D; import mydev.about.Line3D; import mydev.about.PaintAdapter; import mydev.about.PlaneCross; import mydev.about.PlaneLinears; import mydev.about.Point2D; import mydev.about.Point3D; import mydev.about.Pyramid; import mydev.about.Rectangle2D; import mydev.about.ScanLineDuo; import mydev.about.Square; import mydev.about.Text2D; import mydev.about.Triangle2D; import mydev.about.Triangle3D; import mydev.about.Vector3; import mydev.anim.ColorsLogo; import mydev.bbb.Enter2; import mydev.bbb.Location; import mydev.cs.WallsProfile; import mydev.csprofile.AbstractRoomSixWalls; import mydev.csprofile.OpenFrontCubeProfile; import mydev.csprofile.RoomCOknoProfile; import mydev.csprofile.RoomConsumer; import mydev.csprofile.VisibilityProfile; import mydev.m3d.ActivationListener; import mydev.m3d.OrderedZ; import mydev.m3d.RedrawableScene; import mydev.m3d.VertEx3D; import mydev.m3d.VertExModel; import mydev.m3d.VertExScene; import mydev.planelook.CurPtr; import mydev.planelook.MouseClickEvent; import mydev.planelook.ProstoZacepit; import mydev.planelook.Reaction; import mydev.planelook.WireCoord; import mydev.sqproj.SqProj; import mydev.sqproj.SqProjBulk; import mydev.sqproj.SqProjProfile; import mydev.sqproj.SqProjsRepo; import mydev.uix.AbstractApproach; import mydev.uix.AbstractApproachProvider; import mydev.uix.AbstractParallelPanel; import mydev.uix.AmountPanel; import mydev.uix.Better; import mydev.uix.CommonCanvas; import mydev.uix.CommonDataArrayPanel; import mydev.uix.CommonLogPanel; import mydev.uix.CommonLogo; import mydev.uix.CommonSouthPanel; import mydev.uix.ControlsPanel; import mydev.uix.GeoLayoutBuilder; import mydev.uix.HeaderPathPanel; import mydev.uix.LabeledEditPair; import mydev.uix.LabeledPanel; import mydev.uix.ListPanel; import mydev.uix.LoggingVkusnjashki; import mydev.uix.LongTermCtrl; import mydev.uix.PagesPanel; import mydev.uix.Params; import mydev.uix.ProgressBar; import mydev.uix.ProgressMultiTasking; import mydev.uix.PropertySetPanel; import mydev.uix.Props; import mydev.uix.SizePanel; import mydev.uix.ToogleMultyButton; import mydev.uix.UpdateConsumer; import mydev.uix.YellowAutoButton; import mydev.vutils.Data; import mydev.vutils.Ester; import mydev.vutils.ExpectHere; import mydev.vutils.Queue; import mydev.vutils.ReadyFree; import mydev.vutils.Stack; import mydev.vutils.TimeTracking; public class Craft extends Frame implements Runnable,LongTermCtrl { PlugPathPanel pathPanel; LimStatParallelPanel quadePanel; SouthComboPanel southPanel; PlugLeftPanel leftPanel; PlugLogPanel logPanel; private String pathParam; private String leftPanelParam; private SourceProcessor spCurrent; private boolean modeView; public Craft(String title) { super(title); setLayout(new BorderLayout()); setBackground(Color.gray);} public static void main(String[] args) throws IOException { Craft main=new Craft("Leaves Days Prototype"); if(args.length > 0) { String param=args[0]; String line=CraftViewSourcePanel.line(param); main.setPathParam(param); System.out.println(line); return;} else System.out.println("Please specify source file as a parameter."); main.show(); main.start(); main.pack(); main.reMoveRnd(); main.resize(Enter2.instance().getMainWindowLargeWidth(),Enter2.instance().getMainWindowLargeHeight()); Sleeper sleeper=new Sleeper(); if(Props.mainLower) Thread.currentThread().setPriority(Thread.MIN_PRIORITY); while(Better.working) { main.refreshUpdatable(); TimeTracking.memTrack(); sleeper.sleep((321+123) / 9);} main.hide(); main.dispose(); System.exit(1-1);} public void setPathParam(String path) { this.pathParam=path; File file=new File(path); String fullPath=file.getAbsolutePath(); if(file.isDirectory()) updateInfo(null,true); else { String item=file.getName(); leftPanelParam=item;}} protected void reMoveRnd() { Location ol=Enter2.instance().location(); Point p=ol.getRandomExternalPos((short) Location.MAIN_WINDOWS_WIDTH_LARGE,(short) Location.MAIN_WINDOWS_HEIGHT_LARGE); move(p.x,p.y);} public boolean hasLongTermContin() { return pathPanel.hasLongTermContin();} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) new Better().exitApplicationLoop(); if(et.id==Event.ACTION_EVENT && et.target==pathPanel.getQuadeBtn()) { pathPanel.changeQuadeState(); cRemake(); pack(); invalidate(); repaint();} if(et.id==Event.ACTION_EVENT && et.target==pathPanel.getChSuperck()) { cRemake(); pack(); invalidate(); repaint();} if(et.id==Event.ACTION_EVENT && et.target==pathPanel.getChPro()) { cRemake(); pack(); invalidate(); repaint();} if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getCbCancelIgnore()) leftPanel.onCancelIgnore(); if(et.id==Event.ACTION_EVENT && et.target==pathPanel.getBtStop()) { pathPanel.disableStop(); leftPanel.enableCtrls(true);} if(et.id==Event.ACTION_EVENT && et.target==pathPanel.getBtScan()) updateInfo(null,true); if(et.id==Event.LIST_SELECT && leftPanel.isItemsCtrl(et.target)) spCurrent=leftSelected(); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getAutoBtn()) autoLines(); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getChFigure()) leftPanel.changeFigures(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getChWay()) leftPanel.changeWay(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getChForm()) leftPanel.changeFormation(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getChSolid()) leftPanel.changeFillings(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getChSpeed()) leftPanel.changeSpeed(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==southPanel.getChStripeX()) southPanel.changeProjections(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==southPanel.getChStripeY()) southPanel.changeProjections(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==southPanel.getChStripeZ()) southPanel.changeProjections(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==southPanel.getChBulkX()) southPanel.changeProjections(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==southPanel.getChBulkY()) southPanel.changeProjections(quadePanel); if(et.id==Event.ACTION_EVENT && et.target==southPanel.getChBulkZ()) southPanel.changeProjections(quadePanel); return super.handleEvent(et);} private void autoLines() { leftPanel.enableAutoBtn(false); pathPanel.enableStop(); leftPanel.enableCtrls(false); modeView=true; new Thread(this).start();} private SourceProcessor leftSelected() { SourceProcessor sp=leftPanel.leftSelected(quadePanel,logPanel); return sp;} public void run() { if(modeView) reviewTriangles(); else createShapes(true,true);} private void reviewTriangles() { pathPanel.enableStop(); leftPanel.enableAutoBtn(false); Sleeper sleeper=new Sleeper(); if(leftPanel.itemsNum() < 1) { logPanel.prognoseTasks(1+1); createShapes(false,false);} else logPanel.prognoseTasks(1); viewAll(sleeper); if(pathPanel.getPreview()) { pathPanel.setPreview(false); sleeper.sleep(166 * 2); new Better().exitApplicationLoop();} pathPanel.disableStop(); leftPanel.enableAutoBtn(true);} private void viewAll(Sleeper sleeper) { ViewShapesTask viewShapesTask=new ViewShapesTask(pathPanel,leftPanel,quadePanel,logPanel,sleeper); logPanel.regTreckableTask(viewShapesTask); viewShapesTask.run();} private void createShapes(boolean singleOp,boolean parallel) { CreateShapesTask createShapesTask=new CreateShapesTask(pathPanel,leftPanel,logPanel,singleOp); logPanel.regTreckableTask(createShapesTask); if(parallel) new Thread(createShapesTask).start(); else createShapesTask.run();} protected void start() { this.southPanel=new SouthComboPanel(); this.logPanel=southPanel.getLogPanel(); this.pathPanel=new PlugPathPanel(pathParam); pathPanel.setProProvider(new ProProvider(pathPanel.getChPro())); pathPanel.changeQuadeState(); add("North",pathPanel.getWrapPanel()); add("West",leftPanel=new PlugLeftPanel()); cRemake(); add("South",southPanel);} void cRemake() { if(quadePanel !=null) remove(quadePanel); add("Center",quadePanel=LimStatParallelPanel.create(pathPanel.getSingle3D(),logPanel.getLogging(),pathPanel.getSuperCheck(),pathPanel.getProCheck()));} protected void refreshUpdatable() { southPanel.refreshUpdatable(); pathPanel.refreshUpdatable(); quadePanel.refreshUpdatable();} protected void updateInfo(ExpectHere eh,boolean opSingle) { pathPanel.enableStop(); leftPanel.clearItems(); leftPanel.setPosition(""); leftPanel.enableAutoBtn(false); modeView=false; new Thread(this).start();}} class ProProvider { private Checkbox chPro; private boolean quade; public ProProvider(Checkbox chPro) { this.chPro=chPro;} public boolean getPro() { if(chPro !=null) return chPro.getState(); return false;} public boolean isSingle3D() { return quade==false;} public void setQuade(boolean quade) { this.quade=quade;}} class SouthComboPanel extends Panel { SouthSettingsPanel settingsPanel; PlugSouthPanel southPanel; public SouthComboPanel() { super(); GeoLayoutBuilder.create().appendCenter(southPanel=new PlugSouthPanel()).appendNorth(settingsPanel=new SouthSettingsPanel()).build(this);} public void changeProjections(LimStatParallelPanel quadePanel) { ProjectionsConfig cfg=new ProjectionsConfig(getChStripeX().getState(),getChStripeY().getState(),getChStripeZ().getState(),getChBulkX().getState(),getChBulkY().getState(),getChBulkZ().getState()); quadePanel.changeProjections(cfg);} public Checkbox getChStripeX() { return settingsPanel.getChStripeX();} public Checkbox getChStripeY() { return settingsPanel.getChStripeY();} public Checkbox getChStripeZ() { return settingsPanel.getChStripeZ();} public Checkbox getChBulkX() { return settingsPanel.getChBulkX();} public Checkbox getChBulkY() { return settingsPanel.getChBulkY();} public Checkbox getChBulkZ() { return settingsPanel.getChBulkZ();} public void refreshUpdatable() { southPanel.refreshUpdatable();} public PlugLogPanel getLogPanel() { return southPanel.getLogPanel();}} class PlugSouthPanel extends CommonSouthPanel { PlugLogPanel logPanel; ColorsLogo logoPanel; public PlugSouthPanel() { super();} protected CommonLogo obtainLogo() { logoPanel=new ColorsLogo(); return logoPanel;} protected CommonLogPanel obtainLogPanel() { logPanel=new PlugLogPanel(); return logPanel;} public PlugLogPanel getLogPanel() { return logPanel;}} class ProgressCraftBar extends ProgressBar { public ProgressCraftBar() { super(DEF_HEIGHT,CraftProps.borderProgressColor,CraftProps.bgProgressColor,CraftProps.mainProgressColor,true);} public ProgressCraftBar(int minSize,Color borderColor,Color bgColor,Color progressColor) { super(minSize,borderColor,bgColor,progressColor,true);}} class PlugLogPanel extends CommonLogPanel implements LoggingVkusnjashki { public PlugLogPanel() { super(false);} protected ProgressBar obtainProgressBarCurrent() { return new ProgressCraftBar();} protected ProgressBar obtainProgressBarTotal() { return new ProgressCraftBar(ProgressCraftBar.DEF_HEIGHT,CraftProps.borderProgressTotalColor,CraftProps.bgProgressTotalColor,CraftProps.mainProgressTotalColor);} public Color getPanelBgColor() { return CraftProps.bgLogPanelColor;} public LayoutManager getPanelLayout() { return new BorderLayout();} public LoggingVkusnjashki getLogging() { return(LoggingVkusnjashki)(this);}} class PlugPathPanel extends HeaderPathPanel implements LongTermCtrl { private String pathParam; private Checkbox chSuperck; private Checkbox chPro; private ProProvider proProvider; final static String CH_SUPERCK="chSuperck"; final static String CH_PRO="chPro"; public PlugPathPanel(String pathParam) { super("Leaves Days Prototype",!false,true,true,LabeledPanel.DEF_MIN_SIZE,CraftProps.northBgColor,CraftProps.northBorderColor,CraftProps.northTextColor); this.pathParam=pathParam;} public void setProProvider(ProProvider proProvider) { this.proProvider=proProvider;} public boolean getSuperCheck() { return chSuperck.getState();} public ProProvider getProCheck() { return proProvider;} public boolean getSingle3D() { return !getMultyState();} protected ToogleMultyButton obtainMultyButton() { return new PlugMultyBtn();} public void enableQuadeBtn(boolean enable) { enableMultyBtn(enable);} public void changeQuadeState() { changeMultyState();} public Button getQuadeBtn() { return getBtMulty();} public boolean hasLongTermContin() { return longTermOp;} protected Label obtainLbPath() { return new Label("Figures number:");} protected TextField obtainTfPath() { TextField tfPath=new TextField("",5+5); tfPath.setText("C:\\Users\\dzianis\\workspace\\"); tfPath.setText("555"); if(pathParam !=null) tfPath.setText(pathParam); return tfPath;} public Checkbox getChSuperck() { return chSuperck;} public Checkbox getChPro() { return chPro;} protected void buildCommonCtrls(boolean withMulty) { super.buildCommonCtrls(withMulty); chSuperck=new Checkbox(getSuperckLabel()); append(CH_SUPERCK,chSuperck); chSuperck.setState(false); chPro=new Checkbox(getProLabel()); append(CH_PRO,chPro); chPro.setState(!false);} private String getSuperckLabel() { return "Super";} private String getProLabel() { return "Proj";} protected void buildPanel() { buildPath();} public Color getPanelBgColor() { return CraftProps.bgTopColor;}} class PlugMultyBtn extends ToogleMultyButton { public PlugMultyBtn() { super(); if(false) changeState();} protected String getMultyName() { return "Single-3D";} protected int getMultyNumber() { return 4;}} class CommandPlug { public static final int ID_READY=1; public static final int ID_INIT=1+1; public static final int ID_READ_SOURCE=1+1+1; public static final int ID_ONELINE=1+1+1+1; public static final int ID_SAVE_SOURCE=1+1+1+1+1; private int id; protected boolean complete; CommandPlug(int id) { super(); this.id=id; this.complete=false;} public static CommandPlug create(int cmdId) { CommandPlug cmd=null; switch(cmdId) { case ID_READY : case ID_INIT : cmd=new CommandPlug(cmdId); break;} return cmd;} public int getId() { return id;} public boolean isComplete() { return complete;}} class ReadCommandPlug extends CommandPlug { private String name; private String path; public ReadCommandPlug(String name,String path) { super(ID_READ_SOURCE); this.name=name; this.path=path;} public String getName() { return name;} public String getPath() { return path;}} class ProcessCommandPlug extends CommandPlug { private boolean needSave; private ReadyFree readyFree; public ProcessCommandPlug(boolean needSave,ReadyFree readyFree) { super(ID_ONELINE); this.needSave=needSave; this.readyFree=readyFree;} public ReadyFree getReadyFree() { return readyFree;} public boolean isNeedSave() { return needSave;}} class SaveCommandPlug extends CommandPlug { private ReadyFree readyFree; public SaveCommandPlug(ReadyFree readyFree) { super(ID_SAVE_SOURCE); this.readyFree=readyFree;} public ReadyFree getReadyFree() { return readyFree;}} interface SourceProcessor { boolean isReadyFree(); void readSource(String name,String path,String looking,String relPath,int idxSel); void process(boolean needSave); void saveSourceLine();} class CommandPlugQueue { private Queue itemsQueue=new Queue(); public CommandPlugQueue() { super();} public void push(CommandPlug cmd) { itemsQueue.enqueueQueueRecord(cmd);} public boolean hasSomeWork() { return itemsQueue.isEmptyQueue()==false;} public CommandPlug nextCurrent() { CommandPlug cmd=(CommandPlug) itemsQueue.dequeueQueueRecord(); return cmd;}} class CapturedCubeItem { private CurPtr msCaptured; private CraftVertEx activeCaptured; public CapturedCubeItem(CurPtr msCaptured,CraftVertEx activeCaptured) { super(); this.msCaptured=msCaptured; this.activeCaptured=activeCaptured;} public CurPtr getMsCaptured() { return msCaptured;} public CraftVertEx getActiveCaptured() { return activeCaptured;}} class CraftViewPanelsRepainter { private Stack updates; private CommonCanvas[] recipients; public CraftViewPanelsRepainter() { this.updates=new Stack();} public void reg4modelUpdate(CommonCanvas commonCanvas) { if(commonCanvas !=null) { updates.push(commonCanvas); updateRecipients();}} public void modelUpdated() { if(recipients !=null) for(int i=0; i < recipients.length; i++) recipients[i].refreshUpdatable();} private void updateRecipients() { recipients=new CommonCanvas[(int) updates.sizeOfStack()]; Object[] stackRecordsArray=updates.getStackRecordsArray(); for(int i=0; i < stackRecordsArray.length; i++) recipients[i]=(CommonCanvas) stackRecordsArray[i];}} abstract class ProstoView { protected static final boolean showViewName=!false; protected static short curMouseX; protected static short curMouseY; protected boolean mouseIn; protected long lastRepaint; protected String viewName; protected VirtualScene vs; private boolean timedRepaint; private CraftViewPanelsRepainter projPanelRep; protected CommonCanvas where; protected ProstoZacepit ctrl; protected Point2D capturePlanePoint; protected Point2D captureActivePoint; private boolean selectedNow; private boolean capturedNow; protected ProstoView(String viewName,CommonCanvas where,boolean timedRepaint,VirtualScene vs,CraftViewPanelsRepainter projPanelRep) { this.viewName=viewName; this.where=where; this.timedRepaint=timedRepaint; this.vs=vs; this.projPanelRep=projPanelRep; this.ctrl=createController();} protected abstract ProstoZacepit createController(); public String getViewName() { return viewName;} public abstract String getInvertedName(); protected abstract void movePlane(int mx,int my); public void clearItems() {} protected void drawItems(CanvasAdapter ics,PaintAdapter pn) { Dimension d1=where.size(); pn.setColor(Color.lightGray.getRGB()); String displStr=viewName; drawLinears(ics,pn); if(showViewName) { Text2D text=new Text2D(new Point2D(CraftProps.ZHO_PIO_SHELL,CraftProps.ZHO_PIO_SHELL),displStr); text.toPen(ics,pn);} if(mouseIn) crossDraw(ics,pn,d1); drawViewItems(ics,pn); drawController(ics,pn);} protected abstract void drawController(CanvasAdapter ics,PaintAdapter pn); protected abstract void drawLinears(CanvasAdapter ics,PaintAdapter pn); protected abstract void crossDraw(CanvasAdapter ics,PaintAdapter pn,Dimension d1); protected abstract Ester getSecondCoord(); protected abstract Ester getFirstCoord(); protected abstract void drawViewItems(CanvasAdapter ics,PaintAdapter pn); private CurPtr regMousePtr(Event et,int mx,int my) { curMouseX=(short) mx; curMouseY=(short) my; CurPtr ms=new CurPtr(et.x,et.y); return ms;} public void mouseEnterings(Event et,int mx,int my) { mouseIn=true;} public void mouseExitings(Event et,int mx,int my) { mouseIn=false; repaintRequest(false);} public void mouseMovings(Event et,int mx,int my) { CurPtr ms=regMousePtr(et,mx,my); Rectangle rt=((CommonCanvas)(et.target)).bounds(); MouseClickEvent tse=new MouseClickEvent(ms,rt,1+1 > 1); selectedNow=processItemSelection(tse); if(ctrl !=null) { boolean aboveCtrl=ctrl.mouseMove(mx,my); if(aboveCtrl) mouseIn=false; else mouseIn=true;} repaintRequest(timedRepaint);} public void mouseDownings(Event et,int mx,int my) { CurPtr ms=regMousePtr(et,mx,my); Rectangle rt=((CommonCanvas)(et.target)).bounds(); MouseClickEvent tse=new MouseClickEvent(ms,rt,1+1 > 1); if(selectedNow) { processItemCapture(tse); capturedNow=true;} if(ctrl !=null) ctrl.mouseDown(mx,my);} public void mouseUpings(Event et,int mx,int my) { CurPtr msReleased=regMousePtr(et,mx,my); Rectangle rt=((CommonCanvas)(et.target)).bounds(); MouseClickEvent tse=new MouseClickEvent(msReleased,rt,1+1 > 1,(et.modifiers & Event.CTRL_MASK) > 0); if(capturedNow) { processItemRelease(tse); capturedNow=false;} repaintRequest(false); if(projPanelRep !=null) projPanelRep.modelUpdated(); if(ctrl !=null) ctrl.mouseUp(mx,my);} protected abstract boolean processItemSelection(MouseClickEvent mce); protected abstract void processItemCapture(MouseClickEvent tse); protected abstract void processItemRelease(MouseClickEvent tse); protected void repaintRequest(boolean withTiming) { if(withTiming) { long curTime=new Date().getTime(); if(curTime-lastRepaint > CraftProps.msecAnimationRefresh /(1+1+1)) { lastRepaint=curTime; where.refreshUpdatable();}} else where.refreshUpdatable();} protected abstract void newSizeArrive(short width,short height);} class CraftModel extends VertExModel { public CraftModel() { super(); CraftVertEx a=createCube7("A"); addVert(a); CraftVertEx b=createCube92("B"); addVert(b); CraftVertEx c=createCube_1("C"); addVert(c); CraftVertEx d=new CraftVertEx("D",new Line3D(a.getCenter(),new Line3D(b.getCenter(),c.getCenter()).midpoint()).midpoint(),CraftProps.lineColorVirtualProjection,CraftProps.projections); addVert(d); CraftVertEx e=createCube4("E"); addVert(e); CraftVertEx f=createCube3("F"); addVert(f); CraftVertEx g=createCube3("G"); addVert(g);} CraftVertEx createCube7(String pointName) { Point3D p7=new Point3D(); p7.setX((short)-143 / 4); p7.setY((short) 193); p7.setZ((short)-220 / 4); CraftVertEx c7=new CraftVertEx(pointName,p7,CraftProps.lineColorVirtualProjection,CraftProps.projections); return c7;} CraftVertEx createCube92(String pointName) { Point3D p92=new Point3D(); p92.setX((short) 246 / 4); p92.setY((short) 338 / 4); p92.setZ((short)-110); CraftVertEx c92=new CraftVertEx(pointName,p92,CraftProps.lineColorVirtualProjection,CraftProps.projections); return c92;} CraftVertEx createCube_1(String pointName) { Point3D p_1=new Point3D(); p_1.setX((short) 155); p_1.setY((short) 135); p_1.setZ((short)-46 / 4); CraftVertEx c_1=new CraftVertEx(pointName,p_1,CraftProps.lineColorVirtualProjection,CraftProps.projections); return c_1;} CraftVertEx createCube4(String pointName) { Point3D p4=new Point3D(); p4.setX((short) 204 / 5); p4.setY((short) 117); p4.setZ((short)-44); CraftVertEx c4=new CraftVertEx(pointName,p4,CraftProps.lineColorVirtualProjection,CraftProps.projections); return c4;} CraftVertEx createCube3(String pointName) { Point3D p3=new Point3D(); p3.setX((short) 177); p3.setY((short) 345 / 5); p3.setZ((short)-197 / 5); CraftVertEx c3=new CraftVertEx(pointName,p3,CraftProps.lineColorVirtualProjection,CraftProps.projections); return c3;} public CraftVertEx getA() { return(CraftVertEx) getVert("A");} public CraftVertEx getB() { return(CraftVertEx) getVert("B");} public CraftVertEx getC() { return(CraftVertEx) getVert("C");} public CraftVertEx getD() { return(CraftVertEx) getVert("D");} public CraftVertEx getE() { return(CraftVertEx) getVert("E");} public CraftVertEx getF() { return(CraftVertEx) getVert("F");} public CraftVertEx getG() { return(CraftVertEx) getVert("G");}} class CraftFigure { private Colorfull shape; private CasualType figureChoice; private String fillingType; public CraftFigure() { super();} public Colorfull getShape() { return shape;} public void reconfigure(CasualType curSel,FillingType fillingType,Colorfull newShape) { this.figureChoice=curSel; this.fillingType=fillingType.getName(); this.shape=newShape;} public CasualType getCurrentFigureChoice() { return figureChoice;} public void setFillingType(String fillingType) { this.fillingType=fillingType;} public String getFillingType() { return fillingType;}} class MotionStrafe { public static final int MIN=5 * 5; private Point3D[] ciclaRedunda; private int curIns; public MotionStrafe(int itemsNum) { super(); this.ciclaRedunda=new Point3D[itemsNum > MIN ? itemsNum : MIN];} public boolean isWaveAvail(int mShif) { Point3D item=getItem(getIdx(mShif)); return item !=null;} private int getIdx(int mShif) { int kandi=curIns-mShif; if(kandi < 0) kandi+=ciclaRedunda.length; return kandi;} private Point3D getItem(int pos) { int num=ciclaRedunda.length; int idx=pos-pos / num * num; Point3D item=ciclaRedunda[idx]; return item;} public Point3D getWaveItem(int mShif) { Point3D item=getItem(getIdx(mShif)); return item;} public void keepMePosted(Point3D position) { if(curIns==ciclaRedunda.length-1) curIns=0; ciclaRedunda[curIns++]=new Point3D(position);}} class VirtualScene extends VertExScene implements RedrawableScene,ActivationListener { private CraftPoint a; private CraftPoint b; private CraftPoint c; private CraftPoint d; private CraftPoint e; private CraftPoint f; private CraftPoint g; private CraftLine ab; private CraftLine cd; private CraftTriangle abd; private CraftFourCorner abcd; private CraftPyramid dabc; private CraftCube a1; private CraftCube b1; private CraftCube c1; private CraftCube d1; private boolean needsRedraw; private CraftFigure currentFigure=new CraftFigure(); private Motion currentMotion=new Motion(); protected AbstractMotionWay motionWay; protected ProjectionsConfig cfg=new ProjectionsConfig(); public VirtualScene(CraftModel model) { this.model=model; this.a=new CraftPoint(model.getA(),CraftProps.lineColorVirtualSpace.getRGB()); this.b=new CraftPoint(model.getB(),CraftProps.lineColorVirtualSpace.getRGB()); this.c=new CraftPoint(model.getC(),CraftProps.lineColorVirtualSpace.getRGB()); this.d=new CraftPoint(model.getD(),CraftProps.lineColorVirtualSpace.getRGB()); this.e=new CraftPoint(model.getE(),CraftProps.lineColorVirtualSpace.getRGB()); this.f=new CraftPoint(model.getF(),CraftProps.lineColorVirtualSpace.getRGB()); this.g=new CraftPoint(model.getG(),CraftProps.lineColorVirtualSpace.getRGB()); this.ab=new CraftLine(model.getA(),model.getB(),CraftProps.lineColorVirtualSpace.getRGB()); this.cd=new CraftLine(model.getC(),model.getD(),CraftProps.lineColorVirtualSpace.getRGB()); this.abd=new CraftTriangle(model.getA(),model.getB(),model.getD(),CraftProps.lineColorVirtualSpace.getRGB()); this.abcd=new CraftFourCorner(model.getA(),model.getB(),model.getC(),model.getD(),CraftProps.lineColorVirtualSpace.getRGB()); this.dabc=new CraftPyramid(model.getA(),model.getB(),model.getC(),model.getD(),CraftProps.lineColorVirtualSpace.getRGB()); currentFigure.reconfigure(CasualType.CT_PYRAMIDES,FillingType.FT_REGENERATION,dabc.setFillingType(FillingType.FT_REGENERATION)); this.a1=new CraftCube(model.getA(),CraftProps.lineColorVirtualSpace.getRGB()); this.b1=new CraftCube(model.getB(),CraftProps.lineColorVirtualSpace.getRGB()); this.c1=new CraftCube(model.getC(),CraftProps.lineColorVirtualSpace.getRGB()); this.d1=new CraftCube(model.getD(),CraftProps.lineColorVirtualSpace.getRGB());} public CraftModel getCraftModel() { return(CraftModel) model;} public CraftPoint getA() { return a;} public CraftPoint getB() { return b;} public CraftPoint getC() { return c;} public CraftPoint getD() { return d;} public CraftPoint getE() { return e;} public CraftPoint getF() { return f;} public CraftPoint getG() { return g;} public CraftLine getAb() { return ab;} public CraftLine getCd() { return cd;} public CraftTriangle getAbd() { return abd;} public CraftFourCorner getAbcd() { return abcd;} public CraftPyramid getDabc() { return dabc;} public CraftCube getA1() { return a1;} public CraftCube getB1() { return b1;} public CraftCube getC1() { return c1;} public CraftCube getD1() { return d1;} public void onActivate(VertEx3D obj) { obj.setColor(CraftProps.lineColorVirtualProjection); markNeedsRedraw();} public void onDeactivate(VertEx3D obj) { obj.setColor(CraftProps.lineColorVirtualSpace.getRGB()); markNeedsRedraw();} public void markNeedsRedraw() { needsRedraw=true;} public boolean peekRedrawFlag() { boolean result=needsRedraw; needsRedraw=false; return result;} public void setCurrentTri(Triangle3D tri) { getCraftModel().getA().moveTo(tri.A()); getCraftModel().getB().moveTo(tri.B()); getCraftModel().getC().moveTo(tri.C()); abd.setFill(tri.getFill()); abd.setColor(tri.getColor());} public void setCurrentFour(FourCornersConture3D fc) { getCraftModel().getA().moveTo(fc.getP1()); getCraftModel().getB().moveTo(fc.getP2()); getCraftModel().getC().moveTo(fc.getP3()); getCraftModel().getD().moveTo(fc.getP4()); abcd.setFill(fc.getFill()); abcd.setColor(fc.getColor());} public void setCurrentPyr(Pyramid pyr) { getCraftModel().getA().moveTo(pyr.A()); getCraftModel().getB().moveTo(pyr.B()); getCraftModel().getC().moveTo(pyr.C()); getCraftModel().getD().moveTo(pyr.D()); dabc.setFill(pyr.getFill()); dabc.setColor(pyr.getColor());} public void setCurrentCubes(ColorfulShapeSet pointSet) { Cube cube=(Cube) pointSet.at(1-1); Cube cube2=(Cube) pointSet.at(1-1+1); Cube cube3=(Cube) pointSet.at(1-1+1+1); Cube cube4=(Cube) pointSet.at(1-1+1+1+1); setCurrentPoints(cube.getCenter(),cube2.getCenter(),cube3.getCenter(),cube4.getCenter());} public void setCurrentPoints(ColorfulShapeSet pointSet) { Point3D point=(Point3D) pointSet.at(1-1); Point3D point2=(Point3D) pointSet.at(1-1+1); Point3D point3=(Point3D) pointSet.at(1-1+1+1); Point3D point4=(Point3D) pointSet.at(1-1+1+1+1); setCurrentPoints(point,point2,point3,point4);} public void setCurrentLines(ColorfulShapeSet lineSet) { Line3D line=(Line3D) lineSet.at(1-1); Line3D line2=(Line3D) lineSet.at(1-1+1); setCurrentLines(line,line2);} public void setCurrentLines(Line3D line,Line3D line2) { getCraftModel().getA().moveTo(line.getP1()); getCraftModel().getB().moveTo(line.getP2()); ab.setColor(line.getColor()); getCraftModel().getC().moveTo(line2.getP1()); getCraftModel().getD().moveTo(line2.getP2()); cd.setColor(line2.getColor());} public void setCurrentPoints(Point3D point,Point3D point2,Point3D point3,Point3D point4) { getCraftModel().getA().moveTo(point); a.setColor(point.getColor()); getCraftModel().getB().moveTo(point2); b.setColor(point2.getColor()); getCraftModel().getC().moveTo(point3); c.setColor(point3.getColor()); getCraftModel().getD().moveTo(point4); d.setColor(point4.getColor());} public void setCurrentFigureChoice(CasualType curSelShape,String curSelFilling) { currentFigure.setFillingType(curSelFilling); currentFigure.reconfigure(curSelShape,FillingType.getType(curSelFilling),getByType(curSelShape,curSelFilling));} public void setCurrentFillingChoice(String curSelFilling) { currentFigure.setFillingType(curSelFilling); CasualType curSelShape=currentFigure.getCurrentFigureChoice(); currentFigure.reconfigure(curSelShape,FillingType.getType(curSelFilling),getByType(curSelShape,curSelFilling));} public Colorfull getCurrentFigure() { return currentFigure.getShape();} public CasualType getCurrentFigureName() { return currentFigure.getCurrentFigureChoice();} private Colorfull getByType(CasualType curSelShape,String curSelFilling) { if(curSelShape !=null) { if(curSelShape.isPoints()) return new ColorfulShapeSet().append(a).append(b).append(c).append(d).append(e).append(f); else if(curSelShape.isLines()) return new ColorfulShapeSet().append(ab).append(cd); else if(curSelShape.isTriangles()) return abd.setFillingType(FillingType.getType(curSelFilling)); else if(curSelShape.isFourCorners()) return abcd.setFillingType(FillingType.getType(curSelFilling)); else if(curSelShape.isPyramides()) return dabc.setFillingType(FillingType.getType(curSelFilling)); else if(curSelShape.isCubes()) return new ColorfulShapeSet().append(a1).append(b1).append(c1).append(d1);} return null;} public boolean isTriangle() { boolean result=getCurrentFigureName().isTriangles(); return result;} public boolean isLines() { boolean result=getCurrentFigureName().isLines(); return result;} public boolean isFourCorners() { boolean result=getCurrentFigureName().isFourCorners(); return result;} public boolean isPyramides() { boolean result=getCurrentFigureName().isPyramides(); return result;} public boolean isPoints() { boolean result=getCurrentFigureName().isPoints(); return result;} public boolean isCubes() { boolean result=getCurrentFigureName().isCubes(); return result;} public void changeCurrentSpeed(String curSelSpeed) { currentMotion.getSpeed().cruisingAuto(MotionVelocity.recover(curSelSpeed));} public Motion getCurrentMotion() { return currentMotion;} public void animateWay() { if(currentMotion.wayType.isNorthSouthWestEast()) { if(motionWay==null || !(motionWay instanceof MotionWayNSWE)) motionWay=new MotionWayNSWE(getCraftModel(),currentMotion,getAirField());} else if(currentMotion.wayType.isSpiral()) { if(motionWay==null || !(motionWay instanceof MotionWaySpiral)) motionWay=new MotionWaySpiral(getCraftModel(),currentMotion);} else if(currentMotion.wayType.isRing()) { if(motionWay==null || !(motionWay instanceof MotionWayRing)) motionWay=new MotionWayRing(getCraftModel(),currentMotion);} else if(currentMotion.wayType.isSphere()) { if(motionWay==null || !(motionWay instanceof MotionWaySphere)) motionWay=new MotionWaySphere(getCraftModel(),currentMotion);} if(motionWay !=null) motionWay.nextLocation();} public AirField getAirField() { return(AirField) aiSc;} public void changeProjections(ProjectionsConfig cfg) { this.cfg=cfg;}} class ProjectionsConfig { boolean stripeX; boolean stripeY; boolean stripeZ; boolean bulkX; boolean bulkY; boolean bulkZ; public ProjectionsConfig(boolean stripeX,boolean stripeY,boolean stripeZ,boolean bulkX,boolean bulkY,boolean bulkZ) { super(); this.stripeX=stripeX; this.stripeY=stripeY; this.stripeZ=stripeZ; this.bulkX=bulkX; this.bulkY=bulkY; this.bulkZ=bulkZ;} public ProjectionsConfig() {} public boolean isStripeX() { return stripeX;} public void setStripeX(boolean stripeX) { this.stripeX=stripeX;} public boolean isStripeY() { return stripeY;} public void setStripeY(boolean stripeY) { this.stripeY=stripeY;} public boolean isStripeZ() { return stripeZ;} public void setStripeZ(boolean stripeZ) { this.stripeZ=stripeZ;} public boolean isBulkX() { return bulkX;} public void setBulkX(boolean bulkX) { this.bulkX=bulkX;} public boolean isBulkY() { return bulkY;} public void setBulkY(boolean bulkY) { this.bulkY=bulkY;} public boolean isBulkZ() { return bulkZ;} public void setBulkZ(boolean bulkZ) { this.bulkZ=bulkZ;}} abstract class AbstractMotionWay { protected final static int xMax=175; protected final static int xMin=-160; protected final static int xCenter=(xMax+xMin) / 2; protected final static int yMax=235; protected final static int yMin=15; protected final static int yCenter=(yMax+yMin) / 2; protected final static int zMax=15; protected final static int zMin=-73; protected final static int zCenter=(zMax+zMin) / 2; protected final static float radius=87.f; protected final static float radius2=107.f; protected CraftModel model; protected Motion currentMotion; public AbstractMotionWay(CraftModel model,Motion currentMotion) { super(); this.model=model; this.currentMotion=currentMotion;} abstract public void nextLocation();} class MotionWayNSWE extends AbstractMotionWay { private AirField room; public MotionWayNSWE(CraftModel model,Motion currentMotion,AirField room) { super(model,currentMotion); this.room=room;} public void nextLocation() { Point3D position=model.getD().getCenter(); if(currentMotion.checkIfState(0) && position.getX() >= xMax) { currentMotion.updateState(1,Vector3.DX1m);} if(currentMotion.checkIfState(1) && position.getX() <= xMin) { currentMotion.updateState(2,Vector3.DX1);} if(currentMotion.checkIfState(2) && position.getX() >= xCenter) { currentMotion.updateState(3,Vector3.DY1);} if(currentMotion.checkIfState(3) && position.getY() >= yMax) { currentMotion.updateState(4,Vector3.DY1m);} if(currentMotion.checkIfState(4) && position.getY() <= yMin) { currentMotion.updateState(5,Vector3.DY1);} if(currentMotion.checkIfState(5) && position.getY() >= yCenter) { currentMotion.updateState(); currentMotion.invertShiftZ(); position.moveTo(Vector3.shiftZ(currentMotion.getShiftZ()).getShiftedCopy(position));} currentMotion.move(position);}} abstract class AbstractMotionWayReformation extends AbstractMotionWay { protected MotionStrafe strafe=new MotionStrafe(5+5+5+1); protected Point3D position; protected Point3D position2; protected Point3D position3; protected Point3D position4; AbstractMotionWayReformation(CraftModel model,Motion currentMotion) { super(model,currentMotion);} protected void reform(Point3D center) { if(currentMotion.getFormationType().isChain()) { if(strafe.isWaveAvail(5)) position2.moveTo(strafe.getWaveItem(5)); if(strafe.isWaveAvail(5+5)) position3.moveTo(strafe.getWaveItem(5+5)); if(strafe.isWaveAvail(5+5+5)) position4.moveTo(strafe.getWaveItem(5+5+5));} else if(currentMotion.getFormationType().isTri()) { if(strafe.isWaveAvail(5)) { position2.moveTo(strafe.getWaveItem(5)); Line3D radLine=new Line3D(position2,center); Point3D position2Copy=radLine.getVect().halfLikeProportion((float) model.getD().getWidth() / radLine.length()).getShiftedCopy(position2); position3.moveTo(position2Copy); Point3D position4Copy=radLine.getVect().halfLikeProportion((float) model.getD().getWidth() *.55f / radLine.length()).getShiftedCopy(position); position4.moveTo(position4Copy);}} else if(currentMotion.getFormationType().isLine()) { Line3D radLine=new Line3D(position,center); Point3D position2Copy=radLine.getVect().halfLikeProportion((float) model.getD().getWidth() * 0.55f / radLine.length()).getShiftedCopy(position); position2.moveTo(position2Copy); Point3D position3Copy=radLine.getVect().halfLikeProportion((float) model.getD().getWidth() * 1.1f / radLine.length()).getShiftedCopy(position); position3.moveTo(position3Copy); Point3D position4Copy=radLine.getVect().halfLikeProportion((float) model.getD().getWidth() * 1.55f / radLine.length()).getShiftedCopy(position); position4.moveTo(position4Copy);}} protected int mod(int num) { return num < 0 ?-num : num;}} class MotionWaySphere extends AbstractMotionWayReformation { public MotionWaySphere(CraftModel model,Motion currentMotion) { super(model,currentMotion);} public void nextLocation() {}} class MotionWaySpiral extends AbstractMotionWayReformation { private float angleXZ=0.f; private int yPos=9759345; private int changeY=1; private float changeAlf=0.036f; public MotionWaySpiral(CraftModel model,Motion currentMotion) { super(model,currentMotion);} public void nextLocation() { position=model.getD().getCenter(); position2=model.getE().getCenter(); position3=model.getF().getCenter(); position4=model.getG().getCenter(); angleXZ+=changeAlf * currentMotion.getSpeed().getStepsMult(); if(changeY !=0) changeY=changeY / mod(changeY) * currentMotion.getSpeed().getStepsMult(); else changeY=currentMotion.getSpeed().getStepsMult(); Point3D center=new Point3D(xCenter,yCenter,zCenter); int xPos=(int)(radius * Math.sin((float) angleXZ)); int zPos=(int)(radius * Math.cos((float) angleXZ)); if(yPos==9759345) yPos=0-yCenter+15; else yPos+=changeY; if(yPos > yMax-yCenter) changeY *=-1; if(yPos < 0-yCenter+15) changeY *=-1; Point3D newLoc=Vector3.shiftXYZ(xPos,yPos,zPos).getShiftedCopy(center); position.moveTo(newLoc); reform(center); strafe.keepMePosted(position);}} class MotionWayRing extends AbstractMotionWayReformation { private float angleXZ=0.f; private float changeAlf=0.036f; public MotionWayRing(CraftModel model,Motion currentMotion) { super(model,currentMotion);} public void nextLocation() { position=model.getD().getCenter(); position2=model.getE().getCenter(); position3=model.getF().getCenter(); position4=model.getG().getCenter(); angleXZ+=changeAlf * currentMotion.getSpeed().getStepsMult(); Point3D center=new Point3D(xCenter,yCenter,zCenter); int xPos=(int)(radius2 * Math.sin((float) angleXZ)); int yPos=(int) zCenter; int zPos=(int)(radius2 * Math.cos((float) angleXZ)); Point3D newLoc=Vector3.shiftXYZ(xPos,yPos,zPos).getShiftedCopy(center); position.moveTo(newLoc); reform(center); strafe.keepMePosted(position);}} class Motion extends Vector3 { protected int motionState; protected MotionVelocity motionVelocity=MotionVelocity.startVelocity; protected int shiftZ=-30; protected PathType wayType=PathType.PT_SPIRAL; protected AirFormation formationType=AirFormation.AF_CHAIN; public Motion() { super(); updateState();} public Motion(int motionState,Vector3 motionVector) { super(); updateState(motionState,motionVector);} public void changeWay(PathType curSelWay) { if(curSelWay !=null) this.wayType=curSelWay;} public PathType getWayType() { return wayType;} public AirFormation getFormationType() { return formationType;} public void changeForm(AirFormation curSelForm) { if(curSelForm !=null) this.formationType=curSelForm;} public int getShiftZ() { return shiftZ;} public void invertShiftZ() { shiftZ=-shiftZ;} public void updateState() { update(DX1); this.motionState=0;} public void updateState(int motionState,Vector3 motionVector) { update(motionVector); this.motionState=motionState;} public boolean checkIfState(int state) { return motionState==state;} public void move(Point3D location) { Vector3 shiftVect=new Vector3(this).halfLikeProportion((double) motionVelocity.getStepsMult() / module()); Point3D newLocation=shiftVect.getShiftedCopy(location); location.moveTo(newLocation);} public MotionVelocity getSpeed() { return motionVelocity;}} abstract class ItemCraftPlainView extends ProstoView { protected Square pointSquareSelection; protected Point2D pointSelect; protected PlaneCross cross; protected Vector3 ento; protected PlaneLinears linears; protected WireCoord seeFirst; protected WireCoord seeSecond; protected ItemCraftPlainView(String viewName,CommonCanvas where,boolean timedRepaint,VirtualScene vs,CraftViewPanelsRepainter projPanelRep,WireCoord seeFirst,WireCoord seeSecond) { super(viewName,where,timedRepaint,vs,projPanelRep); this.cross=new PlaneCross(new Point2D(curMouseX,curMouseY),CraftProps.ZHO_PIO_SHELL,CraftProps.ZHO_PIO_SHELL,getFirstCoord(),getSecondCoord(),CraftProps.crossColor); this.seeFirst=seeFirst; this.seeSecond=seeSecond;} protected abstract void updateSees(); public WireCoord getSeeFirst() { return seeFirst;} public WireCoord getSeeSecond() { return seeSecond;} protected void crossDraw(CanvasAdapter ics,PaintAdapter pn,Dimension d1) { cross.update(new Point2D(curMouseX,curMouseY),d1.width,d1.height); cross.toPen(ics,pn.select(cross));} protected void drawController(CanvasAdapter ics,PaintAdapter pn) { ctrl.toPen(ics,pn.select(ctrl));} public abstract boolean readyCreated(); protected abstract Point2D getP1(); protected abstract Point2D getP2(); protected abstract Point2D getP3(); protected abstract Point2D getP4(); protected abstract Point2D getP5(); protected abstract Point2D getP6(); protected abstract Point2D getP7(); protected void drawSelection(CanvasAdapter ics,PaintAdapter pn) { if(pointSquareSelection !=null) pointSquareSelection.toPen(ics,pn.select(pointSquareSelection));} private CurPtr msCaptured; protected void processItemCapture(MouseClickEvent tse) { msCaptured=tse.getMs(); if(pointSquareSelection !=null) captureActivePoint=pointSelect;} protected void processItemRelease(MouseClickEvent tse) { CurPtr msReleased=tse.getMs(); if(captureActivePoint !=null && readyCreated()) { Vector3 relocVect=Vector3.shiftXY(-msReleased.dx(msCaptured),msReleased.dy(msCaptured)); Point2D P1=getP1(); Point2D P2=getP2(); Point2D P3=getP3(); Point2D P4=getP4(); Point2D P5=getP5(); Point2D P6=getP6(); Point2D P7=getP7(); if(isModePoints()) { if(captureActivePoint.equals(P1)) { P1.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P1);} else if(captureActivePoint.equals(P2)) { P2.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P2);} else if(captureActivePoint.equals(P3)) { P3.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P3);} else if(captureActivePoint.equals(P4)) { P4.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P4);} else if(captureActivePoint.equals(P5)) { P5.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P5);} else if(captureActivePoint.equals(P6)) { P6.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P6);} else if(captureActivePoint.equals(P7)) { P7.shift(relocVect); updatePoints(P1,P2,P3,P4,P5,P6,P7,relocVect,P7);}} else if(isModeCubes()) { if(captureActivePoint.equals(P1)) { P1.shift(relocVect); updateCubes(P1,P2,P3,P4,relocVect,P1);} else if(captureActivePoint.equals(P2)) { P2.shift(relocVect); updateCubes(P1,P2,P3,P4,relocVect,P2);} else if(captureActivePoint.equals(P3)) { P3.shift(relocVect); updateCubes(P1,P2,P3,P4,relocVect,P3);} else if(captureActivePoint.equals(P4)) { P4.shift(relocVect); updateCubes(P1,P2,P3,P4,relocVect,P4);}} else if(isModeLines()) { if(captureActivePoint.equals(P1)) { P1.shift(relocVect); updateLines(P1,P2,P3,P4,relocVect,P1);} else if(captureActivePoint.equals(P2)) { P2.shift(relocVect); updateLines(P1,P2,P3,P4,relocVect,P2);} else if(captureActivePoint.equals(P3)) { P3.shift(relocVect); updateLines(P1,P2,P3,P4,relocVect,P3);} else if(captureActivePoint.equals(P4)) { P4.shift(relocVect); updateLines(P1,P2,P3,P4,relocVect,P4);}} else if(isModeTriangles()) { if(captureActivePoint.equals(P1)) { P1.shift(relocVect); updateTri(P1,P2,P3,relocVect,P1);} else if(captureActivePoint.equals(P2)) { P2.shift(relocVect); updateTri(P1,P2,P3,relocVect,P2);} else if(captureActivePoint.equals(P3)) { P3.shift(relocVect); updateTri(P1,P2,P3,relocVect,P3);}} else if(isModeFourCorners()) { if(captureActivePoint.equals(P1)) { P1.shift(relocVect); updateFour(P1,P2,P3,P4,relocVect,P1);} else if(captureActivePoint.equals(P2)) { P2.shift(relocVect); updateFour(P1,P2,P3,P4,relocVect,P2);} else if(captureActivePoint.equals(P3)) { P3.shift(relocVect); updateFour(P1,P2,P3,P4,relocVect,P3);} else if(captureActivePoint.equals(P4)) { P4.shift(relocVect); updateFour(P1,P2,P3,P4,relocVect,P4);}} else if(isModePyramides()) { if(captureActivePoint.equals(P1)) { P1.shift(relocVect); updatePyr(P1,P2,P3,P4,relocVect,P1);} else if(captureActivePoint.equals(P2)) { P2.shift(relocVect); updatePyr(P1,P2,P3,P4,relocVect,P2);} else if(captureActivePoint.equals(P3)) { P3.shift(relocVect); updatePyr(P1,P2,P3,P4,relocVect,P3);} else if(captureActivePoint.equals(P4)) { P4.shift(relocVect); updatePyr(P1,P2,P3,P4,relocVect,P4);}} captureActivePoint=null; if(pointSquareSelection !=null) pointSquareSelection.getCenter().moveTo(msReleased.mx(),msReleased.my()); repaintRequest(false);}} private boolean isModeCubes() { boolean result=vs.getCurrentFigureName().isCubes(); return result;} private boolean isModePoints() { boolean result=vs.getCurrentFigureName().isPoints(); return result;} private boolean isModeLines() { boolean result=vs.getCurrentFigureName().isLines(); return result;} private boolean isModeTriangles() { boolean result=vs.getCurrentFigureName().isTriangles(); return result;} private boolean isModeFourCorners() { boolean result=vs.getCurrentFigureName().isFourCorners(); return result;} private boolean isModePyramides() { boolean result=vs.getCurrentFigureName().isPyramides(); return result;} protected abstract void updatePoints(Point2D a,Point2D b,Point2D c,Point2D d,Point2D e,Point2D f,Point2D g,Vector3 relocVect,Point2D P1234); protected abstract void updateLines(Point2D a,Point2D b,Point2D c,Point2D d,Vector3 relocVect,Point2D P1234); protected abstract void updateTri(Point2D a,Point2D b,Point2D c,Vector3 relocVect,Point2D P123); protected abstract void updateFour(Point2D a,Point2D b,Point2D c,Point2D d,Vector3 relocVect,Point2D P1234); protected abstract void updatePyr(Point2D a,Point2D b,Point2D c,Point2D d,Vector3 relocVect,Point2D P1234); protected abstract void updateCubes(Point2D a,Point2D b,Point2D c,Point2D d,Vector3 relocVect,Point2D P1234); protected boolean processItemSelection(MouseClickEvent mce) { int q=8; Point2D mcePoint=new Point2D(mce.ms().mx(),mce.ms().my()); if(readyCreated()) { if(getP1().distance(mcePoint) < q) { pointSelect=getP1(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else if(getP2().distance(mcePoint) < q) { pointSelect=getP2(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else if(getP3().distance(mcePoint) < q) { pointSelect=getP3(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else if(getP4() !=null && getP4().distance(mcePoint) < q) { pointSelect=getP4(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else if(getP5() !=null && getP5().distance(mcePoint) < q) { pointSelect=getP5(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else if(getP6() !=null && getP6().distance(mcePoint) < q) { pointSelect=getP6(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else if(getP7() !=null && getP7().distance(mcePoint) < q) { pointSelect=getP7(); pointSquareSelection=new Square(pointSelect,q,CraftProps.lineColorVirtualSpace.getRGB());} else { pointSquareSelection=null; pointSelect=null;}} return pointSelect !=null;} protected void drawLinears(CanvasAdapter ics,PaintAdapter pn) { if(linears==null) { linears=new GridPlaneLinears(where.getCcWidth(),where.getCcHeight(),ColorsArray.bluePoint.ic(),where.getBgColor().getRGB()); linears.setEnto(ento);} linears.toPen(ics,pn.select(linears));} protected void newSizeArrive(short width,short height) { if(linears !=null) linears.notifyNewSize(width,height);}} class ProjUtils { public ProjUtils() { super();} public boolean isInited(ProjLineXY[] lineProjXY) { if(lineProjXY !=null) return lineProjXY[0] !=null && lineProjXY[1] !=null; return false;} public boolean isInited(ProjLineYZ[] lineProjYZ) { if(lineProjYZ !=null) return lineProjYZ[0] !=null && lineProjYZ[1] !=null; return false;} public boolean isInited(ProjLineXZ[] lineProjXZ) { if(lineProjXZ !=null) return lineProjXZ[0] !=null && lineProjXZ[1] !=null; return false;} public boolean isInited(ProjPointXY[] pointProjXY) { if(pointProjXY !=null) return pointProjXY[0] !=null && pointProjXY[1] !=null && pointProjXY[1+1] !=null && pointProjXY[1+1+1] !=null; return false;} public boolean isInited(ProjCubeXY[] cubeProjXY) { if(cubeProjXY !=null) return cubeProjXY[0] !=null && cubeProjXY[1] !=null && cubeProjXY[1+1] !=null && cubeProjXY[1+1+1] !=null; return false;} public boolean isInited(ProjPointYZ[] pointProjYZ) { if(pointProjYZ !=null) return pointProjYZ[0] !=null && pointProjYZ[1] !=null && pointProjYZ[1+1] !=null && pointProjYZ[1+1+1] !=null; return false;} public boolean isInited(ProjCubeYZ[] cubeProjYZ) { if(cubeProjYZ !=null) return cubeProjYZ[0] !=null && cubeProjYZ[1] !=null && cubeProjYZ[1+1] !=null && cubeProjYZ[1+1+1] !=null; return false;} public boolean isInited(ProjPointXZ[] pointProjXZ) { if(pointProjXZ !=null) return pointProjXZ[0] !=null && pointProjXZ[1] !=null && pointProjXZ[1+1] !=null && pointProjXZ[1+1+1] !=null; return false;} public boolean isInited(ProjCubeXZ[] cubeProjXZ) { if(cubeProjXZ !=null) return cubeProjXZ[0] !=null && cubeProjXZ[1] !=null && cubeProjXZ[1+1] !=null && cubeProjXZ[1+1+1] !=null; return false;}} class ItemCraftFrontView extends ItemCraftPlainView implements Reaction { protected ProjPointXY[] pointProjXY; protected ProjLineXY[] lineProjXY; protected ProjTriangleXY triProjXY; protected ProjContureFourXY fourProjXY; protected ProjPyramidXY pyrProjXY; protected ProjCubeXY[] cubeProjXY; public ItemCraftFrontView(String viewName,CommonCanvas where,VirtualScene vs,CraftViewPanelsRepainter projPanelRep) { super(viewName,where,false,vs,projPanelRep,WireCoord.xC.complicate(),WireCoord.yC.complicate()); this.ento=Vector3.shiftXY(CraftProps.FV_DX,CraftProps.FV_DY); updateSees();} protected void updateSees() { seeFirst.setValue(""+ento.getDx()); seeSecond.setValue(""+ento.getDy());} protected ProstoZacepit createController() { return new ProstoZacepit(new Point2D(10,30),30+1,170,ColorsArray.orangePoint.ic(),this);} public boolean readyCreated() { if(vs.isTriangle()) return triProjXY !=null; else if(vs.isFourCorners()) return fourProjXY !=null; else if(vs.isPyramides()) return pyrProjXY !=null; else if(vs.isLines()) return new ProjUtils().isInited(lineProjXY); else if(vs.isPoints()) return new ProjUtils().isInited(pointProjXY); else if(vs.isCubes()) return new ProjUtils().isInited(cubeProjXY); return false;} protected Point2D getP1() { if(vs.isTriangle()) return triProjXY.getP1(); else if(vs.isFourCorners()) return fourProjXY.getP1(); else if(vs.isPyramides()) return pyrProjXY.getP1(); else if(vs.isLines()) return lineProjXY[0].getP1(); else if(vs.isPoints()) return pointProjXY[0]; else if(vs.isCubes()) return cubeProjXY[0]; return null;} protected Point2D getP2() { if(vs.isTriangle()) return triProjXY.getP2(); else if(vs.isFourCorners()) return fourProjXY.getP2(); else if(vs.isPyramides()) return pyrProjXY.getP2(); else if(vs.isLines()) return lineProjXY[0].getP2(); else if(vs.isPoints()) return pointProjXY[1]; else if(vs.isCubes()) return cubeProjXY[1]; return null;} protected Point2D getP3() { if(vs.isTriangle()) return triProjXY.getP3(); else if(vs.isFourCorners()) return fourProjXY.getP3(); else if(vs.isPyramides()) return pyrProjXY.getP3(); else if(vs.isLines()) return lineProjXY[1].getP1(); else if(vs.isPoints()) return pointProjXY[1+1]; else if(vs.isCubes()) return cubeProjXY[1+1]; return null;} protected Point2D getP4() { if(vs.isTriangle()) return null; else if(vs.isFourCorners()) return fourProjXY.getP4(); else if(vs.isPyramides()) return pyrProjXY.getP4(); else if(vs.isLines()) return lineProjXY[1].getP2(); else if(vs.isPoints()) return pointProjXY[1+1+1]; else if(vs.isCubes()) return cubeProjXY[1+1+1]; return null;} protected Point2D getP5() { if(vs.isPoints()) return pointProjXY[1+1+1+1]; return null;} protected Point2D getP6() { if(vs.isPoints()) return pointProjXY[1+1+1+1+1]; return null;} protected Point2D getP7() { if(vs.isPoints()) return pointProjXY[1+1+1+1+1+1]; return null;} protected void updateFour(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { fourProjXY.update(P1,P2,P3,P4); vs.getAbcd().updateFourProjXY(P1,P2,P3,P4,relocVect,P1234);} protected void updatePyr(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { pyrProjXY.update(P1,P2,P3,P4); vs.getDabc().updatePyrProjXY(P1,P2,P3,P4,relocVect,P1234);} protected void updateTri(Point2D P1,Point2D P2,Point2D P3,Vector3 relocVect,Point2D P123) { triProjXY.update(P1,P2,P3); vs.getAbd().updateTriangleProjXY(P1,P2,P3,relocVect,P123);} protected void updateLines(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { lineProjXY[0].update(P1,P2); lineProjXY[1].update(P3,P4); vs.getAb().updateLineProjXY(P1,P2,relocVect,P1234); vs.getCd().updateLineProjXY(P3,P4,relocVect,P1234);} protected void updatePoints(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Point2D P5,Point2D P6,Point2D P7,Vector3 relocVect,Point2D P1234) { pointProjXY[0].update(P1); pointProjXY[1].update(P2); pointProjXY[1+1].update(P3); pointProjXY[1+1+1].update(P4); pointProjXY[1+1+1+1].update(P5); pointProjXY[1+1+1+1+1].update(P6); pointProjXY[1+1+1+1+1+1].update(P7); vs.getA().updatePointProjXY(P1,relocVect,P1234); vs.getB().updatePointProjXY(P2,relocVect,P1234); vs.getC().updatePointProjXY(P3,relocVect,P1234); vs.getD().updatePointProjXY(P4,relocVect,P1234); vs.getE().updatePointProjXY(P5,relocVect,P1234); vs.getF().updatePointProjXY(P6,relocVect,P1234); vs.getF().updatePointProjXY(P7,relocVect,P1234);} protected void updateCubes(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { cubeProjXY[0].update(P1); cubeProjXY[1].update(P2); cubeProjXY[1+1].update(P3); cubeProjXY[1+1+1].update(P4); vs.getA1().updateCubeProjXY(P1,relocVect,P1234); vs.getB1().updateCubeProjXY(P2,relocVect,P1234); vs.getC1().updateCubeProjXY(P3,relocVect,P1234); vs.getD1().updateCubeProjXY(P4,relocVect,P1234);} protected void drawViewItems(CanvasAdapter ics,PaintAdapter pn) { float zoom=1.f; Vector3 xyShift=Vector3.shiftXY(ento.getDx(),ento.getDy()); if(lineProjXY==null) lineProjXY=new ProjLineXY[1+1]; if(pointProjXY==null) pointProjXY=new ProjPointXY[1+1+1+1+1+1+1]; if(cubeProjXY==null) cubeProjXY=new ProjCubeXY[1+1+1+1]; if(vs.isTriangle()) { triProjXY=vs.getAbd().triangleProjXY(xyShift); triProjXY.toPen(ics,pn.select(triProjXY)); lastPoints(ics,pn,xyShift); pointProjXY[1+1]=vs.getC().pointProjXY(xyShift); pointProjXY[1+1].toPen(ics,pn.select(pointProjXY[1+1]));} else if(vs.isFourCorners()) { fourProjXY=vs.getAbcd().fourProjXY(xyShift); fourProjXY.toPen(ics,pn.select(fourProjXY)); lastPoints(ics,pn,xyShift);} else if(vs.isPyramides()) { pyrProjXY=vs.getDabc().pyrProjXY(xyShift); pyrProjXY.toPen(ics,pn.select(pyrProjXY)); lastPoints(ics,pn,xyShift);} else if(vs.isLines()) { lineProjXY[0]=vs.getAb().lineProjXY(xyShift); lineProjXY[1]=vs.getCd().lineProjXY(xyShift); lineProjXY[0].toPen(ics,pn.select(lineProjXY[0])); lineProjXY[1].toPen(ics,pn.select(lineProjXY[1])); lastPoints(ics,pn,xyShift);} else if(vs.isPoints()) { pointProjXY[0]=vs.getA().pointProjXY(xyShift); pointProjXY[1]=vs.getB().pointProjXY(xyShift); pointProjXY[1+1]=vs.getC().pointProjXY(xyShift); pointProjXY[1+1+1]=vs.getD().pointProjXY(xyShift); pointProjXY[1+1+1+1]=vs.getE().pointProjXY(xyShift); pointProjXY[1+1+1+1+1]=vs.getF().pointProjXY(xyShift); pointProjXY[1+1+1+1+1+1]=vs.getG().pointProjXY(xyShift); pointProjXY[0].toPen(ics,pn.select(pointProjXY[0])); pointProjXY[1].toPen(ics,pn.select(pointProjXY[1])); pointProjXY[1+1].toPen(ics,pn.select(pointProjXY[1+1])); pointProjXY[1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1])); pointProjXY[1+1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1+1])); pointProjXY[1+1+1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1+1+1])); pointProjXY[1+1+1+1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1+1+1+1]));} else if(vs.isCubes()) { cubeProjXY[0]=vs.getA1().cubeProjXY(xyShift); cubeProjXY[1]=vs.getB1().cubeProjXY(xyShift); cubeProjXY[1+1]=vs.getC1().cubeProjXY(xyShift); cubeProjXY[1+1+1]=vs.getD1().cubeProjXY(xyShift); cubeProjXY[0].toPen(ics,pn.select(cubeProjXY[0])); cubeProjXY[1].toPen(ics,pn.select(cubeProjXY[1])); cubeProjXY[1+1].toPen(ics,pn.select(cubeProjXY[1+1])); cubeProjXY[1+1+1].toPen(ics,pn.select(cubeProjXY[1+1+1])); lastPoints(ics,pn,xyShift);} drawSelection(ics,pn);} private void lastPoints(CanvasAdapter ics,PaintAdapter pn,Vector3 xyShift) { pointProjXY[1+1+1+1]=vs.getE().pointProjXY(xyShift); pointProjXY[1+1+1+1+1]=vs.getF().pointProjXY(xyShift); pointProjXY[1+1+1+1+1+1]=vs.getG().pointProjXY(xyShift); pointProjXY[1+1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1+1])); pointProjXY[1+1+1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1+1+1])); pointProjXY[1+1+1+1+1+1].toPen(ics,pn.select(pointProjXY[1+1+1+1+1+1]));} public String getInvertedName() { return "Distant View";} protected Ester getSecondCoord() { return new Ester("y");} protected Ester getFirstCoord() { return new Ester("x");} public void toTop() { ento.add(Vector3.shiftXY(0,-CraftProps.OO_IKS));} public void toBottom() { ento.add(Vector3.shiftXY(0,CraftProps.OO_IKS));} public void toLeft() { ento.add(Vector3.shiftXY(-CraftProps.OO_IKS,0));} public void toRight() { ento.add(Vector3.shiftXY(CraftProps.OO_IKS,0));} public void toForward() {} public void toBackward() {} protected void movePlane(int mx,int my) { ento.add(Vector3.shiftXY(-mx,-my));}} class ItemCraftLeftView extends ItemCraftPlainView implements Reaction { protected ProjPointYZ[] pointProjYZ; protected ProjTriangleYZ triProjYZ; protected ProjLineYZ[] lineProjYZ; protected ProjContureFourYZ fourProjYZ; protected ProjPyramidYZ pyrProjYZ; protected ProjCubeYZ[] cubeProjYZ; public ItemCraftLeftView(String viewName,CommonCanvas where,VirtualScene vs,CraftViewPanelsRepainter projPanelRep) { super(viewName,where,false,vs,projPanelRep,WireCoord.yC.complicate(),WireCoord.zC.complicate()); this.ento=Vector3.shiftYZ(CraftProps.LV_DY,CraftProps.LV_DZ); updateSees();} protected void updateSees() { seeFirst.setValue(""+ento.getDy()); seeSecond.setValue(""+ento.getDz());} protected ProstoZacepit createController() { return new ProstoZacepit(new Point2D(10,30),30+1,170,ColorsArray.orangePoint.ic(),this);} protected void updateFour(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { fourProjYZ.update(P1,P2,P3,P4); vs.getAbcd().updateFourProjYZ(P1,P2,P3,P4,relocVect,P1234);} protected void updatePyr(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { pyrProjYZ.update(P1,P2,P3,P4); vs.getDabc().updatePyrProjYZ(P1,P2,P3,P4,relocVect,P1234);} protected void updateTri(Point2D P1,Point2D P2,Point2D P3,Vector3 relocVect,Point2D P123) { triProjYZ.update(P1,P2,P3); vs.getAbd().updateTriangleProjYZ(P1,P2,P3,relocVect,P123);} protected void updateLines(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { lineProjYZ[0].update(P1,P2); lineProjYZ[1].update(P3,P4); vs.getAb().updateLineProjYZ(P1,P2,relocVect,P1234); vs.getCd().updateLineProjYZ(P3,P4,relocVect,P1234);} protected void updatePoints(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Point2D P5,Point2D P6,Point2D P7,Vector3 relocVect,Point2D P1234) { pointProjYZ[0].update(P1); pointProjYZ[1].update(P2); pointProjYZ[1+1].update(P3); pointProjYZ[1+1+1].update(P4); pointProjYZ[1+1+1+1].update(P5); pointProjYZ[1+1+1+1+1].update(P6); pointProjYZ[1+1+1+1+1+1].update(P7); vs.getA().updatePointProjYZ(P1,relocVect,P1234); vs.getB().updatePointProjYZ(P2,relocVect,P1234); vs.getC().updatePointProjYZ(P3,relocVect,P1234); vs.getD().updatePointProjYZ(P4,relocVect,P1234); vs.getE().updatePointProjYZ(P5,relocVect,P1234); vs.getF().updatePointProjYZ(P6,relocVect,P1234); vs.getG().updatePointProjYZ(P7,relocVect,P1234);} protected void updateCubes(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { cubeProjYZ[0].update(P1); cubeProjYZ[1].update(P2); cubeProjYZ[1+1].update(P3); cubeProjYZ[1+1+1].update(P4); vs.getA1().updateCubeProjYZ(P1,relocVect,P1234); vs.getB1().updateCubeProjYZ(P2,relocVect,P1234); vs.getC1().updateCubeProjYZ(P3,relocVect,P1234); vs.getD1().updateCubeProjYZ(P4,relocVect,P1234);} public boolean readyCreated() { if(vs.isTriangle()) return triProjYZ !=null; else if(vs.isFourCorners()) return fourProjYZ !=null; else if(vs.isPyramides()) return pyrProjYZ !=null; else if(vs.isLines()) return new ProjUtils().isInited(lineProjYZ); else if(vs.isPoints()) return new ProjUtils().isInited(pointProjYZ); else if(vs.isCubes()) return new ProjUtils().isInited(cubeProjYZ); return false;} protected Point2D getP1() { if(vs.isTriangle()) return triProjYZ.getP1(); else if(vs.isFourCorners()) return fourProjYZ.getP1(); else if(vs.isPyramides()) return pyrProjYZ.getP1(); else if(vs.isLines()) return lineProjYZ[0].getP1(); else if(vs.isPoints()) return pointProjYZ[0]; else if(vs.isCubes()) return cubeProjYZ[0]; return null;} protected Point2D getP2() { if(vs.isTriangle()) return triProjYZ.getP2(); else if(vs.isFourCorners()) return fourProjYZ.getP2(); else if(vs.isPyramides()) return pyrProjYZ.getP2(); else if(vs.isLines()) return lineProjYZ[0].getP2(); else if(vs.isPoints()) return pointProjYZ[1]; else if(vs.isCubes()) return cubeProjYZ[1]; return null;} protected Point2D getP3() { if(vs.isTriangle()) return triProjYZ.getP3(); else if(vs.isFourCorners()) return fourProjYZ.getP3(); else if(vs.isPyramides()) return pyrProjYZ.getP3(); else if(vs.isLines()) return lineProjYZ[1].getP1(); else if(vs.isPoints()) return pointProjYZ[1+1]; else if(vs.isCubes()) return cubeProjYZ[1+1]; return null;} protected Point2D getP4() { if(vs.isTriangle()) return null; else if(vs.isFourCorners()) return fourProjYZ.getP4(); else if(vs.isPyramides()) return pyrProjYZ.getP4(); else if(vs.isLines()) return lineProjYZ[1].getP2(); else if(vs.isPoints()) return pointProjYZ[1+1+1]; else if(vs.isCubes()) return cubeProjYZ[1+1+1]; return null;} protected Point2D getP5() { if(vs.isPoints()) return pointProjYZ[1+1+1+1]; return null;} protected Point2D getP6() { if(vs.isPoints()) return pointProjYZ[1+1+1+1+1]; return null;} protected Point2D getP7() { if(vs.isPoints()) return pointProjYZ[1+1+1+1+1+1]; return null;} protected void drawViewItems(CanvasAdapter ics,PaintAdapter pn) { float zoom=1.f; Vector3 yzShift=Vector3.shiftYZ(ento.getDy(),ento.getDz()); if(lineProjYZ==null) lineProjYZ=new ProjLineYZ[1+1]; if(pointProjYZ==null) pointProjYZ=new ProjPointYZ[1+1+1+1+1+1+1]; if(cubeProjYZ==null) cubeProjYZ=new ProjCubeYZ[1+1+1+1]; if(vs.isTriangle()) { triProjYZ=vs.getAbd().triangleProjYZ(yzShift); triProjYZ.toPen(ics,pn.select(triProjYZ)); lastPoints(ics,pn,yzShift); pointProjYZ[1+1]=vs.getC().pointProjYZ(yzShift); pointProjYZ[1+1].toPen(ics,pn.select(pointProjYZ[1+1]));} else if(vs.isFourCorners()) { fourProjYZ=vs.getAbcd().fourProjYZ(yzShift); fourProjYZ.toPen(ics,pn.select(fourProjYZ)); lastPoints(ics,pn,yzShift);} else if(vs.isPyramides()) { pyrProjYZ=vs.getDabc().pyrProjYZ(yzShift); pyrProjYZ.toPen(ics,pn.select(pyrProjYZ)); lastPoints(ics,pn,yzShift);} else if(vs.isLines()) { lineProjYZ[0]=vs.getAb().lineProjYZ(yzShift); lineProjYZ[1]=vs.getCd().lineProjYZ(yzShift); lineProjYZ[0].toPen(ics,pn.select(lineProjYZ[0])); lineProjYZ[1].toPen(ics,pn.select(lineProjYZ[1])); lastPoints(ics,pn,yzShift);} else if(vs.isPoints()) { pointProjYZ[0]=vs.getA().pointProjYZ(yzShift); pointProjYZ[1]=vs.getB().pointProjYZ(yzShift); pointProjYZ[1+1]=vs.getC().pointProjYZ(yzShift); pointProjYZ[1+1+1]=vs.getD().pointProjYZ(yzShift); pointProjYZ[1+1+1+1]=vs.getE().pointProjYZ(yzShift); pointProjYZ[1+1+1+1+1]=vs.getF().pointProjYZ(yzShift); pointProjYZ[1+1+1+1+1+1]=vs.getG().pointProjYZ(yzShift); pointProjYZ[0].toPen(ics,pn.select(pointProjYZ[0])); pointProjYZ[1].toPen(ics,pn.select(pointProjYZ[1])); pointProjYZ[1+1].toPen(ics,pn.select(pointProjYZ[1+1])); pointProjYZ[1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1])); pointProjYZ[1+1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1+1])); pointProjYZ[1+1+1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1+1+1])); pointProjYZ[1+1+1+1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1+1+1+1]));} else if(vs.isCubes()) { cubeProjYZ[0]=vs.getA1().cubeProjYZ(yzShift); cubeProjYZ[1]=vs.getB1().cubeProjYZ(yzShift); cubeProjYZ[1+1]=vs.getC1().cubeProjYZ(yzShift); cubeProjYZ[1+1+1]=vs.getD1().cubeProjYZ(yzShift); cubeProjYZ[0].toPen(ics,pn.select(cubeProjYZ[0])); cubeProjYZ[1].toPen(ics,pn.select(cubeProjYZ[1])); cubeProjYZ[1+1].toPen(ics,pn.select(cubeProjYZ[1+1])); cubeProjYZ[1+1+1].toPen(ics,pn.select(cubeProjYZ[1+1+1])); lastPoints(ics,pn,yzShift);} drawSelection(ics,pn);} private void lastPoints(CanvasAdapter ics,PaintAdapter pn,Vector3 yzShift) { pointProjYZ[1+1+1+1]=vs.getE().pointProjYZ(yzShift); pointProjYZ[1+1+1+1+1]=vs.getF().pointProjYZ(yzShift); pointProjYZ[1+1+1+1+1+1]=vs.getG().pointProjYZ(yzShift); pointProjYZ[1+1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1+1])); pointProjYZ[1+1+1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1+1+1])); pointProjYZ[1+1+1+1+1+1].toPen(ics,pn.select(pointProjYZ[1+1+1+1+1+1]));} public String getInvertedName() { return "Right View";} protected Ester getSecondCoord() { return new Ester("z");} protected Ester getFirstCoord() { return new Ester("y");} public void toTop() { ento.add(Vector3.shiftYZ(0,-5));} public void toBottom() { ento.add(Vector3.shiftYZ(0,5));} public void toLeft() { ento.add(Vector3.shiftYZ(-5,0));} public void toRight() { ento.add(Vector3.shiftYZ(5,0));} public void toForward() {} public void toBackward() {} protected void movePlane(int mx,int my) { ento.add(Vector3.shiftYZ(-mx,-my));}} class ItemCraftTopView extends ItemCraftPlainView implements Reaction { protected ProjPointXZ[] pointProjXZ; protected ProjTriangleXZ triProjXZ; protected ProjLineXZ[] lineProjXZ; protected ProjContureFourXZ fourProjXZ; protected ProjPyramidXZ pyrProjXZ; protected ProjCubeXZ[] cubeProjXZ; public ItemCraftTopView(String viewName,CommonCanvas where,VirtualScene vs,CraftViewPanelsRepainter projPanelRep) { super(viewName,where,false,vs,projPanelRep,WireCoord.xC.complicate(),WireCoord.zC.complicate()); this.ento=Vector3.shiftXZ(CraftProps.TV_DX,CraftProps.TV_DZ); updateSees();} protected void updateSees() { seeFirst.setValue(""+ento.getDx()); seeSecond.setValue(""+ento.getDz());} protected ProstoZacepit createController() { return new ProstoZacepit(new Point2D(10,30),30+1,170,ColorsArray.orangePoint.ic(),this);} protected void updateFour(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { fourProjXZ.update(P1,P2,P3,P4); vs.getAbcd().updateFourProjXZ(P1,P2,P3,P4,relocVect,P1234);} protected void updatePyr(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { pyrProjXZ.update(P1,P2,P3,P4); vs.getDabc().updatePyrProjXZ(P1,P2,P3,P4,relocVect,P1234);} protected void updateTri(Point2D P1,Point2D P2,Point2D P3,Vector3 relocVect,Point2D P123) { triProjXZ.update(P1,P2,P3); vs.getAbd().updateTriangleProjXZ(P1,P2,P3,relocVect,P123);} protected void updateLines(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { lineProjXZ[0].update(P1,P2); lineProjXZ[1].update(P3,P4); vs.getAb().updateLineProjXZ(P1,P2,relocVect,P1234); vs.getCd().updateLineProjXZ(P3,P4,relocVect,P1234);} protected void updatePoints(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Point2D P5,Point2D P6,Point2D P7,Vector3 relocVect,Point2D P1234) { pointProjXZ[0].update(P1); pointProjXZ[1].update(P2); pointProjXZ[1+1].update(P3); pointProjXZ[1+1+1].update(P4); pointProjXZ[1+1+1+1].update(P5); pointProjXZ[1+1+1+1+1].update(P6); pointProjXZ[1+1+1+1+1+1].update(P7); vs.getA().updatePointProjXZ(P1,relocVect,P1234); vs.getB().updatePointProjXZ(P2,relocVect,P1234); vs.getC().updatePointProjXZ(P3,relocVect,P1234); vs.getD().updatePointProjXZ(P4,relocVect,P1234); vs.getE().updatePointProjXZ(P5,relocVect,P1234); vs.getF().updatePointProjXZ(P6,relocVect,P1234); vs.getG().updatePointProjXZ(P7,relocVect,P1234);} protected void updateCubes(Point2D P1,Point2D P2,Point2D P3,Point2D P4,Vector3 relocVect,Point2D P1234) { cubeProjXZ[0].update(P1); cubeProjXZ[1].update(P2); cubeProjXZ[1+1].update(P3); cubeProjXZ[1+1+1].update(P4); vs.getA1().updateCubeProjXZ(P1,relocVect,P1234); vs.getB1().updateCubeProjXZ(P2,relocVect,P1234); vs.getC1().updateCubeProjXZ(P3,relocVect,P1234); vs.getD1().updateCubeProjXZ(P4,relocVect,P1234);} public boolean readyCreated() { if(vs.isTriangle()) return triProjXZ !=null; else if(vs.isFourCorners()) return fourProjXZ !=null; else if(vs.isPyramides()) return pyrProjXZ !=null; else if(vs.isLines()) return new ProjUtils().isInited(lineProjXZ); else if(vs.isPoints()) return new ProjUtils().isInited(pointProjXZ); else if(vs.isCubes()) return new ProjUtils().isInited(cubeProjXZ); return false;} protected Point2D getP1() { if(vs.isTriangle()) return triProjXZ.getP1(); else if(vs.isFourCorners()) return fourProjXZ.getP1(); else if(vs.isPyramides()) return pyrProjXZ.getP1(); else if(vs.isLines()) return lineProjXZ[0].getP1(); else if(vs.isPoints()) return pointProjXZ[0]; else if(vs.isCubes()) return cubeProjXZ[0]; return null;} protected Point2D getP2() { if(vs.isTriangle()) return triProjXZ.getP2(); else if(vs.isFourCorners()) return fourProjXZ.getP2(); else if(vs.isPyramides()) return pyrProjXZ.getP2(); else if(vs.isLines()) return lineProjXZ[0].getP2(); else if(vs.isPoints()) return pointProjXZ[1]; else if(vs.isCubes()) return cubeProjXZ[1]; return null;} protected Point2D getP3() { if(vs.isTriangle()) return triProjXZ.getP3(); else if(vs.isFourCorners()) return fourProjXZ.getP3(); else if(vs.isPyramides()) return pyrProjXZ.getP3(); else if(vs.isLines()) return lineProjXZ[1].getP1(); else if(vs.isPoints()) return pointProjXZ[1+1]; else if(vs.isCubes()) return cubeProjXZ[1+1]; return null;} protected Point2D getP4() { if(vs.isTriangle()) return null; else if(vs.isFourCorners()) return fourProjXZ.getP4(); else if(vs.isPyramides()) return pyrProjXZ.getP4(); else if(vs.isLines()) return lineProjXZ[1].getP2(); else if(vs.isPoints()) return pointProjXZ[1+1+1]; else if(vs.isCubes()) return cubeProjXZ[1+1+1]; return null;} protected Point2D getP5() { if(vs.isPoints()) return pointProjXZ[1+1+1+1]; return null;} protected Point2D getP6() { if(vs.isPoints()) return pointProjXZ[1+1+1+1+1]; return null;} protected Point2D getP7() { if(vs.isPoints()) return pointProjXZ[1+1+1+1+1+1]; return null;} protected void drawViewItems(CanvasAdapter ics,PaintAdapter pn) { float zoom=1.f; Vector3 xzShift=Vector3.shiftXZ(ento.getDx(),ento.getDz()); if(lineProjXZ==null) lineProjXZ=new ProjLineXZ[1+1]; if(pointProjXZ==null) pointProjXZ=new ProjPointXZ[1+1+1+1+1+1+1]; if(cubeProjXZ==null) cubeProjXZ=new ProjCubeXZ[1+1+1+1]; if(vs.isTriangle()) { triProjXZ=vs.getAbd().triangleProjXZ(xzShift); triProjXZ.toPen(ics,pn.select(triProjXZ)); lastPoints(ics,pn,xzShift); pointProjXZ[1+1]=vs.getC().pointProjXZ(xzShift); pointProjXZ[1+1].toPen(ics,pn.select(pointProjXZ[1+1]));} else if(vs.isFourCorners()) { fourProjXZ=vs.getAbcd().fourProjXZ(xzShift); fourProjXZ.toPen(ics,pn.select(fourProjXZ)); lastPoints(ics,pn,xzShift);} else if(vs.isPyramides()) { pyrProjXZ=vs.getDabc().pyrProjXZ(xzShift); pyrProjXZ.toPen(ics,pn.select(pyrProjXZ)); lastPoints(ics,pn,xzShift);} else if(vs.isLines()) { lineProjXZ[0]=vs.getAb().lineProjXZ(xzShift); lineProjXZ[1]=vs.getCd().lineProjXZ(xzShift); lineProjXZ[0].toPen(ics,pn.select(lineProjXZ[0])); lineProjXZ[1].toPen(ics,pn.select(lineProjXZ[1])); lastPoints(ics,pn,xzShift);} else if(vs.isPoints()) { pointProjXZ[0]=vs.getA().pointProjXZ(xzShift); pointProjXZ[1]=vs.getB().pointProjXZ(xzShift); pointProjXZ[1+1]=vs.getC().pointProjXZ(xzShift); pointProjXZ[1+1+1]=vs.getD().pointProjXZ(xzShift); pointProjXZ[1+1+1+1]=vs.getE().pointProjXZ(xzShift); pointProjXZ[1+1+1+1+1]=vs.getF().pointProjXZ(xzShift); pointProjXZ[1+1+1+1+1+1]=vs.getG().pointProjXZ(xzShift); pointProjXZ[0].toPen(ics,pn.select(pointProjXZ[0])); pointProjXZ[1].toPen(ics,pn.select(pointProjXZ[1])); pointProjXZ[1+1].toPen(ics,pn.select(pointProjXZ[1+1])); pointProjXZ[1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1])); pointProjXZ[1+1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1+1])); pointProjXZ[1+1+1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1+1+1])); pointProjXZ[1+1+1+1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1+1+1+1]));} else if(vs.isCubes()) { cubeProjXZ[0]=vs.getA1().cubeProjXZ(xzShift); cubeProjXZ[1]=vs.getB1().cubeProjXZ(xzShift); cubeProjXZ[1+1]=vs.getC1().cubeProjXZ(xzShift); cubeProjXZ[1+1+1]=vs.getD1().cubeProjXZ(xzShift); cubeProjXZ[0].toPen(ics,pn.select(cubeProjXZ[0])); cubeProjXZ[1].toPen(ics,pn.select(cubeProjXZ[1])); cubeProjXZ[1+1].toPen(ics,pn.select(cubeProjXZ[1+1])); cubeProjXZ[1+1+1].toPen(ics,pn.select(cubeProjXZ[1+1+1])); lastPoints(ics,pn,xzShift);} drawSelection(ics,pn);} private void lastPoints(CanvasAdapter ics,PaintAdapter pn,Vector3 xzShift) { pointProjXZ[1+1+1+1]=vs.getE().pointProjXZ(xzShift); pointProjXZ[1+1+1+1+1]=vs.getF().pointProjXZ(xzShift); pointProjXZ[1+1+1+1+1+1]=vs.getG().pointProjXZ(xzShift); pointProjXZ[1+1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1+1])); pointProjXZ[1+1+1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1+1+1])); pointProjXZ[1+1+1+1+1+1].toPen(ics,pn.select(pointProjXZ[1+1+1+1+1+1]));} public String getInvertedName() { return "Bottom View";} protected Ester getSecondCoord() { return new Ester("z");} protected Ester getFirstCoord() { return new Ester("x");} public void toTop() { ento.add(Vector3.shiftXZ(0,-5));} public void toBottom() { ento.add(Vector3.shiftXZ(0,5));} public void toLeft() { ento.add(Vector3.shiftXZ(-5,0));} public void toRight() { ento.add(Vector3.shiftXZ(5,0));} public void toForward() {} public void toBackward() {} protected void movePlane(int mx,int my) { ento.add(Vector3.shiftXZ(-mx,-my));}} class AirField extends AbstractRoomSixWalls { public AirField(Point3D uc,int w,int h,int depth,int color,boolean solid,WallsProfile wallsProfile,VisibilityProfile visibilityProfile) { super(uc,w,h,depth,color,solid,wallsProfile,visibilityProfile);} public static AirField createSomeRoom(Rectangle2D areaWnd,int z,int depth,int ribsColor) { Point3D uc=new Point3D(areaWnd.w() / 2,areaWnd.h() / 2,z); return new AirField(uc,areaWnd.w(),areaWnd.h(),depth,ribsColor,false,new RoomCOknoProfile(ribsColor),null);}} class ItemViewCraft3D extends ProstoView implements RoomConsumer { public static final int CELL=18+1; public static final int STEP=(7-1+1) /(1+1); protected static int W12=1; protected static int H12=2; protected static int SPS=3; protected short cx; protected short cy; private OrderedSpiskaZ qyoubeecle=new OrderedSpiskaZ(); private Rectangle2D area=new Rectangle2D(0,0); private Rectangle2D log=new Rectangle2D(0,0); private Rectangle2D mon=new Rectangle2D(0,0); private Queue laterOverdrawCubes=new Queue(); private short wx; private short wy; private short wz; private short rx1; private short rx2; private short ry1; private short ry2; private short h1; private short h2; private Dimension lastSize; private Rectangle2D areaWnd; ResultsOxyzPanel res=new ResultsOxyzPanel(); public ItemViewCraft3D(String viewName,CommonCanvas where,VirtualScene vs,CraftViewPanelsRepainter projPanelRep) { super(viewName,where,true,vs,projPanelRep); this.wx=0; this.wy=115; this.wz=30; qyoubeecle.append(vs.getCraftModel().getAll());} protected void crossDraw(CanvasAdapter ics,PaintAdapter pn,Dimension d1) {} protected void drawController(CanvasAdapter ics,PaintAdapter pn) {} protected void drawLinears(CanvasAdapter ics,PaintAdapter pn) {} protected void movePlane(int mx,int my) {} protected ProstoZacepit createController() { return null;} public void updateBase(Rectangle2D area) { W12=area.w() / 100 *(STEP *(1+1)); H12=area.h() / 100 *(STEP *(1+1));} public String getInvertedName() { return null;} protected void crossDraw(Graphics cs1,Dimension d1) {} protected Ester getSecondCoord() { return null;} protected Ester getFirstCoord() { return null;} void recount1(short right,short bottom) { short left=0; short top=0; rx1=(short)(SPS); ry1=(short)(SPS); rx2=(short)(right-SPS-SPS-(right-left-SPS-SPS) / 4); ry2=(short)(bottom-top-SPS-SPS-(bottom-top-SPS-SPS-SPS-26) / 4); cx=(short)(area.x()+area.w() / 2); cy=(short)(area.y()+area.h() / 2); h1=(short)(cy+(ry1+ry2) / 23); h2=(short)(ry2-h1);} void resize1(short right,short bottom) { short left=0; short top=0; short filePathX=(short)(left+SPS); short filePathY=(short)(top+SPS); short filePathWidth=(short)(right-left-SPS-SPS); short contentHeight=(short)(bottom-top-SPS-SPS); short elementsWidth=(short)(filePathWidth / 4); short ctrlHeight=(short)(contentHeight / 4); ctrlHeight=0; log.update(new Point2D(filePathX,filePathY+contentHeight-ctrlHeight),filePathWidth-elementsWidth,ctrlHeight); elementsWidth=0; mon.update(new Point2D(filePathX+filePathWidth-elementsWidth,filePathY),elementsWidth,contentHeight-ctrlHeight); area.update(new Point2D(filePathX,filePathY),mon.x()-filePathX-SPS,log.y()-filePathY-SPS);} public void setText() {} public AbstractRoomSixWalls roomSvc(int width,int height) { int Z0=getZ0(); int DEPTH=getDepth(); Rectangle2D areaWnd=obtainAreaWnd(width,height); AbstractRoomSixWalls result; vs.setAiSc(result=AirField.createSomeRoom(areaWnd,Z0,DEPTH,ColorsArray.bluePoint.ic())); return result;} public int getSPS() { int SPS=3-1-1-1; return SPS;} public int getZ0() { int Z0=-5+5; return Z0;} public int getDepth() { int DEPTH=2400 / 5; return DEPTH;} public Rectangle2D obtainAreaWnd(int width,int height) { int SPS=getSPS(); Rectangle2D areaWnd=new Rectangle2D(1-1,1-1); areaWnd.update(new Point2D(SPS,SPS),width-SPS-SPS,height-SPS-SPS); return areaWnd;} protected void newSizeArrive(short width,short height) { roomSvc(width,height);} protected void drawViewItems(CanvasAdapter ics,PaintAdapter pn) { res.updateSelection(vs.cfg); Dimension d=where.size(); Color hPen2=CraftProps.objRibs; if(d.equals(lastSize)==false) { lastSize=d; resize1((short) d.width,(short) d.height); recount1((short) d.width,(short) d.height); areaWnd=obtainAreaWnd(d.width,d.height); updateBase(area); if(vs.isEmptyScan()) roomSvc(d.width,d.height);} vs.getAiSc().toPen(ics,pn.select(vs.getAiSc()).reshape(areaWnd)); CraftVertEx[] items=qyoubeecle.items(); for(int i=0; i < items.length; i++) { CraftVertEx ol=items[i]; bus(ol,hPen2,ics,pn,res);} if(vs.isCubes()) { ResultsOxyzPanel resFalse=res.copyFalse(); bus(vs.getA1(),hPen2,ics,pn,resFalse); bus(vs.getB1(),hPen2,ics,pn,resFalse); bus(vs.getC1(),hPen2,ics,pn,resFalse); bus(vs.getD1(),hPen2,ics,pn,resFalse);} laterOverdraw(ics,pn); Colorfull curFig=vs.getCurrentFigure(); curFig.toPen(ics,pn.select(curFig));} protected boolean processItemSelection(MouseClickEvent mce) { CraftVertEx[] items=qyoubeecle.items(); for(int i=0; i < items.length; i++) { CraftVertEx cubeItem=items[i]; if(cubeItem.mouseClickIntercept(mce)) cubeItem.activate(); else cubeItem.deactivate();} if(vs.peekRedrawFlag()) repaintRequest(false); return CraftVertEx.getActive() !=null;} private CurPtr msCaptured; protected void processItemCapture(MouseClickEvent tse) { msCaptured=tse.getMs();} protected void processItemRelease(MouseClickEvent tse) { Point3D activeReleasedCenter=CraftVertEx.getActive().getCenter(); CurPtr msReleased=tse.getMs(); Vector3 relocVect; if(tse.isCtrlMask()) relocVect=Vector3.shiftZ((msReleased.dx(msCaptured)+msReleased.dy(msCaptured)) / 2); else relocVect=Vector3.shiftXY(msReleased.dx(msCaptured),msReleased.dy(msCaptured)); activeReleasedCenter.shift(relocVect);} private void laterOverdraw(CanvasAdapter ics,PaintAdapter pn) { Object[] queueRecordsArray=laterOverdrawCubes.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { Object obj=queueRecordsArray[i]; if(obj instanceof LaterOverDraw) { LaterOverDraw up7=(LaterOverDraw) obj; up7.draw(ics,pn);}} this.laterOverdrawCubes.clearQueue();} void bus(CraftVertEx cve,Color hPen2,CanvasAdapter ics,PaintAdapter pn,SqProjProfile sqProf) { float lx; float ly; float lx2; float ly2; float cply; float cply2; float cplx; float cplx2; float ax1; float ax2; float ay1; float ay2; float bx1; float bx2; float by1; float by2; int i; float dl; short uax=(short) cve.x(); short uay=(short) cve.y(); short uaz=(short) cve.z(); SqProjsRepo projections=cve.getProjsRepo(); ax1=0; ay1=0; ax2=0; ay2=0; bx1=0; by1=0; bx2=0; by2=0; i=wz-uaz; if(i==wz-uaz) { lx=area.x()+(float) i / 300 *(area.w() / 2-W12); ly=area.y()+area.h()-(float) i / 300 *(area.h() / 2-H12); lx2=area.x()+area.w()-(float) i / 300 *(area.w() / 2-W12); ly2=area.y()+(float) i / 300 *(area.h() / 2-H12); if(sqProf.isStripeX()) { projections.getStripeX().regFirstConture(lx,ly,lx2,ly,lx2,ly2,lx,ly2); projections.getStripeX().readyDraw(ics,pn);} cply=ly; cply2=ly2; cplx=lx; cplx2=lx2; if(true || sqProf.isBulkX()) { ly=area.y()+area.h() / 2; ly2=uay-wy; ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); if(ly+ly2 >= cply2 && ly+ly2 <= cply) { projections.getLeft().setP1(lx,ly+ly2); projections.getRight().setP4(lx2,ly+ly2);} ly=area.y()+area.h() / 2; ly2=uay-wy-cve.yLn(); ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); if(ly+ly2 >= cply2 && ly+ly2 <= cply) { projections.getLeft().setP2(lx,ly+ly2); projections.getRight().setP3(lx2,ly+ly2);}} if(true || sqProf.isBulkY()) { lx=area.x()+area.w() / 2; lx2=uax-wx; lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); if(lx-lx2 <= cplx2 && lx-lx2 >= cplx) { projections.getFloor().setP1(lx-lx2,cply); projections.getCeiling().setP1(lx-lx2,cply2);} lx=area.x()+area.w() / 2; lx2=uax-wx-cve.xLn(); lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); if(lx-lx2 <= cplx2 && lx-lx2 >= cplx) { projections.getFloor().setP4(lx-lx2,cply); projections.getCeiling().setP2(lx-lx2,cply2);}} lx=area.x()+area.w() / 2; lx2=uax-wx; lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); ax1=lx-lx2; lx=area.x()+area.w() / 2; lx2=uax-wx-cve.xLn(); lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); ax2=lx-lx2; ly=area.y()+area.h() / 2; ly2=uay-wy-cve.yLn(); ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); ay1=ly+ly2; ly=area.y()+area.h() / 2; ly2=uay-wy; ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); ay2=ly+ly2; cve.regNearPlane(ax1,ay1,ax2,ay2);} do { dl=(float) cve.zLn() * H12 /(area.h() / 2)+(cve.zLn()-(float) cve.zLn() * H12 /(area.h() / 2)) *(float)(300-i) / 300;} while(i <= 300 && i++<= wz+dl-uaz); if(i >= wz+dl-uaz) { lx=area.x()+(float) i / 300 *(area.w() / 2-W12); ly=area.y()+area.h()-(float) i / 300 *(area.h() / 2-H12); lx2=area.x()+area.w()-(float) i / 300 *(area.w() / 2-W12); ly2=area.y()+(float) i / 300 *(area.h() / 2-H12); if(sqProf.isStripeX()) { projections.getStripeX().regSecondConture(lx,ly,lx2,ly,lx2,ly2,lx,ly2); projections.getStripeX().readyDraw(ics,pn);} cply=ly; cply2=ly2; cplx=lx; cplx2=lx2; if(true || sqProf.isBulkX()) { ly=area.y()+area.h() / 2; ly2=uay-wy; ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); if(ly+ly2 >= cply2 && ly+ly2 <= cply) { projections.getLeft().setP4((short) lx,(short)(ly+ly2)); projections.getRight().setP1((short) lx2,(short)(ly+ly2));} ly=area.y()+area.h() / 2; ly2=uay-wy-cve.yLn(); ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); if(ly+ly2 >= cply2 && ly+ly2 <= cply) { projections.getLeft().setP3(lx,ly+ly2); projections.getRight().setP2(lx2,ly+ly2);}} if(true || sqProf.isBulkY()) { lx=area.x()+area.w() / 2; lx2=uax-wx; lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); if(lx-lx2 <= cplx2 && lx-lx2 >= cplx) { projections.getFloor().setP2((short)(lx-lx2),(short) cply); projections.getCeiling().setP4((short)(lx-lx2),(short) cply2);} lx=area.x()+area.w() / 2; lx2=uax-wx-cve.xLn(); lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); if(lx-lx2 <= cplx2 && lx-lx2 >= cplx) { projections.getFloor().setP3(lx-lx2,cply); projections.getCeiling().setP3(lx-lx2,cply2);}} lx=area.x()+area.w() / 2; lx2=uax-wx; lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); bx1=lx-lx2; lx=area.x()+area.w() / 2; lx2=uax-wx-cve.xLn(); lx2=lx2-(float) i / 300 *(lx2-(float) W12 /(area.w() / 2) * lx2); bx2=lx-lx2; ly=area.y()+area.h() / 2; ly2=uay-wy-cve.yLn(); ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); by1=ly+ly2; ly=area.y()+area.h() / 2; ly2=uay-wy; ly2=ly2-(float) i / 300 *(ly2-(float) H12 /(area.h() / 2) * ly2); by2=ly+ly2; cve.regDistPlane(bx1,by1,bx2,by2);} i=uax-wx; if(i==uax-wx) { lx=area.x()+area.w() / 2-i; ly=area.y()+area.h(); lx2=area.x()+area.w() / 2-(float) i /(area.w() / 2) *(W12); ly2=area.y()+area.h()-(float) 300 / 300 *(area.h() / 2-H12); if(sqProf.isStripeY()) { projections.getStripeY().regFirstConture(lx,ly,lx2,ly2,lx2,ly2-2 * H12,lx,ly-area.h()); projections.getStripeY().readyDraw(ics,pn); registerLaterOverdrawLine(lx,ly-area.h(),lx,ly,CraftProps.projections);} if(true || sqProf.isBulkZ()) { if(ly-area.h() / 2-(wy+cve.yLn()-uay) >= area.y() && ly-area.h() / 2-(wy+cve.yLn()-uay) <= area.y()+area.h()) { projections.getNear().setP2(lx,ly-area.h() / 2-(wy+cve.yLn()-uay)); projections.getDist().setP2(lx2,ly2-(float)(wy+cve.yLn()-uay+area.h() / 2) /(area.h() / 2) * H12);} if(ly-area.h() / 2-(wy-uay) >= area.y() && ly-area.h() / 2-(wy-uay) <= area.y()+area.h()) { projections.getNear().setP1(lx,ly-area.h() / 2-(wy-uay)); projections.getDist().setP1(lx2,ly2-(float)(wy-uay+area.h() / 2) /(area.h() / 2) * H12);}}} i=uax-wx-cve.xLn(); if(i==uax-wx-cve.xLn()) { lx=area.x()+area.w() / 2-i; ly=area.y()+area.h(); lx2=area.x()+area.w() / 2-(float) i /(area.w() / 2) *(W12); ly2=area.y()+area.h()-(float) 300 / 300 *(area.h() / 2-H12); if(sqProf.isStripeY()) { projections.getStripeY().regSecondConture(lx,ly,lx2,ly2,lx2,ly2-2 * H12,lx,ly-area.h()); projections.getStripeY().readyDraw(ics,pn); registerLaterOverdrawLine(lx,ly-area.h(),lx,ly,CraftProps.projections);} if(true || sqProf.isBulkZ()) { if(ly-area.h() / 2-(wy+cve.yLn()-uay) >= area.y() && ly-area.h() / 2-(wy+cve.yLn()-uay) <= area.y()+area.h()) { projections.getNear().getP3().moveTo((short) lx,(short)(ly-area.h() / 2-(wy+cve.yLn()-uay))); projections.getDist().setP3((short) lx2,(short)(ly2-(float)(wy+cve.yLn()-uay+area.h() / 2) /(area.h() / 2) * H12));} if(ly-area.h() / 2-(wy-uay) >= area.y() && ly-area.h() / 2-(wy-uay) <= area.y()+area.h()) { projections.getNear().setP4(lx,ly-area.h() / 2-(wy-uay)); projections.getDist().setP4(lx2,ly2-(float)(wy-uay+area.h() / 2) /(area.h() / 2) * H12);}}} if(sqProf.isStripeZ()) { i=wy+cve.yLn()-uay; if(i==wy+cve.yLn()-uay) { registerLaterOverdrawLine(area.x(),area.y()+area.h() / 2-i,area.x()+area.w(),area.y()+area.h() / 2-i,CraftProps.projections); lx=area.x()+area.w() / 2+W12; ly=area.y()+area.h() / 2-(float) i /(area.h() / 2) * H12; projections.getStripeZ().regFirstConture(area.x()+area.w(),area.y()+area.h() / 2-i,lx,ly,lx-2 * W12,ly,area.x(),area.y()+area.h() / 2-i); projections.getStripeZ().readyDraw(ics,pn);} i=wy-uay; if(i==wy-uay) { registerLaterOverdrawLine(area.x(),area.y()+area.h() / 2-i,area.x()+area.w(),area.y()+area.h() / 2-i,CraftProps.projections); lx=area.x()+area.w() / 2+W12; ly=area.y()+area.h() / 2-(float) i /(area.h() / 2) * H12; projections.getStripeZ().regSecondConture(area.x()+area.w(),area.y()+area.h() / 2-i,lx,ly,lx-2 * W12,ly,area.x(),area.y()+area.h() / 2-i); projections.getStripeZ().readyDraw(ics,pn);}} projections.getCeiling().encryptSimple(); drawAllExceptNear(sqProf,ics,pn,projections); if(sqProf.isBulkX()) { projections.getBulkX().regFar1(projections.getLeft().getP3(),projections.getRight().getP2()); projections.getBulkX().regFar2(projections.getLeft().getP4(),projections.getRight().getP1()); projections.getBulkX().readyDrawFar(ics,pn);} if(sqProf.isBulkY()) { projections.getBulkY().regFar1(projections.getCeiling().getP1(),projections.getFloor().getP2()); projections.getBulkY().regFar2(projections.getCeiling().getP4(),projections.getFloor().getP3()); projections.getBulkY().readyDrawFar(ics,pn);} if(sqProf.isBulkZ()) { projections.getBulkZ().regFar1(projections.getNear().getP1(),projections.getDist().getP1()); projections.getBulkZ().regFar2(projections.getNear().getP2(),projections.getDist().getP2()); projections.getBulkZ().readyDrawFar(ics,pn); projections.getBulkZ().regNear1(projections.getNear().getP3(),projections.getDist().getP3()); projections.getBulkZ().regNear2(projections.getNear().getP4(),projections.getDist().getP4()); projections.getBulkZ().readyDrawNear(ics,pn);} registerLaterOverdraw(cve); if(sqProf.isBulkX()) { projections.getBulkX().regNear1(projections.getLeft().getP1(),projections.getRight().getP4()); projections.getBulkX().regNear2(projections.getLeft().getP2(),projections.getRight().getP3()); registerLaterOverdrawBulk(projections.getBulkX());} if(sqProf.isBulkY()) { projections.getBulkY().regNear1(projections.getCeiling().getP2(),projections.getFloor().getP1()); projections.getBulkY().regNear2(projections.getCeiling().getP3(),projections.getFloor().getP4()); registerLaterOverdrawBulk(projections.getBulkY());} if(sqProf.isProjNearZ()) { registerLaterOverdrawNear(projections.getNear());}} private void drawAllExceptNear(SqProjProfile oxyzPanel,CanvasAdapter ics,PaintAdapter pn,SqProjsRepo projections) { if(oxyzPanel.isProjLeftX()) { projections.getLeft().toPen(ics,pn); projections.getRight().toPen(ics,pn);} if(oxyzPanel.isProjUpY()) { projections.getCeiling().toPen(ics,pn); projections.getFloor().toPen(ics,pn);} if(oxyzPanel.isProjFarZ()) projections.getDist().toPen(ics,pn);} private void registerLaterOverdraw(CraftVertEx active) { LaterOverDraw laterActive=new LaterOverDraw(active); laterOverdrawCubes.enqueueQueueRecord(laterActive);} private void registerLaterOverdrawLine(float lx,float f,float lx2,float ly,Color projections) {} private void registerLaterOverdrawLine(int x,int i,int j,int k,Color projections) {} private void registerLaterOverdrawBulk(SqProjBulk bulkY) {} private void registerLaterOverdrawNear(SqProj near) {} public boolean hasSomeSpace() { return vs.isEmptyScan()==false;} public AirField getSpace() { return(AirField) vs.getAiSc();}} class LocationField extends TextField implements UpdateConsumer { private WireCoord seeFirst; private WireCoord seeSecond; public LocationField(int columns,WireCoord seeFirst,WireCoord seeSecond) { super(columns); setEditable(false); this.seeFirst=seeFirst; this.seeSecond=seeSecond; seeFirst.bindConsumer(this); seeSecond.bindConsumer(this); toScreen();} public void consume(String item) {} public void setFirstSee(String value) { seeFirst.setValue(value);} public void setSecondSee(String value) { seeSecond.setValue(value);} private void toScreen() { String repr=""+seeFirst+","+seeSecond+",0,0"; setText(repr);} public WireCoord getSeeFirst() { return seeFirst;} public WireCoord getSeeSecond() { return seeSecond;}} class CraftSelectViewPanel extends Panel { static final String VIEW_FRONT="Front View"; static final String VIEW_LEFT="Left View"; static final String VIEW_TOP="Top View"; static final String VIEW_3D="3D View"; Choice chView; LocationField tfLocation; ProProvider proProvider; public CraftSelectViewPanel(String viewName,WireCoord seeFirst,WireCoord seeSecond,ProProvider proProvider) { super(); setLayout(new BorderLayout()); setBackground(Color.lightGray); this.proProvider=proProvider; this.chView=obtainChoice(viewName); add("Center",chView); if(new Ester(viewName).nteq(new Ester(VIEW_3D))) add("East",tfLocation=new LocationField(5+5,seeFirst,seeSecond));} public void setFirstSee(String value) { tfLocation.setFirstSee(value);} public void setSecondSee(String value) { tfLocation.setSecondSee(value);} private Choice obtainChoice(String viewName) { Choice ch=new Choice(); if(proProvider.getPro()) { ch.addItem(VIEW_FRONT); ch.addItem(VIEW_LEFT); ch.addItem(VIEW_TOP);} ch.addItem(VIEW_3D); ch.select(viewName); return ch;} public Choice getChView() { return chView;}} class CraftViewSourcePanel extends AbstractApproach implements SourceProcessor { CraftSelectViewPanel selViewPanel; CraftViewCanvas cvCanvas; LoggingVkusnjashki logPanel; private String name; private String path; private CommandPlugQueue cq=new CommandPlugQueue(); public CraftViewSourcePanel(CraftViewCanvas itemView,LoggingVkusnjashki logPanel,String viewName,WireCoord seeFirst,WireCoord seeSecond,ProProvider proProvider) { super(); this.logPanel=logPanel; setLayout(new BorderLayout()); setBackground(Color.lightGray); if(proProvider.isSingle3D()==false) add("North",selViewPanel=new CraftSelectViewPanel(viewName,seeFirst,seeSecond,proProvider)); add("Center",cvCanvas=itemView);} public CraftSelectViewPanel getSelViewPanel() { return selViewPanel;} public void process(boolean needSave) {} public void saveSourceLine() {} public boolean isReadyFree() { return true;} public LoggingVkusnjashki getLogPanel() { return logPanel;} public Choice getChView() { return selViewPanel.getChView();} public boolean handleEvent(Event et) { if(et.id==Event.ACTION_EVENT && et.target==getChView()) changeView(); return super.handleEvent(et);} private void changeView() { String selectedItem=selViewPanel.getChView().getSelectedItem(); if(selectedItem.equalsIgnoreCase(CraftSelectViewPanel.VIEW_FRONT)) cvCanvas.switchFront(); else if(selectedItem.equalsIgnoreCase(CraftSelectViewPanel.VIEW_LEFT)) cvCanvas.switchLeft(); else if(selectedItem.equalsIgnoreCase(CraftSelectViewPanel.VIEW_TOP)) cvCanvas.switchTop(); else if(selectedItem.equalsIgnoreCase(CraftSelectViewPanel.VIEW_3D)) cvCanvas.switch3D();} public String getName() { return name;} public String getPath() { return path;} public void doIt(Params params) { if(params !=null) { if(params.areYou(LimStatParallelPanel.CMD_INIT_SRC)) initSource(params.getParam("name"),params.getParam("path")); else if(params.areYou(LimStatParallelPanel.CMD_READ_SRC)) readSource(params.getParam("name"),params.getParam("path"),params.getParam("looking"),params.getParam("relPath"),params.getParamInteger("idxSel").intValue());}} public void clearPanel() {} public void initSource(String name,String path) { readSource("","","","",0);} public void readSource(String name,String path,String looking,String relPath,int idxSel) { CommandPlug cmd=new ReadCommandPlug(name,path); cq.push(cmd); if(worker1==null) { worker1=new Thread(this); worker1.start();}} public static String line(String path) throws IOException { return "";} public static String loadSource(String path) throws IOException { return "";} private void interpret(CommandPlug cmd) { switch(cmd.getId()) { case CommandPlug.ID_READY : break; case CommandPlug.ID_INIT : break; case CommandPlug.ID_READ_SOURCE : break; case CommandPlug.ID_ONELINE : break; case CommandPlug.ID_SAVE_SOURCE : break;}} public void run() { while(Better.working) { if(cq.hasSomeWork()) { CommandPlug cmd=cq.nextCurrent(); interpret(cmd);} sleeper.sleep(5 * 5);}}} class CraftViewChangeRequest { private ItemCraftTopView topView; private ItemCraftLeftView leftView; private ItemCraftFrontView frontView; private ItemViewCraft3D view3d; public CraftViewChangeRequest() {} public void switch3D(CraftViewCanvas viewCanvas) { viewCanvas.changeView(view3d);} public void switchTop(CraftViewCanvas viewCanvas) { viewCanvas.changeView(topView);} public void switchLeft(CraftViewCanvas viewCanvas) { viewCanvas.changeView(leftView);} public void switchFront(CraftViewCanvas viewCanvas) { viewCanvas.changeView(frontView);} public void register3D(ItemViewCraft3D itemViewCraft3D) { this.view3d=itemViewCraft3D;} public void registerTop(ItemCraftTopView itemCraftView) { this.topView=itemCraftView;} public void registerLeft(ItemCraftLeftView itemCraftView) { this.leftView=itemCraftView;} public void registerFront(ItemCraftFrontView itemCraftView) { this.frontView=itemCraftView;}} class CraftViewCanvas extends CommonCanvas { private ProstoView view; private CraftViewChangeRequest viewChangeReq; public CraftViewCanvas(int bgLightBuilder,Color borderColor) { super(new Color(bgLightBuilder),borderColor);} public boolean mouseMove(Event et,int mx,int my) { view.mouseMovings(et,mx,my); return super.mouseMove(et,mx,my);} public boolean mouseEnter(Event et,int mx,int my) { view.mouseEnterings(et,mx,my); return super.mouseEnter(et,mx,my);} public boolean mouseExit(Event et,int mx,int my) { view.mouseExitings(et,mx,my); return super.mouseExit(et,mx,my);} public boolean mouseDown(Event et,int mx,int my) { view.mouseDownings(et,mx,my); return super.mouseDown(et,mx,my);} public boolean mouseUp(Event et,int mx,int my) { view.mouseUpings(et,mx,my); return super.mouseUp(et,mx,my);} public void changeView(ProstoView frontView) { this.view=frontView;} public void switch3D() { if(viewChangeReq !=null) viewChangeReq.switch3D(this);} public void switchTop() { if(viewChangeReq !=null) viewChangeReq.switchTop(this);} public void switchLeft() { if(viewChangeReq !=null) viewChangeReq.switchLeft(this);} public void switchFront() { if(viewChangeReq !=null) viewChangeReq.switchFront(this);} public CraftViewCanvas(Color borderdimensionalview3) { super(borderdimensionalview3,borderdimensionalview3);} public void clearItems() { if(view !=null) view.clearItems();} protected void drawItems(CanvasAdapter ics,PaintAdapter pn) { if(view !=null) view.drawItems(ics,pn);} protected void newSizeArrive(short width,short height) { if(view !=null) view.newSizeArrive(width,height);} public void setupViews(ProstoView view,CraftViewChangeRequest viewChangeRequest) { this.view=view; this.viewChangeReq=viewChangeRequest;} public ProstoView getView() { return view;}} class LimStatApproachProvider implements AbstractApproachProvider { LoggingVkusnjashki logPanel; private int curView; private ItemViewCraft3D view3D; private VirtualScene virtScene; private CraftViewPanelsRepainter allRepainter; private CraftViewChangeRequest viewChangeRq; private ProProvider pro; public LimStatApproachProvider(LoggingVkusnjashki logPanel,ProProvider pro) { super(); this.logPanel=logPanel; CraftModel model=new CraftModel(); this.virtScene=new VirtualScene(model); model.setActivationListener(virtScene); this.curView=0; this.allRepainter=new CraftViewPanelsRepainter(); this.viewChangeRq=new CraftViewChangeRequest(); this.pro=pro;} public AbstractApproach provideApproach() { String viewName=""; WireCoord seeFirst=WireCoord.nC; WireCoord seeSecond=WireCoord.nC; CraftViewCanvas where=null; if(curView > 3-(pro.getPro() ? 0 : 1+1+1)) curView=0; switch(curView++) { case 3 : where=new CraftViewCanvas(CraftProps.bgLightBuilder,CraftProps.borderWhiteBuilder); ItemCraftFrontView itemCraftFrontView=new ItemCraftFrontView(CraftSelectViewPanel.VIEW_FRONT,where,virtScene,allRepainter); seeFirst=itemCraftFrontView.getSeeFirst(); seeSecond=itemCraftFrontView.getSeeSecond(); viewChangeRq.registerFront(itemCraftFrontView); where.setupViews(itemCraftFrontView,viewChangeRq); allRepainter.reg4modelUpdate(where); viewName=itemCraftFrontView.getViewName(); break; case 1 : where=new CraftViewCanvas(CraftProps.bgLightBuilder,CraftProps.borderWhiteBuilder); ItemCraftLeftView itemCraftLeftView=new ItemCraftLeftView(CraftSelectViewPanel.VIEW_LEFT,where,virtScene,allRepainter); seeFirst=itemCraftLeftView.getSeeFirst(); seeSecond=itemCraftLeftView.getSeeSecond(); viewChangeRq.registerLeft(itemCraftLeftView); where.setupViews(itemCraftLeftView,viewChangeRq); allRepainter.reg4modelUpdate(where); viewName=itemCraftLeftView.getViewName(); break; case 2 : where=new CraftViewCanvas(CraftProps.bgLightBuilder,CraftProps.borderWhiteBuilder); ItemCraftTopView itemCraftTopView=new ItemCraftTopView(CraftSelectViewPanel.VIEW_TOP,where,virtScene,allRepainter); seeFirst=itemCraftTopView.getSeeFirst(); seeSecond=itemCraftTopView.getSeeSecond(); viewChangeRq.registerTop(itemCraftTopView); where.setupViews(itemCraftTopView,viewChangeRq); allRepainter.reg4modelUpdate(where); viewName=itemCraftTopView.getViewName(); break; case 0 : where=new CraftViewCanvas(CraftProps.bgLightBuilder,CraftProps.borderWhiteBuilder); view3D=new ItemViewCraft3D(CraftSelectViewPanel.VIEW_3D,where,virtScene,allRepainter); viewChangeRq.register3D(view3D); where.setupViews(view3D,viewChangeRq); allRepainter.reg4modelUpdate(where); viewName=view3D.getViewName(); break;} return new CraftViewSourcePanel(where,logPanel,viewName,seeFirst,seeSecond,pro);} public void refreshUpdatable() { if(view3D !=null && view3D.hasSomeSpace()) { virtScene.animateWay(); allRepainter.modelUpdated();}} public void setCurrentPoints(Point3D point,Point3D point2,Point3D point3,Point3D point4) { virtScene.setCurrentPoints(point,point2,point3,point4); allRepainter.modelUpdated();} public void setCurrentPoints(ColorfulShapeSet pointSet) { virtScene.setCurrentPoints(pointSet); allRepainter.modelUpdated();} public void setCurrentLines(Line3D line,Line3D line2) { virtScene.setCurrentLines(line,line2); allRepainter.modelUpdated();} public void setCurrentLines(ColorfulShapeSet lineSet) { virtScene.setCurrentLines(lineSet); allRepainter.modelUpdated();} public void setCurrentTri(Triangle3D tri) { virtScene.setCurrentTri(tri); allRepainter.modelUpdated();} public void setCurrentFour(FourCornersConture3D fc) { virtScene.setCurrentFour(fc); allRepainter.modelUpdated();} public void setCurrentPyramid(Pyramid pyramid) { virtScene.setCurrentPyr(pyramid); allRepainter.modelUpdated();} public void setCurrentCubes(ColorfulShapeSet cubeSet) { virtScene.setCurrentCubes(cubeSet); allRepainter.modelUpdated();} public void setCurrentFigureChoice(CasualType curSelShape,String curSelFilling) { virtScene.setCurrentFigureChoice(curSelShape,curSelFilling); allRepainter.modelUpdated();} public void setCurrentFillingChoice(String selectedFilling) { virtScene.setCurrentFillingChoice(selectedFilling); allRepainter.modelUpdated();} public void setCurrentSpeed(String selectedSpeed) { virtScene.changeCurrentSpeed(selectedSpeed); allRepainter.modelUpdated();} public void setCurrentWay(PathType selectedWay) { virtScene.getCurrentMotion().changeWay(selectedWay); allRepainter.modelUpdated();} public void setCurrentForm(AirFormation selectedForm) { virtScene.getCurrentMotion().changeForm(selectedForm); allRepainter.modelUpdated();} public void changeProjections(ProjectionsConfig cfg) { virtScene.changeProjections(cfg); allRepainter.modelUpdated();}} class LimStatParallelPanel extends AbstractParallelPanel { static final String CMD_INIT_SRC="initSource"; static final String CMD_READ_SRC="readSource"; static LoggingVkusnjashki logPanel; private LimStatApproachProvider approachProvider; private static ProProvider pro; LimStatParallelPanel(int nWidth,int nHeight) { super(nWidth,nHeight);} public static LimStatParallelPanel create(boolean quade,LoggingVkusnjashki lineLogging,boolean superck,ProProvider pro) { if(lineLogging !=null) LimStatParallelPanel.logPanel=lineLogging; LimStatParallelPanel.pro=pro; pro.setQuade(quade); return quade ? new LimStatParallelPanel(2 *(superck ? 8 : 1),2 *(superck ? 13 : 1)) : new LimStatParallelPanel(1,1);} protected synchronized AbstractApproachProvider obtainProvider() { if(approachProvider==null) approachProvider=new LimStatApproachProvider(logPanel,pro); return approachProvider;} public synchronized LimStatApproachProvider getApproachProvider() { if(approachProvider==null) obtainProvider(); return approachProvider;} public void refreshUpdatable() { getApproachProvider().refreshUpdatable();} public void setCurrentTri(Triangle3D tri) { getApproachProvider().setCurrentTri(tri);} public void setCurrentFour(FourCornersConture3D fc) { getApproachProvider().setCurrentFour(fc);} public void setCurrentCubes(ColorfulShapeSet pointSet) { getApproachProvider().setCurrentCubes(pointSet);} public void setCurrentPoints(ColorfulShapeSet pointSet) { getApproachProvider().setCurrentPoints(pointSet);} public void setCurrentLines(ColorfulShapeSet lineSet) { getApproachProvider().setCurrentLines(lineSet);} public void setCurrentPyr(Pyramid pyr) { getApproachProvider().setCurrentPyramid(pyr);} public void setCurrentLine(Line3D line,Line3D line2) { getApproachProvider().setCurrentLines(line,line2);} public void setCurrentPoint(Point3D point,Point3D point2,Point3D point3,Point3D point4) { getApproachProvider().setCurrentPoints(point,point2,point3,point4);} public void setCurrentFigureChoice(CasualType curSelShape,String curSelFilling) { getApproachProvider().setCurrentFigureChoice(curSelShape,curSelFilling);} public void setCurrentFillingChoice(String curSel) { getApproachProvider().setCurrentFillingChoice(curSel);} public void setCurrentSpeed(String curSel) { getApproachProvider().setCurrentSpeed(curSel);} public void setCurrentWay(PathType curSel) { getApproachProvider().setCurrentWay(curSel);} public void setCurrentForm(AirFormation curSel) { getApproachProvider().setCurrentForm(curSel);} public void changeProjections(ProjectionsConfig cfg) { getApproachProvider().changeProjections(cfg);}} class CraftProps extends Props { public static final Color borderWhiteBuilder=null; public static final int bgLightBuilder=mydev.about.Color.middleColor(ColorsArray.whitePoint.ic(),mydev.about.Color.middleColor(ColorsArray.whitePoint.ic(),mydev.about.Color.middleColor(ColorsArray.whitePoint.ic(),ColorsArray.lightGrayPoint.ic()))); public static final Color projections=Color.white; public static final int crossColor=mydev.about.Color.middleColor(mydev.about.Color.middleColor(ColorsArray.bluePoint.ic(),ColorsArray.darkGrayPoint.ic()),mydev.about.Color.middleColor(ColorsArray.bluePoint.ic(),ColorsArray.blackPoint.ic())); public static final Color lineColorVirtualSpace=new Color(34,34,144); public static final int lineColorVirtualProjection=objRibs.getRGB(); public static final int textColorVirtualCoords=lineColorVirtualSpace.getRGB(); public static final int LV_DY=40; public static final int LV_DZ=140; public static final int TV_DX=180-40; public static final int TV_DZ=180-40; public static final int FV_DX=120; public static final int FV_DY=10-15; public static final int ZHO_PIO_SHELL=5+5+5; public static final int OO_IKS=5+1+1;} class PointLabel extends Text2D { public PointLabel(Point2D labelPoint,String name,String text,int textColor) { super(labelPoint,""+name+text,textColor);}} interface CornerLabels { public static final int between=10; public static final int pointR=5; PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint);} abstract class ProjPoint extends Point2D implements CornerLabels { protected Point2D pProjA; protected Text2D cTextA; protected Circle2D reprA; protected Vector3 sh; public ProjPoint(Point3D pA,String nameA,int color,int textColor,Vector3 sh) { super(new Point2D(1-1,1-1),color); this.sh=sh; initProjText(textColor,pA,nameA); update(pProjA);} protected abstract void initProjText(int textColor,Point3D pA,String nameA); public void toPen(CanvasAdapter ics,PaintAdapter pn) { super.toPen(ics,pn.select(this)); reprA.toPen(ics,pn.select(reprA)); cTextA.toPen(ics,pn.select(cTextA));}} class ProjPointXY extends ProjPoint { public ProjPointXY(Point3D pA,String nameA,int color,int textColor,Vector3 sh) { super(pA,nameA,color,textColor,sh); update(pProjA);} protected void initProjText(int textColor,Point3D pA,String nameA) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getY()+sh.getDy()); Point2D ptText=new Point2D(pProjA); reprA=new Circle2D(pProjA,pointR,textColor,true); cTextA=createLabel(textColor,pA,nameA,ptText.labelA(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", y:"+point.getY()+")",textColor);}} class ProjPointYZ extends ProjPoint { public ProjPointYZ(Point3D pA,String nameA,int color,int textColor,Vector3 sh) { super(pA,nameA,color,textColor,sh); update(pProjA);} protected void initProjText(int textColor,Point3D pA,String nameA) { pProjA=new Point2D(pA.getY()+sh.getDy(),pA.getZ()+sh.getDz()); Point2D ptText=new Point2D(pProjA); reprA=new Circle2D(pProjA,pointR,textColor,true); cTextA=createLabel(textColor,pA,nameA,ptText.labelA(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(y:"+point.getY()+", z:"+point.getZ()+")",textColor);}} class ProjPointXZ extends ProjPoint { public ProjPointXZ(Point3D pA,String nameA,int color,int textColor,Vector3 sh) { super(pA,nameA,color,textColor,sh); update(pProjA);} protected void initProjText(int textColor,Point3D pA,String nameA) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getZ()+sh.getDz()); Point2D ptText=new Point2D(pProjA); reprA=new Circle2D(pProjA,pointR,textColor,true); cTextA=createLabel(textColor,pA,nameA,ptText.labelA(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", z:"+point.getZ()+")",textColor);}} abstract class ProjLine extends Line2D implements CornerLabels { protected Point2D pProjA; protected Point2D pProjB; protected Text2D cTextA; protected Text2D cTextB; protected Vector3 sh; public ProjLine(Point3D pA,String nameA,Point3D pB,String nameB,int color,int textColor,Vector3 sh) { super(new Point2D(1-1,1-1),new Point2D(1-1,1-1),color); this.sh=sh; initProjText(textColor,pA,nameA,pB,nameB); update(pProjA,pProjB);} protected abstract void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB); public void toPen(CanvasAdapter ics,PaintAdapter pn) { super.toPen(ics,pn.select(this)); cTextA.toPen(ics,pn.select(cTextA)); cTextB.toPen(ics,pn.select(cTextB));}} class ProjLineXY extends ProjLine { public ProjLineXY(Point3D pA,String nameA,Point3D pB,String nameB,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,color,textColor,sh); update(pProjA,pProjB);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getY()+sh.getDy()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getY()+sh.getDy()); Line2D lnText=new Line2D(pProjA,pProjB); cTextA=createLabel(textColor,pA,nameA,lnText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,lnText.labelB(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", y:"+point.getY()+")",textColor);}} class ProjLineYZ extends ProjLine { public ProjLineYZ(Point3D pA,String nameA,Point3D pB,String nameB,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,color,textColor,sh); update(pProjA,pProjB);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB) { pProjA=new Point2D(pA.getY()+sh.getDy(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getY()+sh.getDy(),pB.getZ()+sh.getDz()); Line2D lnText=new Line2D(pProjA,pProjB); cTextA=createLabel(textColor,pA,nameA,lnText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,lnText.labelB(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(y:"+point.getY()+", z:"+point.getZ()+")",textColor);}} class ProjLineXZ extends ProjLine { public ProjLineXZ(Point3D pA,String nameA,Point3D pB,String nameB,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,color,textColor,sh); update(pProjA,pProjB);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getZ()+sh.getDz()); Line2D lnText=new Line2D(pProjA,pProjB); cTextA=createLabel(textColor,pA,nameA,lnText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,lnText.labelB(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", z:"+point.getZ()+")",textColor);}} abstract class ProjTriangle extends Triangle2D implements CornerLabels { protected Point2D pProjA; protected Point2D pProjB; protected Point2D pProjC; protected Text2D cTextA; protected Text2D cTextB; protected Text2D cTextC; protected Vector3 sh; public ProjTriangle(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,int color,int textColor,Vector3 sh) { super(new Point2D(1-1,1-1),new Point2D(1-1,1-1),new Point2D(1-1,1-1),color); this.sh=sh; initProjText(textColor,pA,nameA,pB,nameB,pC,nameC); update(pProjA,pProjB,pProjC);} protected abstract void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC); public void toPen(CanvasAdapter ics,PaintAdapter pn) { super.toPen(ics,pn.select(this)); cTextA.toPen(ics,pn.select(cTextA)); cTextB.toPen(ics,pn.select(cTextB)); cTextC.toPen(ics,pn.select(cTextC)); if(1+1 > 1+1) { Circle2D innerCircle=innerCircle(); innerCircle.toPen(ics,pn.select(innerCircle)); Circle2D outterCircle=outterCircle(); outterCircle.toPen(ics,pn.select(outterCircle)); Line2D midSideHeightAB=midSideHeightAB(); midSideHeightAB.toPen(ics,pn.select(midSideHeightAB)); Line2D midSideHeightBC=midSideHeightBC(); midSideHeightBC.toPen(ics,pn.select(midSideHeightBC)); Line2D midSideHeightAC=midSideHeightAC(); midSideHeightAC.toPen(ics,pn.select(midSideHeightAC));}}} class ProjTriangleXY extends ProjTriangle { public ProjTriangleXY(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,color,textColor,sh); update(pProjA,pProjB,pProjC);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getY()+sh.getDy()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getY()+sh.getDy()); pProjC=new Point2D(pC.getX()+sh.getDx(),pC.getY()+sh.getDy()); Triangle2D triText=new Triangle2D(pProjA,pProjB,pProjC); cTextA=createLabel(textColor,pA,nameA,triText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,triText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,triText.labelC(between));} public PointLabel createLabel(int textColor,Point3D pA,String pointName,Point2D labelPointA) { return new PointLabel(labelPointA,pointName,"(x:"+pA.getX()+", y:"+pA.getY()+")",textColor);}} class ProjTriangleYZ extends ProjTriangle { public ProjTriangleYZ(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,color,textColor,sh); update(pProjA,pProjB,pProjC);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC) { pProjA=new Point2D(pA.getY()+sh.getDy(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getY()+sh.getDy(),pB.getZ()+sh.getDz()); pProjC=new Point2D(pC.getY()+sh.getDy(),pC.getZ()+sh.getDz()); Triangle2D triText=new Triangle2D(pProjA,pProjB,pProjC); cTextA=createLabel(textColor,pA,nameA,triText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,triText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,triText.labelC(between));} public PointLabel createLabel(int textColor,Point3D pA,String pointName,Point2D labelPointA) { return new PointLabel(labelPointA,pointName,"(y:"+pA.getY()+", z:"+pA.getZ()+")",textColor);}} class ProjTriangleXZ extends ProjTriangle { public ProjTriangleXZ(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,color,textColor,sh); update(pProjA,pProjB,pProjC);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getZ()+sh.getDz()); pProjC=new Point2D(pC.getX()+sh.getDx(),pC.getZ()+sh.getDz()); Triangle2D triText=new Triangle2D(pProjA,pProjB,pProjC); cTextA=createLabel(textColor,pA,nameA,triText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,triText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,triText.labelC(between));} public PointLabel createLabel(int textColor,Point3D pA,String pointName,Point2D labelPointA) { return new PointLabel(labelPointA,pointName,"(x:"+pA.getX()+", z:"+pA.getZ()+")",textColor);}} abstract class ProjContureFour extends FourCornersConture2D implements CornerLabels { protected Point2D pProjA; protected Point2D pProjB; protected Point2D pProjC; protected Point2D pProjD; protected Text2D cTextA; protected Text2D cTextB; protected Text2D cTextC; protected Text2D cTextD; protected Vector3 sh; public ProjContureFour(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(new Point2D(1-1,1-1),new Point2D(1-1,1-1),new Point2D(1-1,1-1),new Point2D(1-1,1-1),color); this.sh=sh; initProjText(textColor,pA,nameA,pB,nameB,pC,nameC,pD,nameD); update(pProjA,pProjB,pProjC,pProjD);} protected ProjContureFour(Point2D p1,Point2D p2,Point2D p3,Point2D p4,int color) { super(p1,p2,p3,p4,color);} protected abstract void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD); public void toPen(CanvasAdapter ics,PaintAdapter pn) { super.toPen(ics,pn.select(this)); cTextA.toPen(ics,pn.select(cTextA)); cTextB.toPen(ics,pn.select(cTextB)); cTextC.toPen(ics,pn.select(cTextC)); cTextD.toPen(ics,pn.select(cTextD));}} class ProjContureFourXY extends ProjContureFour { public ProjContureFourXY(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,pD,nameD,color,textColor,sh); update(pProjA,pProjB,pProjC,pProjD);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getY()+sh.getDy()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getY()+sh.getDy()); pProjC=new Point2D(pC.getX()+sh.getDx(),pC.getY()+sh.getDy()); pProjD=new Point2D(pD.getX()+sh.getDx(),pD.getY()+sh.getDy()); FourCornersConture2D fccText=new FourCornersConture2D(pProjA,pProjB,pProjC,pProjD); cTextA=createLabel(textColor,pA,nameA,fccText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,fccText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,fccText.labelC(between)); cTextD=createLabel(textColor,pD,nameD,fccText.labelD(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", y:"+point.getY()+")",textColor);}} class ProjContureFourYZ extends ProjContureFour { public ProjContureFourYZ(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,pD,nameD,color,textColor,sh); update(pProjA,pProjB,pProjC,pProjD);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD) { pProjA=new Point2D(pA.getY()+sh.getDy(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getY()+sh.getDy(),pB.getZ()+sh.getDz()); pProjC=new Point2D(pC.getY()+sh.getDy(),pC.getZ()+sh.getDz()); pProjD=new Point2D(pD.getY()+sh.getDy(),pD.getZ()+sh.getDz()); FourCornersConture2D fccText=new FourCornersConture2D(pProjA,pProjB,pProjC,pProjD); cTextA=createLabel(textColor,pA,nameA,fccText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,fccText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,fccText.labelC(between)); cTextD=createLabel(textColor,pD,nameD,fccText.labelD(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(y:"+point.getY()+", z:"+point.getZ()+")",textColor);}} class ProjContureFourXZ extends ProjContureFour { public ProjContureFourXZ(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,pD,nameD,color,textColor,sh); update(pProjA,pProjB,pProjC,pProjD);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getZ()+sh.getDz()); pProjC=new Point2D(pC.getX()+sh.getDx(),pC.getZ()+sh.getDz()); pProjD=new Point2D(pD.getX()+sh.getDx(),pD.getZ()+sh.getDz()); FourCornersConture2D fccText=new FourCornersConture2D(pProjA,pProjB,pProjC,pProjD); cTextA=createLabel(textColor,pA,nameA,fccText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,fccText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,fccText.labelC(between)); cTextD=createLabel(textColor,pD,nameD,fccText.labelD(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", z:"+point.getZ()+")",textColor);}} abstract class ProjPyramid extends ProjContureFour { public ProjPyramid(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(new Point2D(1-1,1-1),new Point2D(1-1,1-1),new Point2D(1-1,1-1),new Point2D(1-1,1-1),color); this.sh=sh; initProjText(textColor,pA,nameA,pB,nameB,pC,nameC,pD,nameD); update(pProjA,pProjB,pProjC,pProjD);} public void toPen(CanvasAdapter ics,PaintAdapter pn) { super.toPen(ics,pn); Line2D line=new Line2D(getP1(),getP3(),color); line.toPen(ics,pn.select(line)); Line2D line2=new Line2D(getP2(),getP4(),color); line2.toPen(ics,pn.select(line2));}} class ProjPyramidXY extends ProjPyramid { public ProjPyramidXY(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,pD,nameD,color,textColor,sh); update(pProjA,pProjB,pProjC,pProjD);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getY()+sh.getDy()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getY()+sh.getDy()); pProjC=new Point2D(pC.getX()+sh.getDx(),pC.getY()+sh.getDy()); pProjD=new Point2D(pD.getX()+sh.getDx(),pD.getY()+sh.getDy()); FourCornersConture2D fccText=new FourCornersConture2D(pProjA,pProjB,pProjC,pProjD); cTextA=createLabel(textColor,pA,nameA,fccText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,fccText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,fccText.labelC(between)); cTextD=createLabel(textColor,pD,nameD,fccText.labelD(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", y:"+point.getY()+")",textColor);}} class ProjPyramidYZ extends ProjPyramid { public ProjPyramidYZ(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,pD,nameD,color,textColor,sh); update(pProjA,pProjB,pProjC,pProjD);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD) { pProjA=new Point2D(pA.getY()+sh.getDy(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getY()+sh.getDy(),pB.getZ()+sh.getDz()); pProjC=new Point2D(pC.getY()+sh.getDy(),pC.getZ()+sh.getDz()); pProjD=new Point2D(pD.getY()+sh.getDy(),pD.getZ()+sh.getDz()); FourCornersConture2D fccText=new FourCornersConture2D(pProjA,pProjB,pProjC,pProjD); cTextA=createLabel(textColor,pA,nameA,fccText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,fccText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,fccText.labelC(between)); cTextD=createLabel(textColor,pD,nameD,fccText.labelD(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(y:"+point.getY()+", z:"+point.getZ()+")",textColor);}} class ProjPyramidXZ extends ProjPyramid { public ProjPyramidXZ(Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD,int color,int textColor,Vector3 sh) { super(pA,nameA,pB,nameB,pC,nameC,pD,nameD,color,textColor,sh); update(pProjA,pProjB,pProjC,pProjD);} protected void initProjText(int textColor,Point3D pA,String nameA,Point3D pB,String nameB,Point3D pC,String nameC,Point3D pD,String nameD) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getZ()+sh.getDz()); pProjB=new Point2D(pB.getX()+sh.getDx(),pB.getZ()+sh.getDz()); pProjC=new Point2D(pC.getX()+sh.getDx(),pC.getZ()+sh.getDz()); pProjD=new Point2D(pD.getX()+sh.getDx(),pD.getZ()+sh.getDz()); FourCornersConture2D fccText=new FourCornersConture2D(pProjA,pProjB,pProjC,pProjD); cTextA=createLabel(textColor,pA,nameA,fccText.labelA(between)); cTextB=createLabel(textColor,pB,nameB,fccText.labelB(between)); cTextC=createLabel(textColor,pC,nameC,fccText.labelC(between)); cTextD=createLabel(textColor,pD,nameD,fccText.labelD(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", z:"+point.getZ()+")",textColor);}} abstract class ProjCube extends Point2D implements CornerLabels { protected Point2D pProjA; protected Text2D cTextA; protected Rectangle2D reprA; protected int side; protected Vector3 sh; public ProjCube(Point3D pA,String nameA,int side,int color,int textColor,Vector3 sh) { super(new Point2D(1-1,1-1),color); this.sh=sh; this.side=side; initProjText(textColor,pA,nameA); update(pProjA);} protected abstract void initProjText(int textColor,Point3D pA,String nameA); public void toPen(CanvasAdapter ics,PaintAdapter pn) { super.toPen(ics,pn.select(this)); reprA.toPen(ics,pn.select(reprA)); cTextA.toPen(ics,pn.select(cTextA));}} class ProjCubeXY extends ProjCube { public ProjCubeXY(Point3D pA,String nameA,int side,int color,int textColor,Vector3 sh) { super(pA,nameA,side,color,textColor,sh); update(pProjA);} protected void initProjText(int textColor,Point3D pA,String nameA) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getY()+sh.getDy()); Point2D ptText=new Point2D(pProjA); reprA=new Rectangle2D(pProjA,side,side,textColor,false); cTextA=createLabel(textColor,pA,nameA,ptText.labelA(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", y:"+point.getY()+")",textColor);}} class ProjCubeYZ extends ProjCube { public ProjCubeYZ(Point3D pA,String nameA,int side,int color,int textColor,Vector3 sh) { super(pA,nameA,side,color,textColor,sh); update(pProjA);} protected void initProjText(int textColor,Point3D pA,String nameA) { pProjA=new Point2D(pA.getY()+sh.getDy(),pA.getZ()+sh.getDz()); Point2D ptText=new Point2D(pProjA); reprA=new Rectangle2D(pProjA,side,side,textColor,false); cTextA=createLabel(textColor,pA,nameA,ptText.labelA(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(y:"+point.getY()+", z:"+point.getZ()+")",textColor);}} class ProjCubeXZ extends ProjCube { public ProjCubeXZ(Point3D pA,String nameA,int side,int color,int textColor,Vector3 sh) { super(pA,nameA,side,color,textColor,sh); update(pProjA);} protected void initProjText(int textColor,Point3D pA,String nameA) { pProjA=new Point2D(pA.getX()+sh.getDx(),pA.getZ()+sh.getDz()); Point2D ptText=new Point2D(pProjA); reprA=new Rectangle2D(pProjA,side,side,textColor,false); cTextA=createLabel(textColor,pA,nameA,ptText.labelA(between));} public PointLabel createLabel(int textColor,Point3D point,String pointName,Point2D labelPoint) { return new PointLabel(labelPoint,pointName,"(x:"+point.getX()+", z:"+point.getZ()+")",textColor);}} interface CraftShape { void toPenProj3D(CanvasAdapter ics,PaintAdapter pn); Colorfull setFillingType(FillingType fillingType); FillingType getFillingType();} class CraftVertEx extends VertEx3D { public CraftVertEx(String pointName,Point3D point,int objColor,Color projColor) { this(pointName,point,objColor,projColor,ItemViewCraft3D.CELL);} public CraftVertEx(String pointName,Point3D point,int objColor,Color projColor,int halfSide) { super(pointName,point,halfSide,objColor,CraftProps.lineColorVirtualSpace.getRGB(),projColor.getRGB());}} class CustomPoint2D extends Point2D { public CustomPoint2D(Point2D p,int color) { super(p,color);}} class CustomLine2D extends Line2D { public CustomLine2D(Point2D p1,Point2D p2,int color) { super(p1,p2,color);}} class CustomTriangle2D extends Triangle2D { private ScanLineDuo doubleScan; private FillingType fillingType=FillingType.FT_LINES; private boolean distTeaching=!true; public CustomTriangle2D(Point2D p1,Point2D p2,Point2D p3,int color,boolean solid) { super(p1,p2,p3,color,solid); this.doubleScan=new ScanLineDuo(p1,p2,p3,color);} public void setFillingType(FillingType fillingType) { this.fillingType=fillingType;} public void toPenSolid(CanvasAdapter ics,PaintAdapter pn) { super.toPenSolid(ics,pn); if(1+1 > 1+1) { pn.select(ColorsArray.yellowPoint); super.toPenConture(ics,pn);} if(distTeaching) inCircle(ics,pn);} public void toPenConture(CanvasAdapter ics,PaintAdapter pn) { super.toPenConture(ics,pn); if(fillingType.isLines()) { doubleScan.setLines(); doubleScan.toPen(ics,pn);} else if(fillingType.isQuery()) { doubleScan.setQuery(); doubleScan.toPen(ics,pn);} if(distTeaching) inCircle(ics,pn);} private void inCircle(CanvasAdapter ics,PaintAdapter pn) { Circle2D innerCircle=innerCircle(); innerCircle.toPen(ics,pn.select(innerCircle));}} class CustomFourCornersConture2D extends FourCornersConture2D { private ScanLineDuo doubleScan; private FillingType fillingType; public CustomFourCornersConture2D(Point2D p1,Point2D p2,Point2D p3,Point2D p4,int color,boolean solid) { super(p1,p2,p3,p4,color,solid); this.doubleScan=new ScanLineDuo(p1,p2,p3,p4,color);} public void setFillingType(FillingType fillingType) { this.fillingType=fillingType;} public void toPenSolid(CanvasAdapter ics,PaintAdapter pn) { super.toPenSolid(ics,pn);} public void toPenConture(CanvasAdapter ics,PaintAdapter pn) { super.toPenConture(ics,pn); if(fillingType.isLines()) { doubleScan.setLines(); doubleScan.toPen(ics,pn);} else if(fillingType.isQuery()) { doubleScan.setQuery(); doubleScan.toPen(ics,pn);}}} class OrderedSpiskaZ { protected CraftVertEx[] orderedZ; protected Queue all; public OrderedSpiskaZ() { super(); this.all=new Queue(); this.orderedZ=new CraftVertEx[1-1];} public synchronized void append(OrderedZ item) { all.enqueueQueueRecord(item); updateOrderZ();} public synchronized void append(OrderedZ[] items) { all.enqueueQueueRecords(items); updateOrderZ();} private void updateOrderZ() { Object[] queueRecordsArray=all.getQueueRecordsArray(); orderedZ=new CraftVertEx[(int) queueRecordsArray.length]; for(int i=0; i < orderedZ.length; i++) orderedZ[i]=(CraftVertEx) queueRecordsArray[i]; reOrderZ();} public synchronized boolean hasRellocation() { for(int i=0; i < orderedZ.length; i++) if(orderedZ[i].isRellocation()) return true; return false;} public synchronized CraftVertEx[] items() { return orderedZ;} public synchronized void reOrderZ() { for(int i=0; i < orderedZ.length-1; i++) for(int j=i+1; j < orderedZ.length; j++) { if(orderedZ[i].gt(orderedZ[j])) { OrderedZ tmp=orderedZ[j]; orderedZ[j]=orderedZ[i]; orderedZ[i]=(CraftVertEx) tmp;}} this.all.clearQueue(); for(int i=0; i < orderedZ.length; i++) all.enqueueQueueRecord(orderedZ[i]);}} class LaterOverDraw { private CraftVertEx active; public LaterOverDraw(CraftVertEx active) { super(); this.active=active;} public void draw(CanvasAdapter canvas,PaintAdapter pn) { active.toPen(canvas,pn.select(active));}} class ResultsOxyzPanel implements SqProjProfile { private boolean prx=true; private boolean pry=true; ProjectionsConfig cfg=new ProjectionsConfig(); public ResultsOxyzPanel() {} public void updateSelection(ProjectionsConfig cfg) { this.cfg=cfg;} public boolean isStripeX() { return cfg.stripeX;} public boolean isStripeY() { return cfg.stripeY;} public boolean isStripeZ() { return cfg.stripeZ;} public boolean isBulkX() { return cfg.bulkX;} public boolean isBulkY() { return cfg.bulkY;} public boolean isBulkZ() { return cfg.bulkZ;} public boolean isProjLeftX() { return prx;} public boolean isProjRightX() { return prx;} public boolean isProjUpY() { return pry;} public boolean isProjDownY() { return pry;} public boolean isProjFarZ() { return false;} public boolean isProjNearZ() { return false;} public ResultsOxyzPanel copyFalse() { ResultsOxyzPanel cp=new ResultsOxyzPanel(); cp.prx=false; cp.pry=false; return cp;}} class ColorFillWrap { Colorfull ref; FillingType fillingType; public ColorFillWrap(Colorfull ref,FillingType fillingType) { super(); this.ref=ref; this.fillingType=fillingType;} public Colorfull getRef() { return ref;} public FillingType getFillingType() { return fillingType;}} abstract class ComboSeqBox { public abstract String[] getAllSequence(); public abstract String getName(); protected String[] extractSeqArray(Queue queue) { Object[] queueRecordsArray=queue.getQueueRecordsArray(); String[] result=new String[queueRecordsArray.length]; for(int i=0; i < queueRecordsArray.length; i++) result[i]=(String) queueRecordsArray[i]; return result;}} class AirFormation extends ComboSeqBox { public static final AirFormation AF_CHAIN=new AirFormation("Chain"); public static final AirFormation AF_ZUB=new AirFormation("Tooth"); public static final AirFormation AF_LINE=new AirFormation("Line"); private String name; public AirFormation(String name) { this.name=name;} public boolean isChain() { return isChain(name);} public boolean isTri() { return isTri(name);} public boolean isLine() { return isLine(name);} public boolean isChain(String item) { return item !=null && item.equalsIgnoreCase(AF_CHAIN.getName());} public boolean isTri(String item) { return item !=null && item.equalsIgnoreCase(AF_ZUB.getName());} public boolean isLine(String item) { return item !=null && item.equalsIgnoreCase(AF_LINE.getName());} public String getName() { return name;} public String[] getAllSequence() { Queue queue=new Queue(); queue.enqueueQueueRecord(AirFormation.AF_CHAIN.getName()); queue.enqueueQueueRecord(AirFormation.AF_ZUB.getName()); queue.enqueueQueueRecord(AirFormation.AF_LINE.getName()); return extractSeqArray(queue);} public String toString() { return "AirFormation [name="+name+"]";}} class PathType extends ComboSeqBox { public static final PathType PT_NSWE=new PathType("N-S-W-E"); public static final PathType PT_SPIRAL=new PathType("Spiral"); public static final PathType PT_RING=new PathType("Ring"); public static final PathType PT_SPHERE=new PathType("Sphere"); private String name; public PathType(String name) { this.name=name;} public boolean isRing() { return isRing(name);} public boolean isSpiral() { return isSpiral(name);} public boolean isNorthSouthWestEast() { return isNorthSouthWestEast(name);} public boolean isSphere() { return isSphere(name);} public boolean isRing(String item) { return item !=null && item.equalsIgnoreCase(PT_RING.getName());} public boolean isSpiral(String item) { return item !=null && item.equalsIgnoreCase(PT_SPIRAL.getName());} public boolean isNorthSouthWestEast(String item) { return item !=null && item.equalsIgnoreCase(PT_NSWE.getName());} public boolean isSphere(String item) { return item !=null && item.equalsIgnoreCase(PT_SPHERE.getName());} public String getName() { return name;} public String toString() { return "PathType [name="+name+"]";} public String[] getAllSequence() { Queue queue=new Queue(); queue.enqueueQueueRecord(PathType.PT_SPIRAL.getName()); queue.enqueueQueueRecord(PathType.PT_RING.getName()); queue.enqueueQueueRecord(PathType.PT_SPHERE.getName()); queue.enqueueQueueRecord(PathType.PT_NSWE.getName()); return extractSeqArray(queue);}} class CasualType extends ComboSeqBox { public static final CasualType CT_POINTS=new CasualType("Points"); public static final CasualType CT_LINES=new CasualType("Lines"); public static final CasualType CT_TRIANGLES=new CasualType("Triangles"); public static final CasualType CT_FOURCORNERS=new CasualType("Four-Corners"); public static final CasualType CT_PYRAMIDES=new CasualType("Pyramides"); public static final CasualType CT_CUBES=new CasualType("Cubes"); private String name; public CasualType(String name) { this.name=name;} public boolean isLines() { return isLines(name);} public boolean isLines(String item) { return item !=null && item.equalsIgnoreCase(CT_LINES.getName());} public boolean isPoints() { return isPoints(name);} public boolean isPoints(String item) { return item !=null && item.equalsIgnoreCase(CT_POINTS.getName());} public boolean isTriangles() { return isTriangles(name);} public boolean isTriangles(String item) { return item !=null && item.equalsIgnoreCase(CT_TRIANGLES.getName());} public boolean isFourCorners() { return isFourCorners(name);} public boolean isFourCorners(String item) { return item !=null && item.equalsIgnoreCase(CT_FOURCORNERS.getName());} public boolean isPyramides() { return isPyramides(name);} public boolean isPyramides(String item) { return item !=null && item.equalsIgnoreCase(CT_PYRAMIDES.getName());} public boolean isCubes() { return isCubes(name);} public boolean isCubes(String item) { return item !=null && item.equalsIgnoreCase(CT_CUBES.getName());} public String getName() { return name;} public String[] getAllSequence() { Queue queue=new Queue(); queue.enqueueQueueRecord(CasualType.CT_POINTS.getName()); queue.enqueueQueueRecord(CasualType.CT_LINES.getName()); queue.enqueueQueueRecord(CasualType.CT_TRIANGLES.getName()); queue.enqueueQueueRecord(CasualType.CT_FOURCORNERS.getName()); queue.enqueueQueueRecord(CasualType.CT_PYRAMIDES.getName()); queue.enqueueQueueRecord(CasualType.CT_CUBES.getName()); return extractSeqArray(queue);} public String toString() { return "CasualType [name="+name+"]";}} class MotionVelocity extends ComboSeqBox { public static final MotionVelocity veStop=new MotionVelocity("Stop Speed"); public static final MotionVelocity veSlow=new MotionVelocity("Slow Speed",1); public static final MotionVelocity veNorm=new MotionVelocity("Norm Speed",1+1); public static final MotionVelocity veFast=new MotionVelocity("Fast Speed",1+1+1); public static final MotionVelocity veFaster=new MotionVelocity("Faster Speed",1+1+1+1); public static final MotionVelocity veFastest=new MotionVelocity("Fastest Speed",1+1+1+1+1); public static final short minVelocity=veStop.getStepsMult(); public static final short maxVelocity=veFastest.getStepsMult(); public static final MotionVelocity startVelocity=veNorm; private String name; private short stepsMult; MotionVelocity(String name) { super(); this.name=name;} MotionVelocity(String name,int steps) { super(); this.name=name; this.stepsMult=(short) steps;} public String getName() { return name;} public static MotionVelocity recover(String curSelSpeed) { String speedNum=new Data().replace(new Ester(curSelSpeed),new Ester(" automatique"),new Ester("")).toString(); int num=Integer.parseInt(speedNum); switch(num) { case 0 : return veStop; case 1 : return veSlow; case 2 : return veNorm; case 3 : return veFast; case 4 : return veFaster; case 5 : return veFastest;} return null;} public short getStepsMult() { return stepsMult;} public void accelerating() { if(stepsMult < maxVelocity) stepsMult++;} public void breaking() { if(stepsMult > minVelocity) stepsMult--;} public static MotionVelocity getStartVelocity() { return MotionVelocity.veNorm;} public String repr() { return ""+stepsMult+" automatique";} public String toString() { return "MotionVelocity [name="+name+", stepsMult="+stepsMult+"]";} public boolean isSlower(MotionVelocity speed) { return stepsMult < speed.stepsMult;} public boolean isGreater(MotionVelocity speed) { return stepsMult > speed.stepsMult;} public void cruisingAuto(MotionVelocity newSpeed) { cruising(newSpeed,this);} private void cruising(MotionVelocity newSpeed,MotionVelocity speed) { if(newSpeed.isGreater(speed)) while(newSpeed.isGreater(speed)) speed.accelerating(); else if(newSpeed.isSlower(speed)) while(newSpeed.isSlower(speed)) speed.breaking();} public String[] getAllSequence() { Queue queue=new Queue(); queue.enqueueQueueRecord(MotionVelocity.veStop.getName()); queue.enqueueQueueRecord(MotionVelocity.veSlow.getName()); queue.enqueueQueueRecord(MotionVelocity.veNorm.getName()); queue.enqueueQueueRecord(MotionVelocity.veFast.getName()); queue.enqueueQueueRecord(MotionVelocity.veFaster.getName()); queue.enqueueQueueRecord(MotionVelocity.veFastest.getName()); return extractSeqArray(queue);}} class FillingType extends ComboSeqBox { public static final FillingType FT_SOLID=new FillingType("Solid"); public static final FillingType FT_LINES=new FillingType("Lines"); public static final FillingType FT_REGENERATION=new FillingType("Cells"); public static final FillingType FT_FRAME=new FillingType("Ribs"); private String name; private FillingType(String name) { super(); this.name=name;} public boolean isQuery() { return isQuery(name);} public boolean isSolid() { return isSolid(name);} public boolean isFrame() { return isFrame(name);} public boolean isLines() { return isLines(name);} public static FillingType getType(String curSelFilling) { if(FT_SOLID.isSolid(curSelFilling)) return FT_SOLID; else if(FT_LINES.isLines(curSelFilling)) return FT_LINES; else if(FT_FRAME.isFrame(curSelFilling)) return FT_FRAME; return FT_REGENERATION;} public boolean isSolid(String item) { return item !=null && item.equalsIgnoreCase(FT_SOLID.name);} public boolean isLines(String item) { return item !=null && item.equalsIgnoreCase(FT_LINES.name);} public boolean isFrame(String item) { return item !=null && item.equalsIgnoreCase(FT_FRAME.name);} public boolean isQuery(String item) { return item !=null && item.equalsIgnoreCase(FT_REGENERATION.name);} public String getName() { return name;} public String[] getAllSequence() { Queue queue=new Queue(); queue.enqueueQueueRecord(FillingType.FT_SOLID.getName()); queue.enqueueQueueRecord(FillingType.FT_LINES.getName()); queue.enqueueQueueRecord(FillingType.FT_REGENERATION.getName()); queue.enqueueQueueRecord(FillingType.FT_FRAME.getName()); return extractSeqArray(queue);} public String toString() { return "FillingType [name="+name+"]";}} class PlugLeftPanel extends CommonDataArrayPanel { ListPanel listPanel; PlugControlsPanel savePanel; private Queue leftItemsQueue=new Queue(); private boolean leftItemsQueueIns; private ColorFillWrap[] leftItemsQueueArr=new ColorFillWrap[1-1]; public PlugLeftPanel() { super();} public void changeSpeed(LimStatParallelPanel quadePanel) { String curSel=getChSpeed().getSelectedItem(); quadePanel.setCurrentSpeed(curSel);} public void changeWay(LimStatParallelPanel quadePanel) { String curSel=getChWay().getSelectedItem(); quadePanel.setCurrentWay(new PathType(curSel));} public void changeFormation(LimStatParallelPanel quadePanel) { String curSel=getChForm().getSelectedItem(); quadePanel.setCurrentForm(new AirFormation(curSel));} public void changeFigures(LimStatParallelPanel quadePanel) { String curSelShape=getChFigure().getSelectedItem(); String curSelFilling=getChSolid().getSelectedItem(); quadePanel.setCurrentFigureChoice(new CasualType(curSelShape),curSelFilling);} public void changeFillings(LimStatParallelPanel quadePanel) { String curSel=getChSolid().getSelectedItem(); quadePanel.setCurrentFillingChoice(curSel);} public void enableAutoBtn(boolean enable) { savePanel.getUpPanel().getBtAuto().enable(enable);} public Color getPanelBgColor() { return CraftProps.bgSideColor;} protected Color getWrapPanelColor() { return CraftProps.bgStatPanelColor;} public SourceProcessor leftSelected(LimStatParallelPanel quadePanel,LoggingVkusnjashki logPanel) { int idxSel=getSelectedIdx(); String curSel=getItemSelected(); logPanel.addLog("Selected item "+curSel); SourceProcessor sp=null; if(leftItemsQueueIns) leftItemsQueueArr=makeCopyCash(); ColorFillWrap curSelObj=(ColorFillWrap) leftItemsQueueArr[idxSel]; if(curSelObj.ref instanceof ColorfulShapeSet) { if(((ColorfulShapeSet) curSelObj.ref).at(1-1) instanceof Point3D) { ColorfulShapeSet pointSet=(ColorfulShapeSet) curSelObj.ref; quadePanel.setCurrentPoints(pointSet); getChFigure().select(CasualType.CT_POINTS.getName()); getChSolid().select(curSelObj.fillingType.getName()); changeFigures(quadePanel); changeFillings(quadePanel);} else if(((ColorfulShapeSet) curSelObj.ref).at(1-1) instanceof Cube) { ColorfulShapeSet cubeSet=(ColorfulShapeSet) curSelObj.ref; quadePanel.setCurrentCubes(cubeSet); getChFigure().select(CasualType.CT_CUBES.getName()); getChSolid().select(curSelObj.fillingType.getName()); changeFigures(quadePanel); changeFillings(quadePanel);} else { ColorfulShapeSet lineSet=(ColorfulShapeSet) curSelObj.ref; quadePanel.setCurrentLines(lineSet); getChFigure().select(CasualType.CT_LINES.getName()); getChSolid().select(curSelObj.fillingType.getName()); changeFigures(quadePanel); changeFillings(quadePanel);}} else if(curSelObj.ref instanceof Pyramid) { Pyramid pyr=(Pyramid) curSelObj.ref; quadePanel.setCurrentPyr(pyr); getChFigure().select(CasualType.CT_PYRAMIDES.getName()); getChSolid().select(curSelObj.fillingType.getName()); changeFigures(quadePanel); changeFillings(quadePanel);} else if(curSelObj.ref instanceof Triangle3D) { Triangle3D tri=(Triangle3D) curSelObj.ref; quadePanel.setCurrentTri(tri); getChFigure().select(CasualType.CT_TRIANGLES.getName()); getChSolid().select(curSelObj.fillingType.getName()); changeFigures(quadePanel); changeFillings(quadePanel);} else if(curSelObj.ref instanceof FourCornersConture3D) { FourCornersConture3D four=(FourCornersConture3D) curSelObj.ref; quadePanel.setCurrentFour(four); getChFigure().select(CasualType.CT_FOURCORNERS.getName()); getChSolid().select(curSelObj.fillingType.getName()); changeFigures(quadePanel); changeFillings(quadePanel);} setPosition(""+(idxSel+1)); return sp;} public Button getAutoBtn() { return savePanel.getUpPanel().getBtAuto();} public Choice getChFigure() { return savePanel.getUpPanel().getChFigure();} public Choice getChSolid() { return savePanel.getChSolid();} public Choice getChSpeed() { return savePanel.getChSpeed();} public Choice getChWay() { return savePanel.getChWay();} public Choice getChForm() { return savePanel.getChForm();} public void dropBtnSkipPosition() {} public void enableCtrls(boolean enable) { listPanel.listEnable(enable);} public void clearItems() { listPanel.clearItems(); leftItemsQueue.clearQueue(); leftItemsQueueIns=false; leftItemsQueueArr=makeCopyCash();} private ColorFillWrap[] makeCopyCash() { leftItemsQueueIns=false; Object[] queueRecordsArray=leftItemsQueue.getQueueRecordsArray(); ColorFillWrap[] result=new ColorFillWrap[queueRecordsArray.length]; for(int i=0; i < result.length; i++) result[i]=(ColorFillWrap) queueRecordsArray[i]; return result;} public void addItem(String item,ColorFillWrap cfWrap) { listPanel.addItem(item); leftItemsQueue.enqueueQueueRecord(cfWrap); leftItemsQueueIns=true;} protected Panel obtainControlsPanel() { this.savePanel=new PlugControlsPanel(); return savePanel;} protected SizePanel obtainSizePanel() { return null;} protected ListPanel obtainListPanel() { this.listPanel=new ListPanel(new StatPlugPanel(),new CraftPagesPanel()); return listPanel;}} class CraftPagesPanel extends PagesPanel { public CraftPagesPanel() { super(CraftProps.listPanelPageSize);} public Color getPanelBgColor() { return CraftProps.bgPagesPanelColor;}} class StatPlugPanel extends AmountPanel { public StatPlugPanel() { super("Triangle","item(s)");} public Color getPanelBgColor() { return CraftProps.bgAmountPanelColor;} protected int getPosWidth() { return 5-1+1+1-1;} protected int getAmountWidth() { return 12-5-1-1;}} class PlugControlsPanel extends Panel { LabeledEditPair leWay; LabeledEditPair leForm; LabeledEditPair leSpeed; LabeledEditPair leFilling; PlugControlsUpPanel upPanel; PropertySetPanel psp; public PlugControlsPanel() { super(); setBackground(CraftProps.bgAvgPanelColor); setLayout(new BorderLayout()); add("Center",upPanel=new PlugControlsUpPanel()); psp=new PropertySetPanel(CraftProps.bgChartColor,createPairs()); add("North",createPanelColorfullWrap(psp.cookingLabels(CraftProps.bgSizePanelColor,CraftProps.textChartPanelColor,CraftProps.bgChartPanelColor),Color.white));} protected Panel createPanelColorfullWrap(Component comp,Color wrapColor) { LabeledPanel ignorePanelWrap=new LabeledPanel("",comp,LabeledPanel.DEF_WRAP_SIZE,wrapColor,wrapColor,wrapColor,true,true,false,true); return ignorePanelWrap;} public Choice getChSolid() { return leFilling.getChoisesCtrl();} private LabeledEditPair[] createPairs() { leWay=new LabeledEditPair("Motion way:",obtainFigureWay()); leForm=new LabeledEditPair("Formation:",obtainForms()); leSpeed=new LabeledEditPair("Speed:",obtainChoiceSpeed()); leFilling=new LabeledEditPair("Figure filling:",obtainObjectFilling()); LabeledEditPair[] pairs=new LabeledEditPair[1+1+1+1+1+1+1+1+1+1-1-1-1-1-1-1]; pairs[1-1]=leWay; pairs[1]=leForm; pairs[1+1]=leSpeed; pairs[1+1+1]=leFilling; return pairs;} public PlugControlsUpPanel getUpPanel() { return upPanel;} public Choice getChPath() { return leWay.getChoisesCtrl();} public Choice getChSpeed() { return leSpeed.getChoisesCtrl();} public Choice getChWay() { return leWay.getChoisesCtrl();} public Choice getChForm() { return leForm.getChoisesCtrl();} protected Choice obtainFigureWay() { Choice chFigureWay=makeChoice(PathType.PT_SPHERE.getAllSequence(),PathType.PT_SPIRAL.getName()); return chFigureWay;} private Choice makeChoice(String[] allSequence,String selectedName) { Choice result=new Choice(); for(int i=0; i < allSequence.length; i++) result.addItem(allSequence[i]); result.select(selectedName); return result;} protected Choice obtainForms() { Choice chForm=new Choice(); chForm.addItem(AirFormation.AF_CHAIN.getName()); chForm.addItem(AirFormation.AF_ZUB.getName()); chForm.addItem(AirFormation.AF_LINE.getName()); chForm.select(1-1); return chForm;} protected Choice obtainChoiceSpeed() { Choice chSpeed=new Choice(); chSpeed.addItem(MotionVelocity.veStop.repr()); chSpeed.addItem(MotionVelocity.veSlow.repr()); chSpeed.addItem(MotionVelocity.veNorm.repr()); chSpeed.addItem(MotionVelocity.veFast.repr()); chSpeed.addItem(MotionVelocity.veFaster.repr()); chSpeed.addItem(MotionVelocity.veFastest.repr()); chSpeed.select(1+1); return chSpeed;} protected Choice obtainObjectFilling() { Choice chSolid=new Choice(); chSolid.addItem(FillingType.FT_SOLID.getName()); chSolid.addItem(FillingType.FT_LINES.getName()); chSolid.addItem(FillingType.FT_REGENERATION.getName()); chSolid.addItem(FillingType.FT_FRAME.getName()); chSolid.select(1+1); return chSolid;}} class PlugControlsUpPanel extends ControlsPanel { static final String CH_FIGURE="chFigure"; Choice chFigure; public PlugControlsUpPanel() { super(); enableCtrls(true);} public Button getBtAuto() { return getAutoBtn().getBtAuto();} public Choice getChFigure() { return chFigure;} public Color getPanelBgColor() { return CraftProps.bgCtrlPanelColor;} public LayoutManager getPanelLayout() { return new FlowLayout(FlowLayout.CENTER,1+1,1+1);} protected void buildPanel() { chFigure=new Choice(); chFigure.addItem(CasualType.CT_POINTS.getName()); chFigure.addItem(CasualType.CT_LINES.getName()); chFigure.addItem(CasualType.CT_TRIANGLES.getName()); chFigure.addItem(CasualType.CT_FOURCORNERS.getName()); chFigure.addItem(CasualType.CT_PYRAMIDES.getName()); chFigure.addItem(CasualType.CT_CUBES.getName()); chFigure.select(1+1+1+1); append(CH_FIGURE,chFigure); append("plugAuto",new PlugAuto());} public void enableCtrls(boolean enable) { chFigure.enable(enable); getAutoBtn().enableCtrl(enable);}} class PlugAuto extends YellowAutoButton { public PlugAuto() { super();}} class ViewShapesTask extends ProgressMultiTasking { PlugPathPanel pathPanel; PlugLeftPanel leftPanel; LimStatParallelPanel quadePanel; LoggingVkusnjashki logPanel; private Sleeper sleeper; public ViewShapesTask(PlugPathPanel pathPanel,PlugLeftPanel leftPanel,LimStatParallelPanel quadePanel,LoggingVkusnjashki logPanel,Sleeper sleeper) { super(); this.pathPanel=pathPanel; this.leftPanel=leftPanel; this.quadePanel=quadePanel; this.logPanel=logPanel; this.sleeper=sleeper;} protected void performTask() { viewAll();} private void viewAll() { int size1=leftPanel.itemsNum(); for(int i=0; pathPanel.hasLongTermContin() && i < size1; i++) { leftPanel.selectItem(i); leftPanel.leftSelected(quadePanel,logPanel); recountComplete(i+1,size1); sleeper.sleep(166);}}} class CreateShapesTask extends ProgressMultiTasking { PlugPathPanel pathPanel; PlugLeftPanel leftPanel; LoggingVkusnjashki logPanel; private boolean singleOp; public CreateShapesTask(PlugPathPanel pathPanel,PlugLeftPanel leftPanel,LoggingVkusnjashki logPanel,boolean singleOp) { super(); this.pathPanel=pathPanel; this.leftPanel=leftPanel; this.logPanel=logPanel; this.singleOp=singleOp;} protected void performTask() { createShapes();} private void createShapes() { String amountShapes=pathPanel.getPath(); int amount=Integer.parseInt(amountShapes); ColorsArray cArray=new ColorsArray(); for(int i=1; i <= amount; i++) { long mss=System.currentTimeMillis(); int ms=(int)(mss-mss / 78635L); ms *= i; Point3D p1=createPoint(ms); ms=(int)(mss-mss / 23754L); ms *= i+1; Point3D p2=createPoint(ms); ms=(int)(mss-mss / 54765L); ms *= i+1+1; Point3D p3=createPoint(ms); ms=(int)(mss-mss / 19234L); ms *= i+1+1; Point3D p4=createPoint(ms); int full=i-i / 4 * 4; FillingType fillingType=FillingType.FT_SOLID; switch(full) { case 0 : fillingType=FillingType.FT_SOLID; break; case 1 : fillingType=FillingType.FT_LINES; break; case 2 : fillingType=FillingType.FT_REGENERATION; break; case 3 : fillingType=FillingType.FT_FRAME; break;} int c1=cArray.getColor(i); ms=(int)(mss-mss / 6L * 6); if(ms==0) { Point3D point=new Point3D(p1,c1); Point3D point2=new Point3D(p2,c1); Point3D point3=new Point3D(p3,c1); Point3D point4=new Point3D(p4,c1); ColorfulShapeSet pointSet=new ColorfulShapeSet().append(point).append(point2).append(point3).append(point4); String pointsRec="Points-A,B,C,D-"+i+"("+representPoints(pointSet)+")"; leftPanel.addItem(pointsRec,new ColorFillWrap(pointSet,fillingType)); logPanel.addLog("Created points record "+pointsRec);} else if(ms==1) { Line3D line=new Line3D(p1,p2,c1); Line3D line2=new Line3D(p3,p4,c1); ColorfulShapeSet lineSet=new ColorfulShapeSet().append(line).append(line2); String linesRec="Lines-AB,CD-"+i+"("+representLines(lineSet)+")"; leftPanel.addItem(linesRec,new ColorFillWrap(lineSet,fillingType)); logPanel.addLog("Created lines record "+linesRec);} else if(ms==1+1) { Triangle3D tri=new Triangle3D(p1,p2,p3,c1,fillingType.isSolid()); String triRec="Triangle-ABD-"+i+"("+representTriangle(tri)+")"; leftPanel.addItem(triRec,new ColorFillWrap(tri,fillingType)); logPanel.addLog("Created triangle record "+triRec);} else if(ms==1+1+1) { FourCornersConture3D four=new FourCornersConture3D(p1,p2,p3,p4,c1); four.setFill(fillingType.isSolid()); String fourRec="4Corner-ABCD-"+i+"("+representFourCC(four)+")"; leftPanel.addItem(fourRec,new ColorFillWrap(four,fillingType)); logPanel.addLog("Created four-corner record "+fourRec);} else if(ms==1+1+1+1) { Pyramid pyr=new Pyramid(new Triangle3D(p1,p2,p3,c1,fillingType.isSolid()),p4,c1); pyr.setFill(fillingType.isSolid()); String recPyr="Pyramid-DABC-"+i+"("+representPyr(pyr)+")"; leftPanel.addItem(recPyr,new ColorFillWrap(pyr,fillingType)); logPanel.addLog("Created pyramid record "+recPyr);} else if(ms==1+1+1+1+1) { Cube cube=new Cube(p1,c1); Cube cube2=new Cube(p2,c1); Cube cube3=new Cube(p3,c1); Cube cube4=new Cube(p4,c1); ColorfulShapeSet cubeSet=new ColorfulShapeSet().append(cube).append(cube2).append(cube3).append(cube4); String cubesRec="Cubes-A,B,C,D-"+i+"("+representCubes(cubeSet)+")"; leftPanel.addItem(cubesRec,new ColorFillWrap(cubeSet,fillingType)); logPanel.addLog("Created cubes record "+cubesRec);} leftPanel.setAmount(""+i); recountComplete(i,amount);} if(singleOp) { pathPanel.disableStop(); leftPanel.enableAutoBtn(true);}} private Point3D createPoint(int ms) { int dtx=(int)(ms-ms / 7654L); int dty=(int)(ms-ms / 1999L); int dtz=(int)(ms-ms / 1234L); if(dtx < 0) dtx *=-1; if(dty < 0) dty *=-1; if(dtz < 0) dtz *=-1; int x=-150+dtx % 280; int y=15+dty % 200; int z=-11-dtz % 100; Point3D p1=new Point3D(x,y,z); return p1;} private String representCubes(ColorfulShapeSet shapeSet) { Cube cube=(Cube) shapeSet.at(1-1); Cube cube2=(Cube) shapeSet.at(1-1+1); Cube cube3=(Cube) shapeSet.at(1-1+1+1); Cube cube4=(Cube) shapeSet.at(1-1+1+1+1); Point3D A=cube.getCenter(); Point3D B=cube2.getCenter(); Point3D C=cube3.getCenter(); Point3D D=cube4.getCenter(); return ""+pointRepr(A,"A")+","+pointRepr(B,"B")+","+pointRepr(C,"C")+","+pointRepr(D,"D");} private String representPoints(ColorfulShapeSet shapeSet) { Point3D point=(Point3D) shapeSet.at(1-1); Point3D point2=(Point3D) shapeSet.at(1-1+1); Point3D point3=(Point3D) shapeSet.at(1-1+1+1); Point3D point4=(Point3D) shapeSet.at(1-1+1+1+1); Point3D A=point; Point3D B=point2; Point3D C=point3; Point3D D=point4; return ""+pointRepr(A,"A")+","+pointRepr(B,"B")+","+pointRepr(C,"C")+","+pointRepr(D,"D");} private String representLines(ColorfulShapeSet shapeSet) { Line3D line=(Line3D) shapeSet.at(1-1); Line3D line2=(Line3D) shapeSet.at(1-1+1); Point3D A=line.A(); Point3D B=line.B(); Point3D C=line2.getP1(); Point3D D=line2.getP2(); return ""+pointRepr(A,"A")+","+pointRepr(B,"B")+","+pointRepr(C,"C")+","+pointRepr(D,"D");} private String representTriangle(Triangle3D tri) { Point3D A=tri.A(); Point3D B=tri.B(); Point3D C=tri.C(); return ""+pointRepr(A,"A")+","+pointRepr(B,"B")+","+pointRepr(C,"C");} private String representPyr(Pyramid pyr) { Point3D D=pyr.getTop(); Point3D A=pyr.A(); Point3D B=pyr.B(); Point3D C=pyr.C(); return ""+pointRepr(D,"D")+","+pointRepr(A,"A")+","+pointRepr(B,"B")+","+pointRepr(C,"C");} private String representFourCC(FourCornersConture3D four) { Point3D A=four.A(); Point3D B=four.B(); Point3D C=four.C(); Point3D D=four.D(); return ""+pointRepr(A,"A")+","+pointRepr(B,"B")+","+pointRepr(C,"C")+","+pointRepr(D,"D");} private String pointRepr(Point3D pt,String name) { return ""+name+"("+pt.getX()+","+pt.getY()+","+pt.getZ()+")";}} class CraftCube extends CraftVertEx implements CraftShape { public static final int SIDE=73; private CraftVertEx cubeA; private static FillingType fillingType=FillingType.FT_LINES; public CraftCube(CraftVertEx aItem,int pointColor) { super(aItem.getName(),aItem.getCenter(),pointColor,new Color(pointColor),SIDE); this.cubeA=aItem; this.planesRepo=new OpenFrontCubeProfile(pointColor);} public void toPenProj3D(CanvasAdapter ics,PaintAdapter pn) {} public ProjCubeXY cubeProjXY(Vector3 xyShift) { update3D(); ProjCubeXY lineProj=new ProjCubeXY(this.getCenter(),cubeA.getName(),SIDE,CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xyShift); return lineProj;} public ProjCubeYZ cubeProjYZ(Vector3 yzShift) { update3D(); ProjCubeYZ lineProj=new ProjCubeYZ(this.getCenter(),cubeA.getName(),SIDE,CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,yzShift); return lineProj;} public ProjCubeXZ cubeProjXZ(Vector3 xzShift) { update3D(); ProjCubeXZ lineProj=new ProjCubeXZ(this.getCenter(),cubeA.getName(),SIDE,CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xzShift); return lineProj;} public void updateCubeProjXY(Point2D point,Vector3 relocVect,Point2D p1234) { updateCubeCommon(point,relocVect,p1234);} public void updateCubeProjYZ(Point2D point,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftYZ(relocVect2.getDx(),relocVect2.getDy()); updateCubeCommon(point,relocVect,p1234);} public void updateCubeProjXZ(Point2D point,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftXZ(relocVect2.getDx(),relocVect2.getDy()); updateCubeCommon(point,relocVect,p1234);} private void updateCubeCommon(Point2D point,Vector3 relocVect,Point2D p1234) { Point3D A=cubeA.getCenter(); if(p1234.equals(point)) A.shift(relocVect); update(A);} private void update3D() { update(cubeA.getCenter());} public Colorfull setFillingType(FillingType fillingType) { CraftCube.fillingType=fillingType; return this;} public FillingType getFillingType() { return fillingType;} public String toString() { return "CraftCube [cubeA="+cubeA+"]";}} class CraftFourCorner extends FourCornersConture3D implements CraftShape { private CraftVertEx cubeA; private CraftVertEx cubeB; private CraftVertEx cubeC; private CraftVertEx cubeD; private CustomFourCornersConture2D projection; private static FillingType fillingType=FillingType.FT_LINES; public CraftFourCorner(CraftVertEx aItem,CraftVertEx bItem,CraftVertEx cItem,CraftVertEx dItem,int fourColor) { super(aItem.getCenter(),bItem.getCenter(),cItem.getCenter(),dItem.getCenter(),fourColor,fillingType.isSolid()); this.cubeA=aItem; this.cubeB=bItem; this.cubeC=cItem; this.cubeD=dItem;} public ProjContureFourXY fourProjXY(Vector3 xyShift) { update3D(); ProjContureFourXY fourProj=new ProjContureFourXY(A(),cubeA.getName(),B(),cubeB.getName(),C(),cubeC.getName(),D(),cubeD.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xyShift); return fourProj;} public ProjContureFourYZ fourProjYZ(Vector3 yzShift) { update3D(); ProjContureFourYZ fourProj=new ProjContureFourYZ(A(),cubeA.getName(),B(),cubeB.getName(),C(),cubeC.getName(),D(),cubeD.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,yzShift); return fourProj;} public ProjContureFourXZ fourProjXZ(Vector3 xzShift) { update3D(); ProjContureFourXZ fourProj=new ProjContureFourXZ(A(),cubeA.getName(),B(),cubeB.getName(),C(),cubeC.getName(),D(),cubeD.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xzShift); return fourProj;} public void updateFourProjXY(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect,Point2D p1234) { updateFourCommon(p1,p2,p3,p4,relocVect,p1234);} public void updateFourProjYZ(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftYZ(relocVect2.getDx(),relocVect2.getDy()); updateFourCommon(p1,p2,p3,p4,relocVect,p1234);} public void updateFourProjXZ(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftXZ(relocVect2.getDx(),relocVect2.getDy()); updateFourCommon(p1,p2,p3,p4,relocVect,p1234);} private void updateFourCommon(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect,Point2D p1234) { Point3D A=cubeA.getCenter(); Point3D B=cubeB.getCenter(); Point3D C=cubeC.getCenter(); Point3D D=cubeD.getCenter(); if(p1234.equals(p1)) A.shift(relocVect); else if(p1234.equals(p2)) B.shift(relocVect); else if(p1234.equals(p3)) C.shift(relocVect); else if(p1234.equals(p4)) D.shift(relocVect); update(A,B,C,D);} private void update3D() { update(cubeA.getCenter(),cubeB.getCenter(),cubeC.getCenter(),cubeD.getCenter());} private void update() { Point2D aVert=cubeA.getFrontBackViewCenter(); Point2D bVert=cubeB.getFrontBackViewCenter(); Point2D cVert=cubeC.getFrontBackViewCenter(); Point2D dVert=cubeD.getFrontBackViewCenter(); projection=new CustomFourCornersConture2D(aVert,bVert,cVert,dVert,CraftProps.lineColorVirtualSpace.getRGB(),full); projection.setFillingType(fillingType);} public void toPen(CanvasAdapter ics,PaintAdapter pn) { update(); toPenProj3D(ics,pn);} public void toPenProj3D(CanvasAdapter ics,PaintAdapter pn) { if(fillingType.isLines()) projection.toPenConture(ics,pn.select(projection)); if(fillingType.isFrame()) projection.toPenConture(ics,pn.select(projection)); else if(fillingType.isQuery()) projection.toPenConture(ics,pn.select(projection)); else if(fillingType.isSolid()) projection.toPenSolid(ics,pn.select(projection));} public Colorfull setFillingType(FillingType fillingType) { CraftFourCorner.fillingType=fillingType; if(projection !=null) projection.setFillingType(fillingType); return this;} public FillingType getFillingType() { return fillingType;} public String toString() { return "CraftFourCorner [cubeA="+cubeA+", cubeB="+cubeB+", cubeC="+cubeC+", cubeD="+cubeD+", projection="+projection+"]";}} class CraftLine extends Line3D implements CraftShape { private CraftVertEx cubeA; private CraftVertEx cubeB; private CustomLine2D projection; private static FillingType fillingType=FillingType.FT_SOLID; public CraftLine(CraftVertEx aItem,CraftVertEx bItem,int lineColor) { super(aItem.getCenter(),bItem.getCenter(),lineColor); this.cubeA=aItem; this.cubeB=bItem;} public ProjLineXY lineProjXY(Vector3 xyShift) { update3D(); ProjLineXY lineProj=new ProjLineXY(A(),cubeA.getName(),B(),cubeB.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xyShift); return lineProj;} public ProjLineYZ lineProjYZ(Vector3 yzShift) { update3D(); ProjLineYZ lineProj=new ProjLineYZ(A(),cubeA.getName(),B(),cubeB.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,yzShift); return lineProj;} public ProjLineXZ lineProjXZ(Vector3 xzShift) { update3D(); ProjLineXZ lineProj=new ProjLineXZ(A(),cubeA.getName(),B(),cubeB.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xzShift); return lineProj;} public void updateLineProjXY(Point2D p1,Point2D p2,Vector3 relocVect,Point2D p1234) { updateLineCommon(p1,p2,relocVect,p1234);} public void updateLineProjYZ(Point2D p1,Point2D p2,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftYZ(relocVect2.getDx(),relocVect2.getDy()); updateLineCommon(p1,p2,relocVect,p1234);} public void updateLineProjXZ(Point2D p1,Point2D p2,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftXZ(relocVect2.getDx(),relocVect2.getDy()); updateLineCommon(p1,p2,relocVect,p1234);} private void updateLineCommon(Point2D p1,Point2D p2,Vector3 relocVect,Point2D p1234) { Point3D A=cubeA.getCenter(); Point3D B=cubeB.getCenter(); if(p1234.equals(p1)) A.shift(relocVect); else if(p1234.equals(p2)) B.shift(relocVect); update(A,B);} private void update3D() { update(cubeA.getCenter(),cubeB.getCenter());} private void update() { Point2D aVert=cubeA.getFrontBackViewCenter(); Point2D bVert=cubeB.getFrontBackViewCenter(); projection=new CustomLine2D(aVert,bVert,CraftProps.lineColorVirtualSpace.getRGB());} public void toPen(CanvasAdapter ics,PaintAdapter pn) { update(); toPenProj3D(ics,pn);} public void toPenProj3D(CanvasAdapter ics,PaintAdapter pn) { projection.toPen(ics,pn.select(projection));} public Colorfull setFillingType(FillingType fillingType) { CraftLine.fillingType=FillingType.FT_SOLID; return this;} public FillingType getFillingType() { return fillingType;} public String toString() { return "CraftLine [cubeA="+cubeA+", cubeB="+cubeB+", projection="+projection+"]";}} class CraftPoint extends Point3D implements CraftShape { private CraftVertEx cubeA; private CustomPoint2D projection; private static FillingType fillingType=FillingType.FT_SOLID; public CraftPoint(CraftVertEx aItem,int pointColor) { super(aItem.getCenter(),pointColor); this.cubeA=aItem;} public ProjPointXY pointProjXY(Vector3 xyShift) { update3D(); ProjPointXY lineProj=new ProjPointXY(this,cubeA.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xyShift); return lineProj;} public ProjPointYZ pointProjYZ(Vector3 yzShift) { update3D(); ProjPointYZ lineProj=new ProjPointYZ(this,cubeA.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,yzShift); return lineProj;} public ProjPointXZ pointProjXZ(Vector3 xzShift) { update3D(); ProjPointXZ lineProj=new ProjPointXZ(this,cubeA.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xzShift); return lineProj;} public void updatePointProjXY(Point2D point,Vector3 relocVect,Point2D p1234) { updatePointCommon(point,relocVect,p1234);} public void updatePointProjYZ(Point2D point,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftYZ(relocVect2.getDx(),relocVect2.getDy()); updatePointCommon(point,relocVect,p1234);} public void updatePointProjXZ(Point2D point,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftXZ(relocVect2.getDx(),relocVect2.getDy()); updatePointCommon(point,relocVect,p1234);} private void updatePointCommon(Point2D point,Vector3 relocVect,Point2D p1234) { Point3D A=cubeA.getCenter(); if(p1234.equals(point)) A.shift(relocVect); update(A);} private void update3D() { update(cubeA.getCenter());} private void update() { Point2D aVert=cubeA.getFrontBackViewCenter(); projection=new CustomPoint2D(aVert,CraftProps.lineColorVirtualSpace.getRGB());} public void toPen(CanvasAdapter ics,PaintAdapter pn) { update(); toPenProj3D(ics,pn);} public void toPenProj3D(CanvasAdapter ics,PaintAdapter pn) { projection.toPen(ics,pn.select(projection));} public Colorfull setFillingType(FillingType fillingType) { CraftPoint.fillingType=FillingType.FT_SOLID; return this;} public FillingType getFillingType() { return fillingType;} public String toString() { return "CraftPoint [cubeA="+cubeA+", projection="+projection+"]";}} class CraftPyramid extends Pyramid implements CraftShape { private CraftVertEx cubeA; private CraftVertEx cubeB; private CraftVertEx cubeC; private CraftVertEx cubeD; private CustomTriangle2D[] projection; private static FillingType fillingType=FillingType.FT_LINES; public CraftPyramid(CraftVertEx aItem,CraftVertEx bItem,CraftVertEx cItem,CraftVertEx dItem,int triColor) { super(new Triangle3D(aItem.getCenter(),bItem.getCenter(),cItem.getCenter(),triColor,fillingType.isSolid()),dItem.getCenter(),triColor,fillingType.isSolid()); this.cubeA=aItem; this.cubeB=bItem; this.cubeC=cItem; this.cubeD=dItem;} public ProjPyramidXY pyrProjXY(Vector3 xyShift) { update3D(); ProjPyramidXY pyrProj=new ProjPyramidXY(A(),"A",B(),"B",C(),"C",D(),"D",CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xyShift); return pyrProj;} public ProjPyramidYZ pyrProjYZ(Vector3 yzShift) { update3D(); ProjPyramidYZ pyrProj=new ProjPyramidYZ(A(),"A",B(),"B",C(),"C",D(),"D",CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,yzShift); return pyrProj;} public ProjPyramidXZ pyrProjXZ(Vector3 xzShift) { update3D(); ProjPyramidXZ pyrProj=new ProjPyramidXZ(A(),"A",B(),"B",C(),"C",D(),"D",CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xzShift); return pyrProj;} public void updatePyrProjXY(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect,Point2D p1234) { updatePyrCommon(p1,p2,p3,p4,relocVect,p1234);} public void updatePyrProjYZ(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftYZ(relocVect2.getDx(),relocVect2.getDy()); updatePyrCommon(p1,p2,p3,p4,relocVect,p1234);} public void updatePyrProjXZ(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect2,Point2D p1234) { Vector3 relocVect=Vector3.shiftXZ(relocVect2.getDx(),relocVect2.getDy()); updatePyrCommon(p1,p2,p3,p4,relocVect,p1234);} private void updatePyrCommon(Point2D p1,Point2D p2,Point2D p3,Point2D p4,Vector3 relocVect,Point2D p1234) { Point3D A=cubeA.getCenter(); Point3D B=cubeB.getCenter(); Point3D C=cubeC.getCenter(); Point3D D=cubeD.getCenter(); if(p1234.equals(p1)) A.shift(relocVect); else if(p1234.equals(p2)) B.shift(relocVect); else if(p1234.equals(p3)) C.shift(relocVect); else if(p1234.equals(p4)) D.shift(relocVect); update(A,B,C,D);} private void update3D() { update(cubeA.getCenter(),cubeB.getCenter(),cubeC.getCenter(),cubeD.getCenter());} private void update() { Point2D dVert=cubeD.getFrontBackViewCenter(); Point2D aVert=cubeA.getFrontBackViewCenter(); Point2D bVert=cubeB.getFrontBackViewCenter(); Point2D cVert=cubeC.getFrontBackViewCenter(); if(projection==null) projection=new CustomTriangle2D[1+1+1+1]; projection[0]=new CustomTriangle2D(aVert,bVert,cVert,CraftProps.lineColorVirtualSpace.getRGB(),full); projection[0].setFillingType(fillingType); projection[1]=new CustomTriangle2D(dVert,bVert,cVert,CraftProps.lineColorVirtualSpace.getRGB(),full); projection[1].setFillingType(fillingType); projection[1+1]=new CustomTriangle2D(aVert,dVert,cVert,CraftProps.lineColorVirtualSpace.getRGB(),full); projection[1+1].setFillingType(fillingType); projection[1+1+1]=new CustomTriangle2D(aVert,bVert,dVert,CraftProps.lineColorVirtualSpace.getRGB(),full); projection[1+1+1].setFillingType(fillingType);} public void toPen(CanvasAdapter ics,PaintAdapter pn) { update(); toPenProj3D(ics,pn);} public void toPenProj3D(CanvasAdapter ics,PaintAdapter pn) { if(projection !=null) { if(fillingType.isLines() || fillingType.isFrame() || fillingType.isQuery()) for(int i=0; i < projection.length; i++) projection[i].toPenConture(ics,pn.select(projection[i])); else if(fillingType.isSolid()) for(int i=0; i < projection.length; i++) projection[i].toPenSolid(ics,pn.select(projection[i]));}} public Colorfull setFillingType(FillingType fillingType) { CraftPyramid.fillingType=fillingType; if(projection !=null) for(int i=0; i < projection.length; i++) projection[i].setFillingType(fillingType); return this;} public FillingType getFillingType() { return fillingType;} public String toString() { return "CraftPyramid [cubeA="+cubeA+", cubeB="+cubeB+", cubeC="+cubeC+", cubeD="+cubeD+", projection="+Arrays.toString(projection)+"]";}} class CraftTriangle extends Triangle3D implements CraftShape { private CraftVertEx cubeA; private CraftVertEx cubeB; private CraftVertEx cubeC; private CustomTriangle2D projection; private static FillingType fillingType=FillingType.FT_LINES; public CraftTriangle(CraftVertEx aItem,CraftVertEx bItem,CraftVertEx cItem,int triColor) { super(aItem.getCenter(),bItem.getCenter(),cItem.getCenter(),triColor,fillingType.isSolid()); this.cubeA=aItem; this.cubeB=bItem; this.cubeC=cItem;} public ProjTriangleXY triangleProjXY(Vector3 xyShift) { update3D(); ProjTriangleXY triProj=new ProjTriangleXY(A(),cubeA.getName(),B(),cubeB.getName(),C(),cubeC.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xyShift); return triProj;} public ProjTriangleYZ triangleProjYZ(Vector3 yzShift) { update3D(); ProjTriangleYZ triProj=new ProjTriangleYZ(A(),cubeA.getName(),B(),cubeB.getName(),C(),cubeC.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,yzShift); return triProj;} public ProjTriangleXZ triangleProjXZ(Vector3 xzShift) { update3D(); ProjTriangleXZ triProj=new ProjTriangleXZ(A(),cubeA.getName(),B(),cubeB.getName(),C(),cubeC.getName(),CraftProps.lineColorVirtualProjection,CraftProps.textColorVirtualCoords,xzShift); return triProj;} public void updateTriangleProjXY(Point2D p1,Point2D p2,Point2D p3,Vector3 relocVect,Point2D p123) { updateTriCommon(p1,p2,p3,relocVect,p123);} public void updateTriangleProjYZ(Point2D p1,Point2D p2,Point2D p3,Vector3 relocVect2,Point2D p123) { Vector3 relocVect=Vector3.shiftYZ(relocVect2.getDx(),relocVect2.getDy()); updateTriCommon(p1,p2,p3,relocVect,p123);} public void updateTriangleProjXZ(Point2D p1,Point2D p2,Point2D p3,Vector3 relocVect2,Point2D p123) { Vector3 relocVect=Vector3.shiftXZ(relocVect2.getDx(),relocVect2.getDy()); updateTriCommon(p1,p2,p3,relocVect,p123);} private void updateTriCommon(Point2D p1,Point2D p2,Point2D p3,Vector3 relocVect,Point2D p123) { Point3D A=cubeA.getCenter(); Point3D B=cubeB.getCenter(); Point3D C=cubeC.getCenter(); if(p123.equals(p1)) A.shift(relocVect); else if(p123.equals(p2)) B.shift(relocVect); else if(p123.equals(p3)) C.shift(relocVect); update(A,B,C);} private void update3D() { update(cubeA.getCenter(),cubeB.getCenter(),cubeC.getCenter());} private void update() { Point2D aVert=cubeA.getFrontBackViewCenter(); Point2D bVert=cubeB.getFrontBackViewCenter(); Point2D cVert=cubeC.getFrontBackViewCenter(); if(1+1 > 1+1) { projection.getP1().moveTo(aVert); projection.getP2().moveTo(bVert); projection.getP3().moveTo(cVert); projection.setFill(full); projection.setColor(color);} else { projection=new CustomTriangle2D(aVert,bVert,cVert,CraftProps.lineColorVirtualSpace.getRGB(),full); projection.setFillingType(fillingType);}} public void toPen(CanvasAdapter ics,PaintAdapter pn) { update(); toPenProj3D(ics,pn);} public void toPenProj3D(CanvasAdapter ics,PaintAdapter pn) { if(fillingType.isLines()) projection.toPenConture(ics,pn.select(projection)); else if(fillingType.isFrame()) projection.toPenConture(ics,pn.select(projection)); else if(fillingType.isQuery()) projection.toPenConture(ics,pn.select(projection)); else if(fillingType.isSolid()) projection.toPenSolid(ics,pn.select(projection));} public Colorfull setFillingType(FillingType fillingType) { CraftTriangle.fillingType=fillingType; return this;} public FillingType getFillingType() { return fillingType;} public String toString() { return "CraftTriangle [cubeA="+cubeA+", cubeB="+cubeB+", cubeC="+cubeC+", projection="+projection+"]";}} class SouthSettingsPanel extends ControlsPanel { final static String CH_STRIPE_X_WRAP="chStripeX"; final static String CH_STRIPE_Y_WRAP="chStripeY"; final static String CH_STRIPE_Z_WRAP="chStripeZ"; final static String CH_BULK_X_WRAP="chBulkX"; final static String CH_BULK_Y_WRAP="chBulkY"; final static String CH_BULK_Z_WRAP="chBulkZ"; LabeledEditPair leStripeX; LabeledEditPair leStripeY; LabeledEditPair leStripeZ; LabeledEditPair leBulkX; LabeledEditPair leBulkY; LabeledEditPair leBulkZ; public SouthSettingsPanel() { super(); enableCtrls(false); chooseCurrent();} private void chooseCurrent() { boolean reduce=true; enableCtrls(reduce);} public Color getPanelBgColor() { return Color.lightGray;} public LayoutManager getPanelLayout() { return new FlowLayout(FlowLayout.CENTER,3,3);} protected void buildPanel() { append(CH_STRIPE_X_WRAP,leStripeX=new LabeledEditPair("Stripe X:",obtainStripeX())); append(CH_STRIPE_Y_WRAP,leStripeY=new LabeledEditPair("Stripe Y:",obtainStripeY())); append(CH_STRIPE_Z_WRAP,leStripeZ=new LabeledEditPair("Stripe Z:",obtainStripeZ())); append(CH_BULK_X_WRAP,leBulkX=new LabeledEditPair("Bulk X:",obtainBulkX())); append(CH_BULK_Y_WRAP,leBulkY=new LabeledEditPair("Bulk Y:",obtainBulkY())); append(CH_BULK_Z_WRAP,leBulkZ=new LabeledEditPair("Bulk Z:",obtainBulkZ()));} public void enableCtrls(boolean enable) { if(getCtrl(CH_STRIPE_X_WRAP) !=null)((LabeledEditPair) getCtrl(CH_STRIPE_X_WRAP)).enableCtrls(enable); if(getCtrl(CH_STRIPE_Y_WRAP) !=null)((LabeledEditPair) getCtrl(CH_STRIPE_Y_WRAP)).enableCtrls(enable); if(getCtrl(CH_STRIPE_Z_WRAP) !=null)((LabeledEditPair) getCtrl(CH_STRIPE_Z_WRAP)).enableCtrls(enable); if(getCtrl(CH_BULK_X_WRAP) !=null)((LabeledEditPair) getCtrl(CH_BULK_X_WRAP)).enableCtrls(enable); if(getCtrl(CH_BULK_Y_WRAP) !=null)((LabeledEditPair) getCtrl(CH_BULK_Y_WRAP)).enableCtrls(enable); if(getCtrl(CH_BULK_Z_WRAP) !=null)((LabeledEditPair) getCtrl(CH_BULK_Z_WRAP)).enableCtrls(enable);} protected Checkbox obtainStripeX() { Checkbox stripe=new Checkbox(); return stripe;} protected Checkbox obtainStripeY() { Checkbox stripe=new Checkbox(); return stripe;} protected Checkbox obtainStripeZ() { Checkbox stripe=new Checkbox(); return stripe;} protected Checkbox obtainBulkX() { Checkbox bulk=new Checkbox(); return bulk;} protected Checkbox obtainBulkY() { Checkbox bulk=new Checkbox(); return bulk;} protected Checkbox obtainBulkZ() { Checkbox bulk=new Checkbox(); return bulk;} public Checkbox getChStripeX() { return leStripeX.getCheckCtrl();} public Checkbox getChStripeY() { return leStripeY.getCheckCtrl();} public Checkbox getChStripeZ() { return leStripeZ.getCheckCtrl();} public Checkbox getChBulkX() { return leBulkX.getCheckCtrl();} public Checkbox getChBulkY() { return leBulkY.getCheckCtrl();} public Checkbox getChBulkZ() { return leBulkZ.getCheckCtrl();}}