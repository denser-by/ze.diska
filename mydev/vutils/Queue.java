package mydev.vutils; public class Queue { private long qSize; private QueueNode first; private QueueNode last; public Queue() { super(); this.qSize=0L; this.last=null; this.first=null;} public Queue(Object[] dataItems) { this(); enqueueQueueRecords(dataItems);} public Queue(Queue otherQueue) { this(); enqueueQueueRecords(otherQueue);} public synchronized void enqueueQueueRecords(Object[] dataItems) { for(int i=0; i < dataItems.length; i++) { enqueueQueueRecord(dataItems[i]);}} public synchronized void enqueueQueueRecords(Queue otherQueue) { Object[] dataItems=otherQueue.getQueueRecordsArray(); enqueueQueueRecords(dataItems);} public synchronized void enqueueQueueRecord(Object data) { qSize+=1L; QueueNode newLastNode=new QueueNode(data); if(last !=null) last.next=newLastNode; last=newLastNode; if(first==null) first=newLastNode;} public synchronized Object dequeueQueueRecord() { if(first !=null) { qSize-=1L; QueueNode removeNode=first; first=first.next; return removeNode.data;} return null;} public synchronized Object getQueueRecord(long idx) { QueueNode curNode=first; long qPos=0L; while(curNode !=null) { if(qPos==idx) return curNode.data; curNode=curNode.next; qPos++;} return null;} public synchronized void setQueueRecord(long idx,Object dataReplace) { QueueNode curNode=first; long qPos=0L; while(curNode !=null) { if(qPos==idx) { curNode.data=dataReplace; return;} curNode=curNode.next; qPos++;}} public synchronized Object[] getQueueRecordsArray() { int arrSize=qSize > Integer.MAX_VALUE ? Integer.MAX_VALUE :(int) qSize; Object[] array=new Object[arrSize]; QueueNode curNode=first; for(int i=0; curNode !=null && i < array.length; i++) { array[i]=curNode.data; curNode=curNode.next;} return array;} public Queue quickQueueCopy() { Object[] dataItems=this.getQueueRecordsArray(); return new Queue(dataItems);} public synchronized long sizeOfQueue() { return qSize;} public synchronized boolean isEmptyQueue() { return first==null;} public synchronized void clearQueue() { this.qSize=0L; this.last=null; this.first=null;} public synchronized boolean has(Object what) { return find(what) >-1L;} public synchronized long find(Object what) { QueueNode curNode=first; long i=0L; while(curNode !=null) { Object item=curNode.data; if(what !=null) { if(what.equals(item)) return i;} else if(what==item) return i; curNode=curNode.next; i++;} return-1;} public synchronized Object delete(long index) { if(qSize < 0) return null; Object result=null; if(index==0) { qSize-=1L; result=first.data; if(first.next !=null) first=first.next; else { first=null; last=null;}} else if(index > 0) { QueueNode curNode=first; long k=0L; while(k < index-1) { if(curNode.next !=null) curNode=curNode.next; k++;} if(curNode.next !=null) { qSize-=1L; if(curNode.next==last) last=curNode; result=curNode.next.data; curNode.next=curNode.next.next;}} return result;} public synchronized void insert(long index,Object newItem) { QueueNode newNode=new QueueNode(newItem); if(first==null) { qSize=0L; first=newNode; last=newNode;} else { qSize+=1L; if(index==0) { newNode.next=first; first=newNode;} else if(index > 0 && index < qSize-1) { QueueNode curNode=first; long k=index; while(--k > 0L) curNode=curNode.next; newNode.next=curNode.next; curNode.next=newNode;} else { last.next=newNode; last=newNode;}}} public synchronized Object remove(Object what) { long idx=find(what); if(idx >-1L) return delete(idx); return null;} public synchronized Object viewLast() { if(last !=null) return last.data; return null;} public synchronized Object viewFirst() { if(first !=null) return first.data; return null;}} class QueueNode { protected Object data; protected QueueNode next; public QueueNode(Object data) { super(); this.data=data; this.next=null;} public QueueNode(Object data,QueueNode next) { super(); this.data=data; this.next=next;} public Object getData() { return data;} public void setData(Object data) { this.data=data;} public QueueNode getNext() { return next;} public void setNext(QueueNode next) { this.next=next;}}