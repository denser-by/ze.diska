package mydev.cool; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Canvas; import java.awt.Color; import java.awt.Component; import java.awt.Container; import java.awt.Dimension; import java.awt.Event; import java.awt.Frame; import java.awt.Graphics; import java.awt.Image; import java.awt.LayoutManager; import java.awt.Point; import java.awt.Rectangle; import java.awt.image.ImageObserver; import java.awt.image.MemoryImageSource; public class Engine extends Frame { boolean stop; boolean resetup; CanvasX cx; short cxWidth; short cxHeight; Point bsLoc; Dimension bsSize; Button bs; Point wsLoc; Dimension wsSize; boolean started; public Engine() { super("Appplication"); setBackground(Color.gray); this.stop=false; this.resetup=false; this.cxWidth=10; this.cxHeight=10; this.started=false;} public static void main(String[] args) { Engine eg=Engine.build(); eg.resize(800,600); eg.prepare(); eg.show(); while(!eg.stop()) { if(eg.resetup) eg.correct(); if(!eg.started && eg.cx !=null) { eg.started=true; eg.cx.startAnimation();} try { Thread.sleep(300);} catch(InterruptedException e) { e.getMessage();}} eg.cx.stopAnimation(); eg.hide(); eg.disable(); System.exit(1-1);} void correct() { if(resetup) { resetup=false; Point wsLoc2=location(); Dimension wsSize2=size(); int ds=(bsSize.width)+((wsSize2.width-wsLoc2.x)-(wsSize.width-wsLoc.x)); int cs=(bsSize.height)+((wsSize2.height-wsLoc2.y)-(wsSize.height-wsLoc.y)); cx.resize(ds,cs); layout(); cx.invalidate(); cx.repaint();}} boolean stop() { return stop;} void prepare() { setLayout(new BorderLayout()); bs=new Button("Start"); add("Center",bs);} public static Engine build() { Engine eg=new Engine(); return eg;} public void paint(Graphics cs) { super.paint(cs); if(bs !=null) { wsLoc=location(); wsSize=size(); bsLoc=bs.location(); bsSize=bs.size(); remove(bs); setLayout(new CenterLayout()); Rectangle winInitRec=new Rectangle(wsLoc.x,wsLoc.y,wsSize.width,wsSize.height); Rectangle objInitRec=new Rectangle(bsLoc.x,bsLoc.y,bsSize.width,bsSize.height); add(cx=new CanvasX(winInitRec,objInitRec)); bs=null;} boolean tri=false; Rectangle d=bounds(); if(d.width !=cxWidth) tri=true; if(d.height !=cxHeight) tri=true; if(tri) { cxWidth=(short) d.width; cxHeight=(short) d.height; resetup=true;}} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) stop=true; return super.handleEvent(et);}} class CenterLayout implements LayoutManager { public CenterLayout() { super();} public void addLayoutComponent(String name,Component comp) {;} public void removeLayoutComponent(Component comp) {;} public Dimension preferredLayoutSize(Container target) { int w=0; int h=0; int cnum=target.countComponents(); for(int i=0; i < cnum; i++) { Component comp=target.getComponent(i); Dimension d=comp.size(); w+=d.width; h+=d.height;} Dimension dim=new Dimension(w,h); return dim;} public Dimension minimumLayoutSize(Container target) { int w=0; int h=0; int cnum=target.countComponents(); for(int i=0; i < cnum; i++) { Component comp=target.getComponent(i); Dimension d=comp.size(); w+=d.width; h+=d.height;} Dimension dim=new Dimension(w,h); return dim;} public void layoutContainer(Container target) { Dimension ts=target.size(); int cnum=target.countComponents(); for(int i=0; i < cnum; i++) { Component comp=target.getComponent(i); Dimension d=comp.size(); if(comp instanceof CanvasX) { CanvasX cx=(CanvasX) comp; Rectangle r=cx.objInitRec; comp.move(r.x,r.y); comp.resize(d);} else { comp.move((ts.width-d.width) / 2,(ts.height-d.height) / 2); comp.resize(d);}}}} interface Iterator { void iterateModel(); void clearScene(); void prepareView(); void publishView();} interface Animator extends Runnable { void startAnimation(); void stopAnimation();} class CanvasX extends Canvas implements ImageObserver,Iterator,Animator { Rectangle winInitRec; Rectangle objInitRec; Image img; short imgWidth; short imgHeight; boolean redraw; int[] pix; boolean stop; int red; boolean br; int green; boolean bg; int blue; boolean bb; int v; public CanvasX(Rectangle winInitRec,Rectangle objInitRec) { super(); this.winInitRec=winInitRec; this.objInitRec=objInitRec; this.imgWidth=0; this.imgHeight=0; this.redraw=false; this.red=100; this.green=100; this.blue=100; this.br=true; this.bg=false; this.bb=false; this.v=0; setBackground(Color.white); resize(10,10); stop=false;} public void paint(Graphics cs) { super.paint(cs); Rectangle d=bounds(); boolean f1=false; if(imgWidth !=d.width) f1=true; if(imgHeight !=d.height) f1=true; if(f1) { imgWidth=(short) d.width; imgHeight=(short) d.height; pix=new int[imgWidth * imgHeight]; int index=0; for(int y=0; y < imgHeight; y++) { for(int x=0; x < imgWidth; x++) { pix[index++]=rgb(red,green,blue);}} redraw=true;} if(redraw) { redraw=false; img=createImage(new MemoryImageSource(imgWidth,imgHeight,pix,0,imgWidth));} if(img !=null) cs.drawImage(img,0,0,this);} int rgb(int r,int g,int b) { int color=(255 << 24) |(r << 16) |(g << 8) | b; return color;} public void run() { while(!stop) { iterateModel(); clearScene(); prepareView(); publishView(); try { Thread.sleep(30);} catch(InterruptedException e) { e.getMessage();}}} public void startAnimation() { stop=false; new Thread(this).start();} public void stopAnimation() { stop=true;} public void iterateModel() { v=(int)(v+100 * Math.random()); v=v % 41; int dt1=3; int dt2=7; int dt3=11; int rest1=v % dt1; int rest2=v % dt2; int rest3=v % dt3; if(br && red+dt1 < 255) red+=rest1; else if(!br && red-dt1 > 0) red-=rest1; else br=!br; if(bg && green+dt2 < 255) green+=rest2; else if(!bg && green-dt2 > 0) green-=rest2; else bg=!bg; if(bb && blue+dt3 < 255) blue+=rest3; else if(!bb && blue-dt3 > 0) blue-=rest3; else bb=!bb;} public void clearScene() { int index=0; if(pix !=null && pix.length==imgHeight * imgWidth) for(int y=0; y < imgHeight; y++) for(int x=0; x < imgWidth; x++) pix[index++]=rgb(0,0,0);} public void prepareView() { int index=0; if(pix !=null && pix.length==imgHeight * imgWidth) for(int y=0; y < imgHeight; y++) for(int x=0; x < imgWidth; x++) pix[index++]=rgb(red,green,blue); redraw=true;} public void publishView() { invalidate(); repaint();}}
