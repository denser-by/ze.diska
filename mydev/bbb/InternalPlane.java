package mydev.bbb; import java.awt.BorderLayout; import java.awt.Color; import java.awt.Event; import java.awt.Graphics; import java.awt.LayoutManager; import java.awt.Panel; import mydev.about.CanvasAdapter; import mydev.about.PaintAdapter; import mydev.uix.CommonCanvas; import mydev.uix.Props; import mydev.vutils.Queue; public class InternalPlane extends Panel { SandboxB bs; protected CommonCanvas csv; private InternalPlaneCanvasContext ctx; public InternalPlane(Color bgColor,Color borderColor) { super(); setLayout(getPanelLayout()); setBackground(getPanelBgColor()); this.csv=obtainCommonCanvas(bgColor,borderColor); add("Center",csv);} protected CommonCanvas obtainCommonCanvas(Color bgColor,Color borderColor) { initContext(); return new InternalPlaneCanvas(bgColor,borderColor,ctx);} protected void initContext() { this.ctx=new InternalPlaneCanvasContext();} public Graphics getDrawGraphics() { Graphics cs1=csv.getGraphics(); return cs1;} public LayoutManager getPanelLayout() { int bs=getBorderSpace(); return new BorderLayout(bs,bs);} public Color getPanelBgColor() { return Props.bgCtrlPanelColor;} public int getBorderSpace() { return 1-1;} public boolean mouseDown(Event evt,int x,int y) { bs=looking4(x,y); if(bs !=null) bs.mouseDown(evt,x,y); return super.mouseDown(evt,x,y);} public boolean mouseDrag(Event evt,int x,int y) { if(bs !=null) bs.mouseDrag(evt,x,y); return super.mouseDrag(evt,x,y);} public boolean mouseUp(Event evt,int x,int y) { if(bs !=null) bs.mouseUp(evt,x,y); return super.mouseUp(evt,x,y);} public boolean mouseMove(Event evt,int x,int y) { if(bs !=null) bs.mouseMove(evt,x,y); return super.mouseMove(evt,x,y);} public boolean mouseEnter(Event evt,int x,int y) { if(bs !=null) bs.mouseEnter(evt,x,y); return super.mouseEnter(evt,x,y);} public boolean mouseExit(Event evt,int x,int y) { if(bs !=null) bs.mouseExit(evt,x,y); return super.mouseExit(evt,x,y);} public void regBOkno(BOkno bo,SandboxB bs) { this.bs=bs; ctx.items.enqueueQueueRecord(new RePair(bo,bs));} public boolean hasBOknos() { return ctx.items !=null && ctx.items.sizeOfQueue() > 0;} public boolean checkRepaint() { if(csv.hasChanges()) { csv.clearChangesMark(); return true;} return bs !=null ? bs.peekRepaint() : false;} public void performRepaint() { csv.refreshUpdatable();} SandboxB looking4(int x,int y) { if(ctx !=null && ctx.items !=null) { Queue iter=ctx.items.quickQueueCopy(); while(iter.sizeOfQueue() > 0) { RePair prs=(RePair) iter.dequeueQueueRecord(); if(prs.turbo(x,y)) return prs.nebo;}} return null;} public void clearBOknos() { csv.clearItems();} public void markRepaint() { csv.markChanges();}} class InternalPlaneCanvasContext { Queue items; public InternalPlaneCanvasContext() { itemsInit();} public void itemsInit() { this.items=new Queue();}} class InternalPlaneCanvas extends CommonCanvas { InternalPlaneCanvasContext ctx; public InternalPlaneCanvas(InternalPlaneCanvasContext ctx) { this(Color.gray,Color.lightGray,ctx);} public InternalPlaneCanvas(Color bgColor,Color borderColor,InternalPlaneCanvasContext ctx) { super(bgColor,borderColor); this.ctx=ctx;} public void clearItems() { ctx.itemsInit();} protected void drawItems(CanvasAdapter ics,PaintAdapter pn) { Location.regInternalSize(sCur.width,sCur.height);}} class RePair { BOkno bochock; SandboxB nebo; public RePair(BOkno bochock,SandboxB nebo) { super(); this.bochock=bochock; this.nebo=nebo;} public boolean turbo(int x,int y) { return bochock.lit(x,y);}}
