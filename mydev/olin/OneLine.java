package mydev.olin; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Checkbox; import java.awt.Color; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.GridLayout; import java.awt.Label; import java.awt.List; import java.awt.Panel; import java.awt.TextArea; import java.awt.TextField; import java.io.File; import java.io.IOException; import java.util.Date; import mydev.aaa.IO; import mydev.aaa.Sleeper; import mydev.vutils.AverageRec; import mydev.vutils.Data; import mydev.vutils.Ester; import mydev.vutils.ExpectHere; import mydev.vutils.Files; import mydev.vutils.Filter; import mydev.vutils.Metr; import mydev.vutils.Spiska; import mydev.vutils.Time; public class OneLine extends Frame implements Runnable { final static boolean D=false; PathPanel pathPanel; LeftPanel leftPanel; QuadeParallelPanel quadePanel; LogPanel logPanel; String pathParam; String leftPanelParam; SourceProcessor spCurrent; public OneLine(String title) { super(title); setLayout(new BorderLayout()); setBackground(Color.gray);} public static void main(String[] args) throws IOException { OneLine main=new OneLine("Leaves Days Publicity"); if(args.length > 0) { String param=args[0]; String line=SourcePanel.line(param); main.setPathParam(param); System.out.println(line); return;} else { System.out.println("Please specify source file as a parameter.");} if(D) System.out.println("Publish Source Studio"); main.show(); main.reMoveRnd(); main.resize(1024,768); main.start(); main.pack(); Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { main.refreshUpdatable(); sleeper.sleep(123);} main.hide(); main.dispose(); System.exit(1-1);} public void setPathParam(String path) { this.pathParam=path; File file=new File(path); String fullPath=file.getAbsolutePath(); if(file.isDirectory()) updateInfo(null); else { String item=file.getName(); leftPanelParam=item; leftPanel.addItem(item,fullPath);}} protected void reMoveRnd() { long x1=new Date().getTime(); if(x1 < 0) x1 *=-1; x1=10+3 *(x1 % 100); long y1=new Date().getTime(); if(y1 < 0) y1 *=-1; y1=10+2 *(y1 % 100); move((int) x1,(int) y1);} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) WorkingHolder.working=false; if(et.id==Event.ACTION_EVENT && et.target==this.pathPanel.quadePanel.getQuadeBtn()) { pathPanel.quadePanel.changeState(); cRemake(); pack(); invalidate(); repaint();} if(et.id==Event.ACTION_EVENT && et.target==this.pathPanel.btScan) { leftPanel.sizeSavePanel.sizeAvgPanel.avgPanel.clear(); updateInfo(null); quadePanel.clearAverage();} if(et.id==Event.LIST_SELECT && et.target==this.leftPanel.getItemsCtrl()) { quadePanel.initSource(); spCurrent=leftSelected(); leftPanel.sizeSavePanel.savePanel.btOneLine.enable(true);} if(et.id==Event.ACTION_EVENT && et.target==this.leftPanel.sizeSavePanel.savePanel.btOneLine) { spCurrent.process(false); leftPanel.sizeSavePanel.savePanel.btOneLine.enable(!true); leftPanel.sizeSavePanel.savePanel.btSave.enable(true);} if(et.id==Event.ACTION_EVENT && et.target==this.leftPanel.sizeSavePanel.savePanel.btSave) { spCurrent.saveSourceLine(); leftPanel.sizeSavePanel.savePanel.btOneLine.enable(false); leftPanel.sizeSavePanel.savePanel.btSave.enable(false);} if(et.id==Event.ACTION_EVENT && et.target==this.leftPanel.sizeSavePanel.savePanel.btAuto) { if(this.leftPanel.itemsNum() < 1) { ExpectHere eh=new ExpectHere(); updateInfo(eh); eh.stopUntilExpected();} autoLines();} return super.handleEvent(et);} public void run() { SourceProcessor sp; Sleeper sleeper=new Sleeper(); Time t=new Time(); t.start(); int size1=leftPanel.itemsNum(); if(size1 > 0) { for(int i=0; i < size1; i++) { leftPanel.selectItem(i); sp=leftSelected(); sp.process(true); System.out.print("1"); while(quadePanel.hasAvailable()==false) { sleeper.sleep(166); System.out.print("SLEEP_1");} System.out.println("2");} while(quadePanel.hasInProgress()) { sleeper.sleep(166); System.out.print("SLEEP_2");} System.out.println("");} t.trust(); logPanel.addLogComplete("Average records("+quadePanel.getAverageRec().getRecordsNum()+") processing time is "+quadePanel.getAverageRec().getAverageTime()+"s also min time is "+quadePanel.getAverageRec().getMinTime()+"s and max time is "+quadePanel.getAverageRec().getMaxTime()+"s"); logPanel.addLogComplete("Auto OneLine transform complete "+t.ess()); pathPanel.btScan.enable(true); leftPanel.sizeSavePanel.savePanel.btAuto.enable(true); leftPanel.enableCtrls(true); leftSelected();} protected void autoLines() { leftPanel.sizeSavePanel.savePanel.btAuto.enable(false); pathPanel.btScan.enable(false); leftPanel.enableCtrls(false); new Thread(this).start();} protected void start() { logPanel=new LogPanel(); add("North",pathPanel=new PathPanel(pathParam)); add("West",leftPanel=new LeftPanel()); cRemake(); add("South",logPanel); if(leftPanelParam !=null) { leftPanel.selectItem(0); this.leftPanel.ignorStatPanel.statPanel.tfAmount.setText("1"); this.leftPanel.sizeSavePanel.sizeAvgPanel.sizePanel.tfSize.setText(""+new File(pathParam).length()); spCurrent=quadePanel.getFirst(); spCurrent.readSource(leftPanelParam,pathParam); spCurrent.process(false); this.leftPanel.sizeSavePanel.savePanel.btSave.enable(true);}} void cRemake() { if(quadePanel !=null) remove(quadePanel); add("Center",quadePanel=QuadeParallelPanel.create(pathPanel.quadePanel.getQuade(),logPanel));} protected void refreshUpdatable() { leftPanel.updateOnUiThread(quadePanel.getAverageRec());} protected void updateInfo(ExpectHere eh) { String path=pathPanel.tfPath.getText(); leftPanel.clearItems(); quadePanel.initSource(); leftPanel.ignorStatPanel.statPanel.tfPosition.setText(""); leftPanel.sizeSavePanel.savePanel.dropBtnSkipPosition(); new Thread(new ScanLeft(leftPanel,path,logPanel,eh)).start();} protected SourceProcessor leftSelected() { int idxSel=leftPanel.getSelectedIdx(); String curSel=leftPanel.getSelectedName(); String path=leftPanel.getSelectedPath(); logPanel.addLog("Selected item "+path); SourceProcessor sp=quadePanel.assignSource(curSel,path); leftPanel.ignorStatPanel.statPanel.tfPosition.setText(""+(idxSel+1)); return sp;}} class LogPanel extends Panel implements Runnable { TextArea taLogging; private String res=new String(); private Object syncObj=new Object(); private Thread worker1; private boolean needUpdate; public LogPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("Center",taLogging=new TextArea(5,20)); taLogging.setEditable(false);} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { synchronized(syncObj) { if(needUpdate) { taLogging.setText(res.toString()); needUpdate=false;}} sleeper.sleep(130 * 2);}} public void addLog(String item) { if(item !=null && item.length() > 0) { synchronized(syncObj) { res=new Ester(item).append('\n')+res; needUpdate=true;} if(worker1==null) { worker1=new Thread(this); worker1.start();}}} public void addLogComplete(String item) { addLog(item.replace('_',':'));}} class WorkingHolder { static boolean working=true;} class PathPanel extends Panel { Label lbPath; TextField tfPath; Button btScan; QuadeButton quadePanel; public PathPanel(String pathParam) { super(); setLayout(new FlowLayout()); setBackground(Props.bgTopColor); add(lbPath=new Label("Source location:")); add(tfPath=new TextField("",50+20+10+5-30-20+5)); tfPath.setText("C:\\Users\\fantom\\workspace\\Architecho"); tfPath.setText("C:\\Users\\fantom\\workspace"); tfPath.setText("C:\\Users\\fantom\\workspace2"); tfPath.setText("C:\\Users\\fantom\\workspace"); if(pathParam !=null) tfPath.setText(pathParam); add(btScan=new Button("Scan")); add(quadePanel=new QuadeButton());}} class LeftPanel extends Panel { IgnorStatPanel ignorStatPanel; private List lsItems; LeftSizeSavePanel sizeSavePanel; private Spiska leftItems=new Spiska(); public LeftPanel() { super(); setBackground(Props.bgAlertColor); setLayout(new BorderLayout()); add("North",ignorStatPanel=new IgnorStatPanel()); add("Center",lsItems=new List(22,false)); add("South",sizeSavePanel=new LeftSizeSavePanel());} public List getItemsCtrl() { return lsItems;} public void selectItem(int idx) { lsItems.select(idx);} public void enableCtrls(boolean enable) { lsItems.enable(enable);} public String getSelectedName() { String curSel=lsItems.getSelectedItem(); return curSel;} public int getSelectedIdx() { int idxSel=lsItems.getSelectedIndex(); return idxSel;} public String getSelectedPath() { int idxSel=lsItems.getSelectedIndex(); String path=(String) leftItems.at(idxSel); return path;} public int itemsNum() { return lsItems.countItems();} public void clearItems() { lsItems.clear(); leftItems=new Spiska();} public void updateOnUiThread(AverageRec mar) { sizeSavePanel.sizeAvgPanel.avgPanel.updateMinMaxAvg(mar);} public void addItem(String item,String fullPath) { lsItems.addItem(item); leftItems.append(fullPath);}} class IgnorStatPanel extends Panel { TextArea taIgnoreList; StatPanel statPanel; public IgnorStatPanel() { super(); setLayout(new BorderLayout()); add("Center",taIgnoreList=new TextArea(4,4)); add("South",statPanel=new StatPanel()); add("West",new Label("Ignore list:")); taIgnoreList.setText("mydev."+"aaa;"+"\n"+"mydev."+"vutils;"+"\n"+"mydev."+"oneway;"+"\n"+"mydev."+"oline;"+"\n"+"mydev."+"gforce;"+"\n"+"mydev."+"t3;");}} class LeftSizeSavePanel extends Panel { LeftOneLineSavePanel savePanel; SizeAvgPanel sizeAvgPanel; public LeftSizeSavePanel() { super(); setBackground(Color.lightGray); setLayout(new BorderLayout()); add("North",savePanel=new LeftOneLineSavePanel()); add("Center",sizeAvgPanel=new SizeAvgPanel());}} class LeftOneLineSavePanel extends Panel { Button btOneLine; Button btSave; Button btAuto; public LeftOneLineSavePanel() { super(); setBackground(Props.bgDownColor); setLayout(new FlowLayout()); add(btOneLine=new Button("OneLine")); add(btSave=new Button("Save")); add(new AutoButtonFrame(btAuto=new Button("Auto"))); dropBtnSkipPosition(); btAuto.enable();} public void dropBtnSkipPosition() { btOneLine.enable(false); btSave.enable(false); btAuto.enable(false);}} class AutoButtonFrame extends Panel { Button autoBtn; public AutoButtonFrame(Button autoBtn) { super(); this.autoBtn=autoBtn; setLayout(new FlowLayout(FlowLayout.LEFT,2+1,2)); setBackground(Color.yellow); add(autoBtn);}} class StatPanel extends Panel { Label lbDst; Label lbAmount; TextField tfAmount; TextField tfPosition; public StatPanel() { super(); setBackground(Color.gray); setLayout(new FlowLayout()); add(lbDst=new Label("*.java")); add(tfPosition=new TextField(5-1)); tfPosition.setEditable(false); add(tfAmount=new TextField("0",12-5-1)); add(lbAmount=new Label("file(s)")); tfAmount.setEditable(false);}} class SizePanel extends Panel { Label lbSize; TextField tfSize; public SizePanel() { super(); setBackground(Color.gray); setLayout(new FlowLayout()); add(tfSize=new TextField("0",25-1-2)); add(lbSize=new Label("byte(s)")); tfSize.setEditable(false);}} class ScanLeft implements Runnable { private LeftPanel leftPanel; private LogPanel logPanel; private String path; private long amount; private long size; private ExpectHere expectHere; public ScanLeft(LeftPanel leftPanel,String path,LogPanel logPanel,ExpectHere eh) { super(); this.leftPanel=leftPanel; this.path=path; this.logPanel=logPanel; this.expectHere=eh;} void displayAmount(Metr m) { leftPanel.ignorStatPanel.statPanel.tfAmount.setText(""+m.repr(' '));} void displaySize(Metr m) { leftPanel.sizeSavePanel.sizeAvgPanel.sizePanel.tfSize.setText(""+m.repr(','));} public void run() { Time t=new Time(); t.start(); updateStat(); scanItems(path,".java"); t.trust(); logPanel.addLogComplete("Source scan complete "+t.ess()); leftPanel.sizeSavePanel.savePanel.btAuto.enable(); if(expectHere !=null) expectHere.markAsReached();} protected void updateStat() { Metr m=new Metr(0); m.inc(amount); displayAmount(m); m=new Metr(0); m.inc(size); displaySize(m);} protected void scanItems(String path,String ext) { Ester[] start=new Files().tree(new Ester(path)); Ester[] select=new Filter().endsWithIncensitive(start,new Ester(ext)); String ignoreList=this.leftPanel.ignorStatPanel.taIgnoreList.getText(); for(int i=0; i < select.length; i++) { File file=new File(select[i].toString()); if(hasIgnoreCoincidence(file.getAbsolutePath(),ignoreList)) continue; leftPanel.addItem(file.getName(),file.getAbsolutePath()); amount+=1; size+=file.length(); updateStat();}} boolean hasIgnoreCoincidence(String absPath,String ignoreList) { Spiska ign=getLines(ignoreList); try { byte[] data=new IO().read(absPath); String content=new Ester(data).toString(); for(int i=0; i < ign.size(); i++) { String c=(String) ign.at(i); boolean contains=content.indexOf(c) >= 0; if(OneLine.D) System.out.println(" C <"+c+"> "+contains+" "+new File(absPath).getName()); if(contains) return true;}} catch(IOException e) { e.printStackTrace();} return false;} Spiska getLines(String ignoreList) { Spiska list=new Spiska(); int idx; do { idx=ignoreList.lastIndexOf('\n'); if(idx >= 0) { String cur=ignoreList.substring(idx+1); list.append(cur); ignoreList=ignoreList.substring(0,idx);}} while(idx >= 0); if(ignoreList.length() > 0) list.append(ignoreList); if(OneLine.D) System.out.println(" D "+new Data().dump(list)); return list;}} class Props { final static Color bgTopColor=Color.green; final static Color bgDownColor=Color.lightGray; final static Color bgAlertColor=Color.yellow;} class Command { public final static int ID_READY=1; public final static int ID_INIT=1+1; public final static int ID_READ_SOURCE=1+1+1; public final static int ID_ONELINE=1+1+1+1; public final static int ID_SAVE_SOURCE=1+1+1+1+1; private int id; protected boolean complete; Command(int id) { super(); this.id=id; this.complete=false;} public static Command create(int cmdId) { Command cmd=null; switch(cmdId) { case ID_READY : case ID_INIT : cmd=new Command(cmdId); break;} return cmd;} public int getId() { return id;} public boolean isComplete() { return complete;}} class CommandRead extends Command { private String name; private String path; public CommandRead(String name,String path) { super(ID_READ_SOURCE); this.name=name; this.path=path;} public String getName() { return name;} public String getPath() { return path;}} class CommandProcess extends Command { private boolean needSave; private ReadyFreeHolder readyFree; public CommandProcess(boolean needSave,ReadyFreeHolder readyFree) { super(ID_ONELINE); this.needSave=needSave; this.readyFree=readyFree;} public ReadyFreeHolder getReadyFree() { return readyFree;} public boolean isNeedSave() { return needSave;}} class CommandSave extends Command { private ReadyFreeHolder readyFree; public CommandSave(ReadyFreeHolder readyFree) { super(ID_SAVE_SOURCE); this.readyFree=readyFree;} public ReadyFreeHolder getReadyFree() { return readyFree;}} interface SourceProcessor { boolean isReadyFree(); void readSource(String name,String path); void process(boolean needSave); void saveSourceLine();} class CommandQueue { private Spiska items=new Spiska(); private int current; public CommandQueue() { super(); this.current=-1;} public void push(Command cmd) { items.append(cmd);} public boolean hasSomeWork() { return current < items.size()-1;} public Command nextCurrent() { current++; Command cmd=(Command) items.at(current); return cmd;} public void dump() { new Data().dump(items);}} class ReadyFreeHolder { private boolean readyFree; public ReadyFreeHolder() { super(); this.readyFree=true;} public boolean isFree() { return readyFree==true;} public void setBusy() { this.readyFree=false;} public void setFree() { this.readyFree=true;}} class SourcePanel extends Panel implements Runnable,SourceProcessor { TextField tfSrcName; TextArea taSource; private String name; private String path; LogPanel logPanel; AverageRec ar=new AverageRec(); private Thread worker1; private ReadyFreeHolder readyFree; private CommandQueue cq=new CommandQueue(); public SourcePanel(LogPanel logPanel) { super(); this.logPanel=logPanel; setLayout(new BorderLayout()); setBackground(Color.lightGray); add("North",tfSrcName=new TextField()); add("Center",taSource=new TextArea()); tfSrcName.setEditable(false); taSource.setEditable(false); this.readyFree=new ReadyFreeHolder();} public boolean isReadyFree() { return readyFree.isFree();} public void readSource(String name,String path) { Command cmd=new CommandRead(name,path); cq.push(cmd); if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void process(boolean needSave) { readyFree.setBusy(); Command cmd=new CommandProcess(needSave,readyFree); cq.push(cmd); if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void saveSourceLine() { Command cmd=new CommandSave(readyFree); cq.push(cmd); if(worker1==null) { worker1=new Thread(this); worker1.start();}} public static String line(String path) throws IOException { return new mydev.oline.OneLine().line(path);} public static String loadSource(String path) throws IOException { return new Ester("").append(new mydev.oline.OneLine().read(path)).toString();} private void interpret(Command cmd) { switch(cmd.getId()) { case Command.ID_READY : break; case Command.ID_INIT : break; case Command.ID_READ_SOURCE : readSource((CommandRead) cmd); break; case Command.ID_ONELINE : oneLineTansform((CommandProcess) cmd); break; case Command.ID_SAVE_SOURCE : oneLineSave(((CommandSave) cmd).getReadyFree()); break;}} private void readSource(CommandRead cmd) { name=cmd.getName(); tfSrcName.setText(name); path=cmd.getPath(); String source=""; if(path !=null && path.length() > 0) try { source=loadSource(path);} catch(IOException ex) { System.out.println("Can't read "+path+" . "+ex.getMessage()); ex.printStackTrace(); logPanel.addLog("Can't read "+path+" . "+ex.getMessage());} taSource.setText(source);} private void oneLineTansform(CommandProcess cmd) { ar.start(); logPanel.addLog("Starting "+path); try { String source=line(path); taSource.setText(source); logPanel.addLog("One line transformation complete "+name); if(cmd.isNeedSave()) oneLineSave(cmd.getReadyFree()); else cmd.getReadyFree().setFree(); taSource.setText(""); tfSrcName.setText("");} catch(IOException ex) { System.out.println("Can't transform "+path+" . "+ex.getMessage()); ex.printStackTrace(); logPanel.addLog("Can't transform "+path+" . "+ex.getMessage());} ar.trust();} private void oneLineSave(ReadyFreeHolder readyFree) { String content=taSource.getText(); logPanel.addLog("Save line with "+new Metr(content.length()).repr(',')+" byte(s) to "+path); try { new Data().write(path,new Ester(content)); logPanel.addLog(""+name+" complete"); readyFree.setFree();} catch(IOException ex) { System.out.println("Can't write "+path+" . "+ex.getMessage()); ex.printStackTrace(); logPanel.addLog("Can't write "+path+" . "+ex.getMessage());}} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { if(cq.hasSomeWork()) { Command cmd=cq.nextCurrent(); interpret(cmd);} sleeper.sleep(5 / 4);}}} class QuadeParallelPanel extends Panel { private Spiska sps=new Spiska(); private MegaAverageRec mar=new MegaAverageRec(); public QuadeParallelPanel(int n,LogPanel logPanel) { super(); setLayout(new GridLayout(n,n,2+1,2)); setBackground(Color.yellow); SourcePanel sp; for(int i=0; i < n; i++) for(int j=0; j < n; j++) { add(sp=new SourcePanel(logPanel)); mar.addItem(sp.ar); sps.append(sp);}} public AverageRec getAverageRec() { return mar;} public void clearAverage() { mar.clearItems();} public SourcePanel getFirst() { return(SourcePanel) sps.at(0);} public boolean hasInProgress() { boolean result=false; for(int i=0; i < sps.size(); i++) { SourcePanel sp=(SourcePanel) sps.at(i); if(sp.isReadyFree()==false) result=true;} return result;} public boolean hasAvailable() { for(int i=0; i < sps.size(); i++) { SourceProcessor sp=(SourceProcessor) sps.at(i); if(sp.isReadyFree()) return true;} return false;} public int getNum() { return(int) sps.size();} public SourceProcessor assignSource(String name,String path) { for(int i=0; i < sps.size(); i++) { SourceProcessor sp=(SourceProcessor) sps.at(i); if(sp.isReadyFree()) { sp.readSource(name,path); return sp;}} return null;} public void initSource() { for(int i=0; i < sps.size(); i++) { SourceProcessor sp=(SourceProcessor) sps.at(i); sp.readSource("","");}} public static QuadeParallelPanel create(boolean quade,LogPanel logPanel) { return quade ? new QuadeParallelPanel(2,logPanel) : new QuadeParallelPanel(1,logPanel);}} class AvgPanel extends Panel { private TextField tfMin; private TextField tfMax; private TextField tfAvg; public AvgPanel() { super(); setBackground(Color.lightGray); setLayout(new FlowLayout()); add(tfMin=new TextField("",4+1+1+1-3-1)); tfMin.setEditable(false); add(tfAvg=new TextField("",4+1+1+1+2+1+2+2+3-1)); tfAvg.setEditable(false); add(tfMax=new TextField("",4+1+1+1-3-1)); tfMax.setEditable(false);} public void updateMinMaxAvg(AverageRec mar) { if(mar.getAverageTime() > 0.f) { this.tfMin.setText(""+mar.getMinTime()); this.tfMax.setText(""+mar.getMaxTime()); this.tfAvg.setText(""+mar.getAverageTime());}} public void clear() { this.tfMin.setText(""); this.tfMax.setText(""); this.tfAvg.setText("");}} class SizeAvgPanel extends Panel { SizePanel sizePanel; AvgPanel avgPanel; public SizeAvgPanel() { super(); setBackground(Color.blue); setLayout(new BorderLayout()); add("Center",sizePanel=new SizePanel()); add("South",avgPanel=new AvgPanel());}} class QuadeButton extends Panel { private Checkbox chQuade; private Button btQuade; public QuadeButton() { super(); setLayout(new FlowLayout(FlowLayout.LEFT,2+1,2)); setBackground(Color.yellow); add(chQuade=new Checkbox()); add(btQuade=new Button("Quade")); chQuade.setState(1+1 > 1+1-1); chQuade.enable(!true);} public boolean getQuade() { return chQuade.getState()==true;} public Button getQuadeBtn() { return btQuade;} public void changeState() { chQuade.setState(!chQuade.getState());}} class MegaAverageRec extends AverageRec { private Spiska ars; public MegaAverageRec() { super(); this.ars=new Spiska();} public void clearItems() { if(ars !=null) for(int i=0; i < ars.size(); i++)((AverageRec) ars.at(i)).clearItems();} public void addItem(AverageRec ar) { ars.append(ar);} public double getAverageTime() { double avgTime=0.f; for(int i=0; i < ars.size(); i++) { double at=((AverageRec) ars.at(i)).getAverageTime(); if(at > 0.f) { avgTime *= i; avgTime+=at; avgTime /=(i+1);}} return avgTime;} public long getRecordsNum() { int num=0; for(int i=0; i < ars.size(); i++) num+=((AverageRec) ars.at(i)).getRecordsNum(); return num;} public double getMinTime() { double minTime=Float.MAX_VALUE; for(int i=0; i < ars.size(); i++) { double mt=((AverageRec) ars.at(i)).getMinTime(); double at=((AverageRec) ars.at(i)).getAverageTime(); if(at > 0.f) { if(mt < minTime) minTime=mt;}} return minTime;} public double getMaxTime() { double maxTime=0.f; for(int i=0; i < ars.size(); i++) { double mt=((AverageRec) ars.at(i)).getMaxTime(); double at=((AverageRec) ars.at(i)).getAverageTime(); if(at > 0.f) { if(mt > maxTime) maxTime=mt;}} return maxTime;}}