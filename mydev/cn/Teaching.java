package mydev.cn; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Checkbox; import java.awt.Choice; import java.awt.Color; import java.awt.Dimension; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Font; import java.awt.FontMetrics; import java.awt.Frame; import java.awt.Graphics; import java.awt.Image; import java.awt.Label; import java.awt.List; import java.awt.Panel; import java.awt.Point; import java.awt.TextField; import java.awt.Toolkit; import java.awt.image.DirectColorModel; import java.awt.image.ImageObserver; import java.awt.image.MemoryImageSource; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.util.Date; import mydev.aaa.Enter; import mydev.aaa.Kadr; import mydev.aaa.Longy; import mydev.aaa.Okno; import mydev.aaa.Shift; import mydev.aaa.Shorty; import mydev.aaa.Sleeper; import mydev.aaa.Slip; import mydev.aaa.Slipstream; import mydev.aaa.Stop; import mydev.bbb.BOkno; import mydev.bbb.Enter2; import mydev.bbb.InternalPlane; import mydev.bbb.Location; import mydev.uix.CommonPathPanel; import mydev.uix.ControlsPanel; import mydev.uix.ToogleMultyButton; import mydev.vutils.Data; import mydev.vutils.Ester; import mydev.vutils.Files; import mydev.vutils.Filter; import mydev.vutils.Karta; import mydev.vutils.SharedGreatesArray; import mydev.vutils.Spiska; public class Teaching extends Frame implements Runnable { final static boolean D=false; PanelClPath pathPanel; CenterPunk centerPunk; PanelDays daysPanel; Longy lg; Shorty rt; int curIdx; ImagesPackSet ipSet=new ImagesPackSet(); public Teaching() { super(); setLayout(new BorderLayout()); setBackground(Color.darkGray); add("North",pathPanel=new PanelClPath()); add("West",daysPanel=new PanelDays()); add("Center",centerPunk=new CenterPunk()); this.rt=Enter.instance().shorty(); this.lg=Enter.instance().longy();} public static void main(String[] args) throws OknoManagerException { Teaching main=new Teaching(); main.setTitle("Leaves Days Professional"); main.show(); main.start(); main.pack(); main.reMoveRnd(); main.resize(1024,768); Sleeper sleeper=new Sleeper(); while(WorkingVisualHolder.working) { main.refreshUpdatable(); sleeper.sleep(123);} main.hide(); main.dispose(); System.exit(1-1);} protected void reMoveRnd() { long x1=new Date().getTime(); if(x1 < 0) x1 *=-1; x1=10+3 *(x1 % 100); long y1=new Date().getTime(); if(y1 < 0) y1 *=-1; y1=10+2 *(y1 % 100); move((int) x1,(int) y1);} private void refreshUpdatable() { centerPunk.refreshUpdatable();} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) { OknoManagerAbstract.destroyAllWindows(); WorkingVisualHolder.working=false;} Object tg=et.target; if(tg==centerPunk.getSettingPanel().getAutoPanel().getBtNext() && et.id==Event.ACTION_EVENT) itemNext(); if(tg==centerPunk.getSettingPanel().getAutoPanel().getBtPrev() && et.id==Event.ACTION_EVENT) itemPrevious(); if(tg==centerPunk.getSettingPanel().getAutoPanel().getBtAuto() && et.id==Event.ACTION_EVENT) auto(); if(tg==centerPunk.getSettingPanel().getAutoPanel().getChRev() && et.id==Event.ACTION_EVENT) autoRev(); if(tg==centerPunk.getSettingPanel().getBtDef() && et.id==Event.ACTION_EVENT) reset(); if(tg==centerPunk.getSettingPanel().getBtRepo() && et.id==Event.ACTION_EVENT) repositionWindows(); if(et.id==Event.ACTION_EVENT && tg==centerPunk.getSettingPanel().getChExt()) processFormatSelection(); if(et.key==Event.F1 && et.id==Event.KEY_ACTION) repositionWindows(); if(et.key==Event.F2 && et.id==Event.KEY_ACTION) auto(); if(tg !=null && tg.equals(centerPunk.getSettingPanel().getTfWidth()) && et.id==Event.LOST_FOCUS) widthChange(centerPunk.getSettingPanel()); if(tg !=null && tg.equals(centerPunk.getSettingPanel().getTfHeight()) && et.id==Event.LOST_FOCUS) heightChange(centerPunk.getSettingPanel()); if(tg !=null && tg.equals(centerPunk.getSettingPanel().getAutoPanel().getTfAuto()) && et.id==Event.LOST_FOCUS) autoReplace(); if(false && tg !=null && tg.equals(pathPanel.getTfPath()) && et.id==Event.LOST_FOCUS) try { start();} catch(OknoManagerException e1) { e1.printStackTrace();} if(tg !=null && tg.equals(daysPanel.getExt3dPanel().getChD3()) && et.id==Event.ACTION_EVENT) { if(daysPanel.getExt3dPanel().get3d()) { daysPanel.getExt3dPanel().getCbExt().setState(false); daysPanel.getExt3dPanel().getCbExt().enable(false); reload();} else { daysPanel.getExt3dPanel().getCbExt().enable(true);}} if(tg !=null && tg.equals(daysPanel.getExt3dPanel().getCbExt()) && et.id==Event.ACTION_EVENT) reload(); if(tg==pathPanel.getBtReload() && et.id==Event.ACTION_EVENT) try { start();} catch(OknoManagerException e) { e.printStackTrace();} return super.handleEvent(et);} private void processFormatSelection() { try { start();} catch(OknoManagerException e) { e.printStackTrace();}} private void heightChange(PanelSettings settingPanel) { commonWidthHeightChanges(); boolean ae=settingPanel.getAutoPanel().isAutoEnable(); settingPanel.getAutoPanel().setAutoEnable(false); auto(); if(!ae) { auto(); itemNext();}} private void widthChange(PanelSettings settingPanel) { commonWidthHeightChanges(); boolean ae=settingPanel.getAutoPanel().isAutoEnable(); settingPanel.getAutoPanel().setAutoEnable(false); auto(); if(!ae) { auto(); itemNext();}} private void itemPrevious() { if(centerPunk.getSettingPanel().getAutoPanel().isAutoEnable()) auto(); OknoManagerAbstract.previousAllWindows();} private void itemNext() { if(centerPunk.getSettingPanel().getAutoPanel().isAutoEnable()) auto(); OknoManagerAbstract.nextAllWindows();} private void commonWidthHeightChanges() { PanelSettings settingPanel=centerPunk.getSettingPanel(); short commonWidth=(short) Integer.parseInt(settingPanel.getWidthTxt()); short commonHeight=(short) Integer.parseInt(settingPanel.getHeightTxt()); OknoManagerAbstract.updateCommonWidthHeightAllWindows(commonWidth,commonHeight); reload();} private void repositionWindows() { try { reposition(daysPanel.getExt3dPanel().getCbExt().getState()); reload();} catch(OknoManagerException e) { e.printStackTrace();}} private void reposition(boolean ext) throws OknoManagerException { if(ext) repositionExternal(); else repositionInternal();} private void repositionInternal() throws OknoManagerException { Location ol=Enter2.instance().location(); PanelSettings settingPanel=centerPunk.getSettingPanel(); short w=Props.getCommonWidth(settingPanel); short h=Props.getCommonHeight(settingPanel); OknoManagerAbstract oknoManager=OknoManagerAbstract.obtain(KinDi3.INT,centerPunk.getFieldCv()); int num=oknoManager.getWindowsNum(); for(int i=0; i < num; i++) { Point p=ol.getRandomInternalPos(w,h); oknoManager.getWindow(i).move((short) p.x,(short) p.y);}} private void repositionExternal() throws OknoManagerException { Location ol=Enter2.instance().location(); PanelSettings settingPanel=centerPunk.getSettingPanel(); short w=Props.getCommonWidth(settingPanel); short h=Props.getCommonHeight(settingPanel); OknoManagerAbstract oknoManager=OknoManagerAbstract.obtain(KinDi3.EXT,null); int num=oknoManager.getWindowsNum(); for(int i=0; i < num; i++) { Point p=ol.getRandomExternalPos(w,h); oknoManager.getWindow(i).move((short) p.x,(short) p.y);}} private void autoReplace() { short autoDelay=(short) centerPunk.getSettingPanel().getAutoPanel().getAutoDelay(); if(Teaching.D) System.out.println(" delay changes "+autoDelay); OknoManagerAbstract.updateDelayAllWindows(autoDelay);} private void procNext() {} private void reset() { System.out.println(" reset settings "); PanelSettings settingPanel=centerPunk.getSettingPanel(); settingPanel.chooseExt(0+1+1); settingPanel.setWidth(""+Props.DEF_W); settingPanel.setHeight(""+Props.DEF_H); settingPanel.setAutoText(Props.AUTO_DELAY); ipSet.refresh(pathPanel.getPath(),settingPanel.getExtSelected()); commonWidthHeightChanges(); autoReplace(); settingPanel.getAutoPanel().setAutoEnable(false); auto();} private void reload() { try { extInternal(daysPanel.getExt3dPanel().getCbExt().getState());} catch(OknoManagerException e) { e.printStackTrace();} centerPunk.getSettingPanel().getAutoPanel().setAutoEnable(false); auto();} public void run() { Sleeper sleeper=new Sleeper(); PanelSettings settingPanel=centerPunk.getSettingPanel(); ReverseMassAuto autoPanel=settingPanel.getAutoPanel(); if(Teaching.D) System.out.println(" j start "+autoPanel.isAutoEnable()); while(autoPanel.isAutoEnable()) { if(Teaching.D) System.out.println("1"); procNext(); if(Teaching.D) System.out.println("2"); int au=autoPanel.getAutoDelay(); sleeper.sleep(au);} System.out.println(" j startExit "+autoPanel.isAutoEnable());} private void autoRev() { PanelSettings settingPanel=centerPunk.getSettingPanel(); ReverseMassAuto autoPanel=settingPanel.getAutoPanel(); OknoManagerAbstract.auto(autoPanel.isAutoEnable(),autoPanel.isReverse());} private void auto() { PanelSettings settingPanel=centerPunk.getSettingPanel(); ReverseMassAuto autoPanel=settingPanel.getAutoPanel(); System.out.println(" start "+autoPanel.isAutoEnable()); if(autoPanel.isAutoEnable()==false) { autoPanel.setAutoEnable(true); new Thread(this).start();} else autoPanel.setAutoEnable(false); OknoManagerAbstract.auto(autoPanel.isAutoEnable(),autoPanel.isReverse());} private void extInternal(boolean ext) throws OknoManagerException { if(ext) reloadExternal(); else reloadInternal();} private void reloadInternal() throws OknoManagerException { Location ol=Enter2.instance().location(); hideAllWindows(); PanelSettings settingPanel=centerPunk.getSettingPanel(); short w=Props.getCommonWidth(settingPanel); short h=Props.getCommonHeight(settingPanel); int delay=settingPanel.getAutoPanel().getAutoDelay(); for(int i=0; i < ipSet.getSize(); i++) { ImagesPack ip=ipSet.getIp(i); Point p=ol.getRandomInternalPos(w,h); OknosCtx ctx=new OknosCtx(); ctx.setAttr("ip",ip); OknoManagerAbstract.obtain(KinDi3.INT,centerPunk.getFieldCv()).createWindow((short) p.x,(short) p.y,w,h,(short) delay,ctx);} centerPunk.getFieldCv().setRedraw(true,true);} private void reloadExternal() throws OknoManagerException { Location ol=Enter2.instance().location(); centerPunk.getFieldCv().setRedraw(false,false); hideAllWindows(); centerPunk.getFieldCv().markRepaint(); short w=Props.getCommonWidth(centerPunk.getSettingPanel()); short h=Props.getCommonHeight(centerPunk.getSettingPanel()); int delay=centerPunk.getSettingPanel().getAutoPanel().getAutoDelay(); for(int i=0; i < ipSet.getSize(); i++) { ImagesPack ip=ipSet.getIp(i); Point p=ol.getRandomExternalPos(w,h); OknosCtx ctx=new OknosCtx(); ctx.setAttr("ip",ip); OknoManagerAbstract.obtain(KinDi3.EXT,null).createWindow((short) p.x,(short) p.y,w,h,(short) delay,ctx);}} private void hideAllWindows() { OknoManagerAbstract.destroyAllWindows();} public void start() throws OknoManagerException { String path=pathPanel.getPath(); ipSet.reloadDays(path); daysPanel.clearDays(); for(int i=0; i < ipSet.getSize(); i++) daysPanel.addLeavesDay(ipSet.getIp(i).getName()); if(daysPanel.hasDays()) daysPanel.selectNoDay(); reload(); PanelSettings settingPanel=centerPunk.getSettingPanel(); ReverseMassAuto autoPanel=settingPanel.getAutoPanel(); OknoManagerAbstract.auto(autoPanel.isAutoEnable(),autoPanel.isReverse()); ipSet.refresh(pathPanel.getPath(),settingPanel.getExtSelected());}} class PanelClPath extends CommonPathPanel { final static String BT_RELOAD="btReload"; public PanelClPath() { super(false,false);} protected ToogleMultyButton obtainMultyButton() { return null;} protected Label obtainLbPath() { return new Label("Pictures Path:");} protected TextField obtainTfPath() { TextField tfPath=new TextField("",50+30+20+30+20-55-15); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days"); return tfPath;} protected void buildPanel() { buildPath(); Button btReload=new Button("Reload"); append(BT_RELOAD,btReload);} public Color getPanelBgColor() { return Props.bgTopColor;} public Button getBtReload() { return(Button) getCtrl(BT_RELOAD);}} class PanelDays extends Panel { Label lbDays; DaysPanel daysPanel; CtrlsPanel ctrlsPanel; public PanelDays() { super(); setLayout(new BorderLayout()); setBackground(Color.gray); add("North",lbDays=new Label("Days")); add("Center",daysPanel=new DaysPanel()); add("South",ctrlsPanel=new CtrlsPanel());} public External3DPanel getExt3dPanel() { return ctrlsPanel.getExt3dPanel();} public void selectNoDay() { List lsDays=daysPanel.getLsDays(); lsDays.select(-1);} public boolean hasDays() { List lsDays=daysPanel.getLsDays(); return lsDays.countItems() > 0;} public void clearDays() { daysPanel.clearLsDays(); daysPanel.getStatPanel().daysIncrErase();} public void addLeavesDay(String item) { daysPanel.addLsDaysItem(item); daysPanel.getStatPanel().daysIncr();}} class DaysPanel extends Panel { List lsDays; StatPanel statPanel; public DaysPanel() { super(); setLayout(new BorderLayout()); add("Center",lsDays=new List(22,false)); add("South",statPanel=new StatPanel());} public StatPanel getStatPanel() { return statPanel;} public void addLsDaysItem(String item) { lsDays.addItem(item);} public void clearLsDays() { lsDays.clear();} public List getLsDays() { return lsDays;}} class StatPanel extends Panel { TextField tfDays; int count; public StatPanel() { super(); setLayout(new BorderLayout()); setBackground(Color.gray); add("West",new Label("Amount")); add("Center",tfDays=new TextField(4)); tfDays.setEditable(false);} public void daysIncr() { count+=1; tfDays.setText(""+count);} public void daysIncrErase() { count-=count; tfDays.setText(""+count);}} class CenterPunk extends Panel { FieldCv fieldCv; PanelSettings settingPanel; public CenterPunk() { super(); setLayout(new FlowLayout()); setBackground(Color.blue); setLayout(new BorderLayout()); settingPanel=new PanelSettings(); add("Center",fieldCv=new FieldCv(settingPanel)); add("South",settingPanel);} public FieldCv getFieldCv() { return fieldCv;} public void refreshUpdatable() { if(fieldCv.checkRepaint()) fieldCv.performRepaint();} public PanelSettings getSettingPanel() { return settingPanel;}} class FieldCv extends InternalPlane { private Date dLast; private boolean redraw; private boolean internalWindows; PanelSettings settingPanel; boolean loaded=false; public FieldCv(PanelSettings settingPanel) { super(Color.lightGray); this.settingPanel=settingPanel; dLast=new Date(); setBackground(Color.white); resize(400,300);} public void setRedraw(boolean redraw,boolean internalWindows) { this.redraw=redraw; this.internalWindows=internalWindows;} public void refresh() { if(1+1 < 1) { Date dCur=new Date(); if(dCur.getTime()-dLast.getTime() > 997) { invalidate(); repaint();}} else { invalidate(); repaint();}} public static Image loadImage(String path) { return Toolkit.getDefaultToolkit().getImage(path);} public void paint(Graphics ics) { super.paint(ics); Dimension d1=size(); Location.regInternalSize(d1.width,d1.height); drawBorder(ics,d1); drawSampleContent(ics,d1); try { if(internalWindows) drawInternalWindows(this); else drawExternalWindows(ics);} catch(OknoManagerException e) { e.printStackTrace();} dLast=new Date();} private void drawExternalWindows(Graphics ics) throws OknoManagerException { OknoManagerExternal ome=(OknoManagerExternal) OknoManagerAbstract.obtain(KinDi3.EXT,null); Shorty or=Enter.instance().shorty(); OknoFrame frame=new OknoFrame(); OknoViewEmptyKadr kadr=new OknoViewEmptyKadr(); short maxWidth=10; short maxHeight=10; for(int i=0; i < ome.getWindowsNum(); i++) { Okno okno=ome.getWindow(i); frame.recall(okno.memo()); if(maxWidth < frame.w) maxWidth=frame.w; if(maxHeight < frame.h) maxHeight=frame.h; kadr.updatePos(frame.x,frame.y); kadr.make(ics,frame.w,frame.h);} if(!loaded && new Ester(settingPanel.getWidthTxt()).nteq(new Ester(""+maxWidth))) { loaded=true; settingPanel.setWidth(""+maxWidth); settingPanel.setHeight(""+maxHeight);} else if(!loaded && new Ester(settingPanel.getHeightTxt()).nteq(new Ester(""+maxHeight))) { loaded=true; settingPanel.setWidth(""+maxWidth); settingPanel.setHeight(""+maxHeight);}} private void drawInternalWindows(InternalPlane panel) throws OknoManagerException { OknoManagerInternal omi=(OknoManagerInternal) OknoManagerAbstract.obtain(KinDi3.INT,panel); Shorty or=Enter.instance().shorty(); OknoFrame frame=new OknoFrame(); short maxWidth=10; short maxHeight=10; for(int i=0; i < omi.getWindowsNum(); i++) { BOkno okno=(BOkno) omi.getWindow(i); OknoIntViewKadr kadr=(OknoIntViewKadr) omi.getWindowKadr(i); frame.recall(okno.memo()); if(maxWidth < frame.w) maxWidth=frame.w; if(maxHeight < frame.h) maxHeight=frame.h; if(Teaching.D) okno.dump(); kadr.updatePos(frame.x,frame.y); kadr.make(ics,or.rev(frame.w,0),or.rev(frame.h,0));} if(!loaded && new Ester(settingPanel.getWidthTxt()).nteq(new Ester(""+maxWidth))) { loaded=true; settingPanel.setWidth(""+maxWidth); settingPanel.setHeight(""+maxHeight);} else if(!loaded && new Ester(settingPanel.getHeightTxt()).nteq(new Ester(""+maxHeight))) { loaded=true; settingPanel.setWidth(""+maxWidth); settingPanel.setHeight(""+maxHeight);}} private void drawSampleContent(Graphics ics,Dimension d1) { ics.drawLine(0,0,d1.width-1,d1.height-1); ics.drawLine(d1.width-1,0,0,d1.height-1); Date d2=new Date(); ics.setColor(Color.black); ics.drawString(""+d2.getTime() % 123456,250,250);} private void drawBorder(Graphics ics,Dimension d1) { ics.setColor(Color.blue); ics.drawLine(0,0,d1.width-1,0); ics.drawLine(d1.width-1,0,d1.width-1,d1.height-1); ics.drawLine(d1.width-1,d1.height-1,0,d1.height-1); ics.drawLine(0,d1.height-1,0,0);}} class PanelSettings extends ControlsPanel { final static String CH_EXT="chExt"; final static String BT_DEF="btDef"; final static String BT_REPO="btRepo"; final static String AUTO_PANEL="autoPanel"; final static String TF_HEIGHT="tfHeight"; final static String TF_WIDTH="tfWidth"; final static String LB_WIDTH="lbWidth"; final static String LB_HEIGHT="lbHeight"; public PanelSettings() { super(); enableCtrls(true);} public void setAutoText(String autoDelay) {((ReverseMassAuto) getCtrl(AUTO_PANEL)).getTfAuto().setText(autoDelay);} public Button getBtDef() { return(Button) getCtrl(BT_DEF);} public Button getBtRepo() { return(Button) getCtrl(BT_REPO);} public Choice getChExt() { return(Choice) getCtrl(CH_EXT);} public void chooseExt(int pos) {((Choice) getCtrl(CH_EXT)).select(pos);} public String getExtSelected() { return((Choice) getCtrl(CH_EXT)).getSelectedItem();} public void setHeight(String height) {((TextField) getCtrl(TF_HEIGHT)).setText(height);} public void setWidth(String width) {((TextField) getCtrl(TF_WIDTH)).setText(width);} public TextField getTfHeight() { return(TextField) getCtrl(TF_HEIGHT);} public TextField getTfWidth() { return(TextField) getCtrl(TF_WIDTH);} public String getWidthTxt() { return((TextField) getCtrl(TF_WIDTH)).getText();} public String getHeightTxt() { return((TextField) getCtrl(TF_HEIGHT)).getText();} public ReverseMassAuto getAutoPanel() { return(ReverseMassAuto) getCtrl(AUTO_PANEL);} protected void buildPanel() { Choice chExt=new Choice(); chExt.addItem(WorkingVisualHolder.BC_EXTDEF); chExt.addItem("*"+WorkingVisualHolder.BC_EXT1); chExt.addItem("*"+WorkingVisualHolder.BC_EXT2); chExt.addItem("*"+WorkingVisualHolder.BC_EXT3); chExt.select(0+1+1-1+1); append(CH_EXT,chExt); append(LB_WIDTH,new Label("Width:")); append(TF_WIDTH,new TextField(""+Props.DEF_W)); append(LB_HEIGHT,new Label("Height:")); append(TF_HEIGHT,new TextField(""+Props.DEF_H)); append(AUTO_PANEL,ReverseMassAuto.createPanel(Props.AUTO_DELAY,true)); append(BT_DEF,new Button("Default")); append(BT_REPO,new Button("Reposition"));} public void enableCtrls(boolean enable) {((Choice) getCtrl(CH_EXT)).enable(enable);((TextField) getCtrl(TF_WIDTH)).enable(enable);((TextField) getCtrl(TF_HEIGHT)).enable(enable);((ReverseMassAuto) getCtrl(AUTO_PANEL)).enableCtrls(enable);((Button) getCtrl(BT_DEF)).enable(enable);((Button) getCtrl(BT_REPO)).enable(enable);} public Color getPanelBgColor() { return Props.bgDownColor;} public FlowLayout getPanelLayout() { return new FlowLayout(FlowLayout.CENTER);}} class CtrlsPanel extends Panel { External3DPanel ext3dPanel; Button btStopAll; StartStopPanel startStopPanel; public CtrlsPanel() { super(); setLayout(new BorderLayout()); setBackground(Color.lightGray); add("North",ext3dPanel=new External3DPanel()); add("Center",startStopPanel=new StartStopPanel()); add("South",btStopAll=new Button("All Stop"));} public External3DPanel getExt3dPanel() { return ext3dPanel;}} class External3DPanel extends Panel { Checkbox cbExt; Checkbox chD3; public External3DPanel() { super(); setLayout(new FlowLayout()); add(cbExt=new Checkbox("external")); cbExt.setState(true); add(chD3=new Checkbox("3D")); chD3.setState(!true);} public boolean get3d() { return chD3.getState();} public Checkbox getChD3() { return chD3;} public Checkbox getCbExt() { return cbExt;}} class StartStopPanel extends Panel { Button btStart; Button btStop; Button btStartAll; public StartStopPanel() { super(); setLayout(new BorderLayout()); setBackground(Color.blue); add("North",btStart=new Button("Start")); add("Center",btStop=new Button("Stop")); add("South",btStartAll=new Button("All Start"));} public Button getBtStart() { return btStart;} public Button getBtStop() { return btStop;} public Button getBtStartAll() { return btStartAll;}} class ImagesPackController { boolean autoEnable; boolean previousWindows; boolean nextWindows; private ImagesPackController() { super();} public void clear() { nextWindows=false; previousWindows=false;} public static ImagesPackController createController() { return new ImagesPackController();}} class ImagesPack implements Runnable { String name; int curIdx; Spiska allViews; Spiska allFiles; Spiska allImages; String pathToImages; String imagesExt; Image photo; Karta readyImages=new Karta(); static ImagesPackController ctrlIPs=ImagesPackController.createController(); public ImagesPack(String name) { super(); this.name=name; this.curIdx=-1; imagesExt="*.jpg"; this.allViews=new Spiska(); this.allFiles=new Spiska(); this.allImages=new Spiska(); System.out.println(" IP "+name);} public String previousImage() { if(allViews.size() < 1) return ""; curIdx-=1; if(curIdx < 0) curIdx=(int)(allViews.size()-1); return(String) allFiles.at(curIdx);} public String nextImage() { if(allViews.size() < 1) return ""; curIdx+=1; if(curIdx > allViews.size()-1) curIdx=0; return(String) allFiles.at(curIdx);} public String getCurName() { return(String) allFiles.at(curIdx);} public String getCurPath() { return(String) allViews.at(curIdx);} public Image getCurImage() throws VisualImageFileException { String curPath=getCurPath(); if(curPath !=null && curPath.endsWith(".jpg")) return reloadOrigImage(curPath); return reloadBackupImage(curPath);} protected Image reloadOrigImage(String picturePath) { photo=FieldCv.loadImage(picturePath); return photo;} protected Image reloadBackupImage(String picturePath) { VisualImageFile file=null; try { if(1+1 <= 1) { if(readyImages.containsKey(picturePath)) file=(VisualImageFile) readyImages.get(picturePath); else { file=VisualImageFile.loadImage(picturePath); readyImages.put(picturePath,file);}} else file=VisualImageFile.loadImage(picturePath);} catch(VisualImageFileException e) { e.printStackTrace();} if(file !=null) { int bits=32; int redMask=16711680; int greenMask=65280; int blueMask=255; DirectColorModel cm=new DirectColorModel(bits,redMask,greenMask,blueMask); int width=file.getWidth(); int height=file.getHeight(); int[] pix=file.getData(); photo=Toolkit.getDefaultToolkit().createImage(new MemoryImageSource(width,height,cm,pix,0,width));} return photo;} public String getName() { return name;} public void refresh(String path,String ext) { System.out.println(" ref "+path+" "+name+" "+ext); this.pathToImages=path; this.imagesExt=ext; new Thread(this).start();} public void run() { refreshProc(pathToImages);} protected void refreshProc(String path) { allViews=new Spiska(); allFiles=new Spiska(); allImages=new Spiska(); String curPath=path+File.separator+name; String curExt=imagesExt; int iExt=curExt.lastIndexOf('*'); if(iExt >-1) curExt=curExt.substring(iExt+1); Ester[] items=new Filter().endsWithIncensitive(new Files().tree(new Ester(curPath)),new Ester(curExt)); for(int i=0; i < items.length; i++) { allViews.append(items[i].toString()); allFiles.append(new File(items[i].toString()).getName());} System.out.println(" "+name+" "+allViews.size()+" "+allFiles.size());}} class Props { final static String AUTO_DELAY="25"; final static Color bgTopColor=Color.green; final static Color bgDownColor=Color.gray; final static Color wndBg=Color.white; final static Color wndBorder=Color.blue; final static short DEF_W=(short)(230+40+5-30-45+40-40+1); final static short DEF_H=151; final static Color caption=Color.black; static Color objRibs=RGB(111,186,248); static Color objRibsNormal=Color.lightGray; static Color RGB(int r,int g,int b) { return new Color(b,g,r);} public static short getCommonHeight(PanelSettings ps) { return(short) Integer.parseInt(ps.getHeightTxt());} public static short getCommonWidth(PanelSettings ps) { return(short) Integer.parseInt(ps.getWidthTxt());}} class ClOknoView implements ImageObserver { private short myy; protected short w; protected short h; protected short x,y; protected String name; protected boolean active; protected String imgName; protected Image img1; public ClOknoView(short x,short y,short w,short h,String name,boolean active,String imgName,Image img1) { super(); this.x=x; this.y=y; this.w=w; this.h=h; this.name=name; this.active=active; this.imgName=imgName; this.img1=img1;} public void drawFrame(Graphics ics) { short fs=(short)(12-1-1-1-1+1+1); ics.setFont(new Font("SansSerif",Font.BOLD,fs)); FontMetrics fm=ics.getFontMetrics(); short sw=(short) fm.stringWidth(name); short sh=(short) fm.getHeight(); short delta=(short)((sh-fs) / 2); ics.setColor(active ? Props.objRibs : Props.objRibsNormal); ics.fillRect(x,y,w-1,sh+5); ics.setColor(Props.wndBorder); ics.drawRect(x,y,w-1,sh+5); myy=(short)(sh+5); ics.setColor(Props.caption); ics.drawString(name+" - "+imgName,x+5,y+sh); ics.setColor(Props.wndBorder); ics.drawRect(x,y+myy,w-1-1+1,h-myy-1-1+1); if(img1 !=null) ics.drawImage(img1,x+1,y+myy+1,w-1-1+1-1,h-myy-1-1+1-1,this); else { ics.setColor(Color.gray); ics.fillRect(x+1,y+myy+1,w-1-1+1-1,h-myy-1-1+1-1);}} public boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height) { if(Teaching.D) System.out.println(" "+infoflags+" "+x+" "+y+" "+width+" "+height); if(infoflags==ImageObserver.ALLBITS) { return false;} return true;}} abstract class OknoManagerAbstract implements Stop,OknosCtrl,OknosManager { protected boolean autoEnable=true; protected boolean autoRev=true; protected OknoManagerAbstract() { super();} public static void nextAllWindows() { new OknoManagerInternal(null).nextWindows(); new OknoManagerExternal().nextWindows();} public static void previousAllWindows() { new OknoManagerInternal(null).previousWindows(); new OknoManagerExternal().previousWindows();} public static void updateCommonWidthHeightAllWindows(short commonWidth,short commonHeight) { new OknoManagerInternal(null).commonWidthHeight(commonWidth,commonHeight); new OknoManagerExternal().commonWidthHeight(commonWidth,commonHeight);} public static void auto(boolean autoEnable,boolean rev) { new OknoManagerInternal(null).autoEnable(autoEnable,rev); new OknoManagerExternal().autoEnable(autoEnable,rev);} public static void destroyAllWindows() { new OknoManagerInternal(null).ka(); new OknoManagerExternal().ka();} public static void updateDelayAllWindows(short refreshDelay) { new OknoManagerInternal(null).updateWindowsDelay(refreshDelay); new OknoManagerExternal().updateWindowsDelay(refreshDelay);} public static OknoManagerAbstract obtain(KinDi3 kind,InternalPlane panel) throws OknoManagerException { if(kind !=null) { if(kind.getId()==KinDi3.INT.getId()) { if(panel==null) throw new OknoManagerException("No graphics for internal windows"); return new OknoManagerInternal(panel);} if(kind.getId()==KinDi3.EXT.getId()) return new OknoManagerExternal();} return new OknoManagerExternal();} public void ka() { Slipstream ss=Enter.instance().slipstream(); for(int i=0; i < getWindowsNum(); i++) { Okno fn=getWindow(i); ss.push(fn.finish());} clearAllWindows();}} class OknoManagerInternal extends OknoManagerAbstract { private static Spiska internalWindows=new Spiska(); private InternalPlane oknosPlane; public OknoManagerInternal(InternalPlane panel) { super(); this.oknosPlane=panel;} public void autoEnable(boolean ae,OknosCtx ctx) { String REV=(String) ctx.getAttr("rev"); this.autoEnable=ae; this.autoRev=REV !=null && new Ester(REV).eq(new Ester("true")); for(int i=0; i < internalWindows.size(); i++) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(i); oknoIntWrap.getKadr().autoEnabled(ae,autoRev);}} public void previousWindows() { autoEnable(false,true); for(int i=0; i < internalWindows.size(); i++) { OknoIntWrap bOknoWrap=(OknoIntWrap) internalWindows.at(i); bOknoWrap.getKadr().imagePrevious();}} public void nextWindows() { autoEnable(false,true); for(int i=0; i < internalWindows.size(); i++) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(i); oknoIntWrap.getKadr().imageNext();}} public void commonWidthHeight(short commonWidth,short commonHeight) { for(int i=0; i < internalWindows.size(); i++) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(i); oknoIntWrap.getRef().size(commonWidth,commonHeight);}} public void autoEnable(boolean ae,boolean rev) { this.autoEnable=ae; this.autoRev=rev; for(int i=0; i < internalWindows.size(); i++) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(i); oknoIntWrap.getKadr().autoEnabled(ae,rev);}} public void updateWindowsDelay(short refreshDelay) { for(int i=0; i < internalWindows.size(); i++) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(i); oknoIntWrap.getRef().delay(refreshDelay);}} public void clearAllWindows() { internalWindows=new Spiska();} public int getWindowsNum() { return(int) internalWindows.size();} public Kadr getWindowKadr(int index) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(index); return oknoIntWrap.getKadr();} public Okno getWindow(int index) { OknoIntWrap oknoIntWrap=(OknoIntWrap) internalWindows.at(index); return oknoIntWrap.getRef();} public void createWindow(short x,short y,short w,short h,short delay,OknosCtx ctx) { ImagesPack ip=(ImagesPack) ctx.getAttr("ip"); OknoIntViewKadr kadr=new OknoIntViewKadr(ip); String name=ip.getName(); BOkno fn=(BOkno)((BOkno)((BOkno) Enter2.instance().okno(oknosPlane).size(w,h).move(x,y)).kadr(kadr)).delay(delay).show(this,name); internalWindows.append(new OknoIntWrap(fn,kadr));}} class OknoManagerExternal extends OknoManagerAbstract { private static Spiska windows=new Spiska(); public OknoManagerExternal() { super();} public void autoEnable(boolean ae,OknosCtx ctx) { String REV=(String) ctx.getAttr("rev"); this.autoRev=REV !=null && new Ester(REV).eq(new Ester("true")); this.autoEnable=ae; for(int i=0; i < windows.size(); i++) { OknoWrap oknoWrap=(OknoWrap) windows.at(i); oknoWrap.autoEnabled(ae,autoRev);}} public void previousWindows() { for(int i=0; i < windows.size(); i++) { OknoWrap oknoWrap=(OknoWrap) windows.at(i); oknoWrap.imagePrevious();}} public void nextWindows() { for(int i=0; i < windows.size(); i++) { OknoWrap oknoWrap=(OknoWrap) windows.at(i); oknoWrap.imageNext();}} public void commonWidthHeight(short commonWidth,short commonHeight) { for(int i=0; i < windows.size(); i++) { Okno okno=getWindow(i); okno.size(commonWidth,commonHeight);}} public void autoEnable(boolean ae,boolean rev) { this.autoEnable=ae; for(int i=0; i < windows.size(); i++) { OknoWrap oknoWrap=(OknoWrap) windows.at(i); oknoWrap.autoEnabled(ae,rev);}} public void updateWindowsDelay(short refreshDelay) { for(int i=0; i < windows.size(); i++) { OknoWrap oknoWrap=(OknoWrap) windows.at(i); oknoWrap.delay(refreshDelay);}} public int getWindowsNum() { return(int) windows.size();} public void clearAllWindows() { windows=new Spiska();} public Okno getWindow(int index) { OknoWrap oknoWrap=(OknoWrap) windows.at(index); return oknoWrap.getRef();} public Kadr getWindowKadr(int index) { OknoWrap oknoWrap=(OknoWrap) windows.at(index); return oknoWrap.getKadr();} public void createWindow(short x,short y,short w,short h,short delay,OknosCtx ctx) { ImagesPack ip=(ImagesPack) ctx.getAttr("ip"); if(Teaching.D) System.out.println(" w "+w+" h "+h); String id=ip.getName(); OknoIntViewKadr kadr=new OknoIntViewKadr(ip); Okno fn=Enter.instance().okno().size(w,h).move(x,y).kadr(kadr).delay(delay).show(this,id); OknoWrap oknoWrap=new OknoWrap(id,fn,kadr); windows.append(oknoWrap);}} interface OknosCtrl { void previousWindows(); void nextWindows(); void commonWidthHeight(short commonWidth,short commonHeight); void updateWindowsDelay(short refreshDelay); void autoEnable(boolean ae,boolean rev); void autoEnable(boolean ae,OknosCtx ctx);} class OknoIntViewKadr implements Kadr { public final static int dv=2-1; private String wndId; private ImagesPack ip; private int x; private int y; private Object active; private Image img1; private String imgName; private boolean ae2; private boolean rev; public OknoIntViewKadr(ImagesPack ip) { super(); this.ip=ip; this.wndId=ip.getName(); this.imgName="";} public void imageNext() { imgName=ip.nextImage(); if(Teaching.D) System.out.println("imageNext "+imgName); try { img1=ip.getCurImage();} catch(VisualImageFileException e) { e.printStackTrace();}} public void imagePrevious() { imgName=ip.previousImage(); if(Teaching.D) System.out.println("imagePrevious "+imgName); try { img1=ip.getCurImage();} catch(VisualImageFileException e) { e.printStackTrace();}} public void updatePos(int x,int y) { this.x=(short)(x / dv); this.y=(short)(y / dv); this.active=this; if(Teaching.D) System.out.println(" x"+x+" y"+y+" "+(active==this));} public void make(Graphics ics,short ww,short hh) { if(x > 0) { ww=(short)(ww / dv); hh=(short)(hh / dv);} if(Teaching.D) System.out.println("make "+ae2); if(ae2) { if(rev) imagePrevious(); else imageNext();} ClOknoView wv=new ClOknoView((short) x,(short) y,ww,hh,wndId,active==this,imgName,img1); wv.drawFrame(ics);} public void autoEnabled(boolean ae,boolean rev) { if(Teaching.D) System.out.println("autoEnabled "+ae+" "+rev); this.ae2=ae; this.rev=rev;}} class OknoIntWrap { BOkno ref; OknoIntViewKadr kadr; public OknoIntWrap(BOkno ref,OknoIntViewKadr kadr) { super(); this.ref=ref; this.kadr=kadr;} public BOkno getRef() { return ref;} public OknoIntViewKadr getKadr() { return kadr;}} class OknoWrap { String name; Okno ref; private OknoIntViewKadr kadr; short refreshDelay; public OknoWrap(String name,Okno ref,OknoIntViewKadr kadr) { super(); this.ref=ref; this.name=name; this.kadr=kadr;} public void imageNext() { kadr.imageNext();} public void imagePrevious() { kadr.imagePrevious();} public void delay(short refreshDelay) { this.refreshDelay=refreshDelay; ref.delay(refreshDelay);} public void autoEnabled(boolean ae,boolean rev) { kadr.autoEnabled(ae,rev); if(ae) ref.delay(refreshDelay); else ref.delay((short) 997);} public Okno getRef() { return ref;} public String getName() { return name;} public OknoIntViewKadr getKadr() { return kadr;}} class WorkingVisualHolder { static boolean working=true; final static String BC_EXTDEF="Default"; final static String BC_EXT1=".im1"; final static String BC_EXT2=".im2"; final static String BC_EXT3=".jpg";} class OknoManagerException extends Exception { public OknoManagerException(String msg) { super(msg);}} class VisualImageFile { protected static final int BUF_LIM=256; private String fullPath; private int width; private int height; private int pix[]; VisualImageFile(String fullPath) { super(); this.fullPath=fullPath;} public static VisualImageFile loadImage(String fullPath) throws VisualImageFileException { VisualImageFile result=null; if(fullPath !=null) { if(fullPath.endsWith(WorkingVisualHolder.BC_EXT1)) result=loadImage1(Data.replace(new Ester(fullPath),new Ester("*"+WorkingVisualHolder.BC_EXT1),new Ester(WorkingVisualHolder.BC_EXT1)).toString()); else if(fullPath.endsWith(WorkingVisualHolder.BC_EXT2)) result=loadImage2(Data.replace(new Ester(fullPath),new Ester("*"+WorkingVisualHolder.BC_EXT2),new Ester(WorkingVisualHolder.BC_EXT2)).toString()); else if(fullPath.endsWith(WorkingVisualHolder.BC_EXT3)) result=loadImage3(Data.replace(new Ester(fullPath),new Ester("*"+WorkingVisualHolder.BC_EXT3),new Ester(WorkingVisualHolder.BC_EXT3)).toString());} return result;} public int[] getData() { return pix;} public int getWidth() { return width;} public int getHeight() { return height;} private static VisualImageFile loadImage3(String replace) { return null;} public static VisualImageFile loadImage2(String fullPath) throws VisualImageFileException { try { VisualImageFile imageFile=new VisualImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); if(Teaching.D) System.out.print(" WH "+imageFile.width+"x"+imageFile.height); imageFile.pix=new int[imageFile.width * imageFile.height]; int paletArrLn=read4b(is); int[] paletArr=new int[paletArrLn]; readIntBuf(is,paletArr); if(Teaching.D) System.out.println(" palette size is "+paletArr.length); ParserWithPaletteVisualAdapter parser=new ParserWithPaletteVisualAdapter(imageFile.pix,paletArr); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new VisualImageFileException("Can't load. "+ex.getMessage());}} public static VisualImageFile loadImage1(String fullPath) throws VisualImageFileException { try { VisualImageFile imageFile=new VisualImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserVisualAdapter parser=new ParserVisualAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new VisualImageFileException("Can't load. "+ex.getMessage());}} private static void readIntBuf(FileInputStream is,int[] intBuf) throws IOException { SharedGreatesArray sga=SharedGreatesArray.createByteArray(0); int lim=intBuf.length * 4; while(lim > 0) { byte[] b1=new byte[lim]; int count=is.read(b1); if(count > 0) { sga.append(b1); lim-=count;}} byte[] buf=sga.getMemoryViewByte(); for(int i=0; i < intBuf.length; i++) { int s=0; int r1=buf[i * 4+1-1]; int r2=buf[i * 4+1]; int r3=buf[i * 4+2]; int r4=buf[i * 4+3]; s=((r4 * 255+r3) * 255+r2) * 255+r1; intBuf[i]=s;}} private static int read4b(InputStream is) throws IOException { int s=0; int r1=is.read(); int r2=is.read(); int r3=is.read(); int r4=is.read(); s=((r4 * 255+r3) * 255+r2) * 255+r1; return s;}} class VisualImageFileException extends Exception { public VisualImageFileException() { super();} public VisualImageFileException(String message) { super(message);}} class ParserWithPaletteVisualAdapter extends ParserVisualAdapter { int[] paletArr; public ParserWithPaletteVisualAdapter(int[] pix,int[] paletArr) { super(pix); this.paletArr=paletArr;} public void push(int b) { switch(n) { case 0 : r1=b; break; case 1 : r2=b; break; case 2 : r3=b; break; default : r4=b; break;} n++; if(n==4) { n=0; if(r1 < 0) r1+=256; if(r2 < 0) r2+=256; if(r3 < 0) r3+=256; if(r4 < 0) r4+=256; if(r4==0) { s=(r3 * 255+r2) * 255+r1; pix[idx++]=paletArr[s];} else { s=(r3 * 255+r2) * 255+r1; for(int i=0; i <= r4; i++) pix[idx++]=paletArr[s];}}}} class ParserVisualAdapter { int s; int r1; int r2; int r3; int r4; int n=0; int idx=0; int[] pix; public ParserVisualAdapter(int[] pix) { this.pix=pix;} public void push(byte[] buf,int count,int[] palette) { for(int j=0; j < count; j++) { push(buf[j]); if(n==0) { System.out.println(" "+idx+" "+pix[idx-1]);}}} public void push(int b) { switch(n) { case 0 : r1=b; break; case 1 : r2=b; break; case 2 : r3=b; break; default : r4=b; break;} n++; if(n==4) { n=0; if(r1 < 0) r1+=256; if(r2 < 0) r2+=256; if(r3 < 0) r3+=256; if(r4 < 0) r4+=256; if(r4==0) { pix[idx++]=new Color(r1,r2,r3).getRGB();} else { s=new Color(r1,r2,r3).getRGB(); for(int i=0; i <= r4; i++) pix[idx++]=s;}}} public void push(byte[] buf,int count) { for(int j=0; j < count; j++) push(buf[j]);}} class Cortege { Spiska relations; public Cortege() { super(); this.relations=new Spiska();} public void append(OknoRelation rel) { if(rel !=null) relations.append(rel);} public void append(Okno ref,Shift vr) { append(new OknoRelation(ref,vr));} public long getNum() { return relations.size();}} class ShiftType { private int id; public static ShiftType stCornerLeftUp=new ShiftType(1); public static ShiftType stCornerLeftDown=new ShiftType(1+1); public static ShiftType stCornerRightDown=new ShiftType(1+1+1); public static ShiftType stCornerRightUp=new ShiftType(1+1+1+1); public static ShiftType stSideRight=new ShiftType(1+1+1+1+1); public static ShiftType stSideTop=new ShiftType(1+1+1+1+1+1); public static ShiftType stSideLeft=new ShiftType(1+1+1+1+1+1+1); public static ShiftType stSideBottom=new ShiftType(1+1+1+1+1+1+1+1); public static ShiftType stHalfSideLeftDown=new ShiftType(1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideLeftUp=new ShiftType(1+1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideTopLeft=new ShiftType(1+1+1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideTopRight=new ShiftType(1+1+1+1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideRightUp=new ShiftType(1+1+1+1+1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideRightDown=new ShiftType(1+1+1+1+1+1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideBottomRight=new ShiftType(1+1+1+1+1+1+1+1+1+1+1+1+1+1+1); public static ShiftType stHalfSideBottomLeft=new ShiftType(1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1); public ShiftType(int id) { super(); this.id=id;} public int getId() { return id;}} class OknoRelation { Okno ref; Shift vr; public OknoRelation(Okno ref,Shift vr) { super(); this.ref=ref; this.vr=vr;} public static Shift obtainShift(ShiftType kind,Okno prev,Okno cur) { Shift result=null; if(kind !=null && prev !=null) { if(kind.getId()==ShiftType.stCornerLeftUp.getId()) { result=new Shift((short) 111,(short) 222);} if(kind.getId()==ShiftType.stCornerLeftDown.getId()) {} if(kind.getId()==ShiftType.stCornerRightDown.getId()) {} if(kind.getId()==ShiftType.stCornerRightUp.getId()) {} if(kind.getId()==ShiftType.stSideRight.getId()) {} if(kind.getId()==ShiftType.stSideTop.getId()) {} if(kind.getId()==ShiftType.stSideLeft.getId()) {} if(kind.getId()==ShiftType.stSideBottom.getId()) {}} return result;}} class ReverseMassAuto extends ControlsPanel { final static String BT_AUTO="btAuto"; final static String BT_NEXT="btNext"; final static String BT_PREV="btPrev"; final static String CH_REV="chRev"; final static String CH_AUTO="chAuto"; final static String TF_AUTO="tfAuto"; static String autoDelay; static boolean initialState; public ReverseMassAuto() { super();} public Button getBtAuto() { return(Button) getCtrl(BT_AUTO);} public Button getBtNext() { return(Button) getCtrl(BT_NEXT);} public Button getBtPrev() { return(Button) getCtrl(BT_PREV);} public Checkbox getChRev() { return(Checkbox) getCtrl(CH_REV);} public boolean isReverse() { return((Checkbox) getCtrl(CH_REV)).getState();} public void setAutoEnable(boolean enable) {((Checkbox) getCtrl(CH_AUTO)).setState(enable);} public boolean isAutoEnable() { return((Checkbox) getCtrl(CH_AUTO)).getState();} public TextField getTfAuto() { return(TextField) getCtrl(TF_AUTO);} public int getAutoDelay() { try { return Integer.parseInt(((TextField) getCtrl(TF_AUTO)).getText());} catch(NumberFormatException ex) { ex.getMessage();} return Integer.parseInt(autoDelay);} protected void buildPanel() { append(BT_NEXT,new Button("Next")); append(BT_PREV,new Button("Prev")); TextField tfAuto=new TextField(4); tfAuto.setText(""+autoDelay); append(TF_AUTO,tfAuto); Checkbox chAuto=new Checkbox(""); chAuto.setState(initialState); chAuto.enable(false); append(CH_AUTO,chAuto); append(BT_AUTO,new Button("Auto")); Checkbox chRev=new Checkbox("Reverse"); chRev.setState(true); append(CH_REV,chRev);} public void enableCtrls(boolean enable) {((Button) getCtrl(BT_NEXT)).enable(enable);((Button) getCtrl(BT_PREV)).enable(enable);((TextField) getCtrl(TF_AUTO)).enable(enable);((Checkbox) getCtrl(CH_AUTO)).enable(enable);((Button) getCtrl(BT_AUTO)).enable(enable);((Checkbox) getCtrl(CH_REV)).enable(enable);} public Color getPanelBgColor() { return Color.yellow;} public FlowLayout getPanelLayout() { return new FlowLayout(FlowLayout.LEFT,2+1,2);} public static ReverseMassAuto createPanel(String autoDelay,boolean initialState) { ReverseMassAuto.autoDelay=autoDelay; ReverseMassAuto.initialState=initialState; ReverseMassAuto rma=new ReverseMassAuto(); return rma;}} class ImagesPackSet { String path; Spiska packs=new Spiska(); public ImagesPackSet() { super();} public void reloadDays(String path) { packs=new Spiska(); File file=new File(path); if(file.isDirectory()) { String[] items=file.list(); for(int i=0; i < items.length; i++) { String item=items[i]; File file2=new File(file.getAbsolutePath()+"/"+item); if(file2.isDirectory()) { ImagesPack ip=new ImagesPack(item); addIp(ip);}}}} public void refresh(String imgPath,String imgExt) { if(imgExt.equalsIgnoreCase(WorkingVisualHolder.BC_EXTDEF)) imgExt="*"+WorkingVisualHolder.BC_EXT2; for(int i=0; i < packs.size(); i++) { ImagesPack ip=(ImagesPack) packs.at(i); ip.refresh(imgPath,imgExt);} System.out.println(" P "+imgPath+" E "+imgExt);} public void addIp(ImagesPack ip) { packs.append(ip);} public ImagesPack getIp(int pos) { return(ImagesPack) packs.at(pos);} public long getSize() { return packs.size();}} class OknoFrame { short w; short h; short x; short y; public boolean recall(Slip item) { String ati=new String(item.symbols()); int idx=ati.indexOf(","); if(idx < 0) return false; w=(short) Long.parseLong(ati.substring(0,idx)); ati=ati.substring(idx+1); idx=ati.indexOf(","); if(idx < 0) return false; h=(short) Long.parseLong(ati.substring(0,idx)); ati=ati.substring(idx+1); idx=ati.indexOf(","); if(idx < 0) return false; x=(short) Long.parseLong(ati.substring(0,idx)); ati=ati.substring(idx+1); y=(short) Long.parseLong(ati); return true;}} class OknoViewEmptyKadr implements Kadr { short x; short y; short w; short h; public void updatePos(short x,short y) { this.x=(short)(x / 2); this.y=(short)(y / 2);} public void make(Graphics ics,short mx,short my) { if(x > 0) { w=(short)(mx / 2+5); h=(short)(my / 2+5);} ics.drawRect(x,y,w,h);}} interface OknosManager { void clearAllWindows(); void createWindow(short x,short y,short w,short h,short delay,OknosCtx ctx); Okno getWindow(int index); Kadr getWindowKadr(int index); int getWindowsNum();} class OknosCtx { private Karta attrMap=new Karta(); public OknosCtx() { super();} public Object getAttr(String name) { return attrMap.get(name);} public void setAttr(String name,Object attr) { attrMap.put(name,attr);}} class KinDi3 { public static final KinDi3 EXT=new KinDi3(1,"external"); public static final KinDi3 INT=new KinDi3(1+1,"internal"); public static final KinDi3 INT3D=new KinDi3(1+1+1,"I3D"); private int id; private String name; private KinDi3(int id,String name) { this.id=id; this.name=name;} public int getId() { return id;} public String getName() { return name;}}