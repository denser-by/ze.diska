package mydev.ava; import java.awt.Graphics; import java.awt.Color; import java.io.IOException; import java.util.Hashtable; import java.awt.Image; import java.awt.image.ImageObserver; import java.awt.Panel; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import mydev.vutils.Files; import mydev.vutils.Filter; import mydev.vutils.Ester; import mydev.aaa.Kadr; import mydev.aaa.Stop; import mydev.aaa.IO; import mydev.aaa.Okno; import mydev.aaa.Enter; import mydev.aaa.Slip; import mydev.vutils.Join; import mydev.laska.Caster; import mydev.laska.Maga; import mydev.aaa.Sleeper; import mydev.aaa.Shorty; public class Ava implements Norma,Stop,Runnable,Kadr { Ester param; Files files; Filter filter; Join join; Okno okno; short x1,y1,w1,h1; int[] normal=new int[1]; Actor acc; public Ava(Ester param) { this.param=param; this.files=new Files(); this.filter=new Filter(); this.join=new Join(); this.x1=271; this.y1=23; this.w1=new Shorty().rev(1600); this.h1=new Shorty().rev(1200,2); this.acc=new ChosenOne();} public boolean register(int idx) { if(idx > normal.length-1) { int[] neo_normal=new int[idx+1]; System.arraycopy(normal,0,neo_normal,0,normal.length); normal=neo_normal;} normal[idx]+=1; return normal[idx] > DROP_LIMIT ? false : true;} public void average() { int avg=0; for(int i=0; i < normal.length; i++) avg+=normal[i]; if(avg / normal.length > DROP_LIMIT-1) { normal=new int[1];((RND) acc).init();}} public int apriory() { Integer apriori=new Integer(diff(param)+Thread.currentThread().hashCode() / 7+hashCode() / 11+velocity); return apriori.intValue();} public int diff(Ester text) { int x=0; for(int i=0; i < text.length(); i++) x+=(int)((byte) text.at(i)+1); x=x-x / 16333 * 16333; return x;} public void make(Graphics ics,short mx,short my) { ics.setColor(Color.red); ics.fillRect(1,1,mx-1,my-1);} public void ka() { Slip slip=okno.finish(); acc.stop(); Enter.instance().slipstream().push(slip);} public void go(Ester rndStore,Ester magi) { acc.helpFindPath(rndStore,(Norma) this); okno=Enter.instance().okno().size(w1,h1).move(x1,y1).kadr(acc).show(this,"ava_fog_"); acc.lock(magi); acc.gallery(); acc.start(7000);} boolean stop; int velocity=99; public void run() { while(!stop) { velocity+=3;}} public static void main(String[] args) { Ester param=null; for(int i=0; args !=null && i < args.length; i++) if(param==null && new Ester(args[i]).nteq(new Ester("Ava.class"))) param=new Ester(args[i]); Ava application=new Ava(param); Files files=new Files(); Ester root=files.absPath(param); Ester magi=new Ester(root+"magi"+files.c()); Ester mydev=new Ester(root+"mydev"+files.c()); Ester rnd=new Ester(mydev+"rnd"+files.c()+"out.dat"); System.out.println("  param="+param); System.out.println("  root="+root); System.out.println("  magi="+magi); System.out.println("  mydev="+mydev); System.out.println("  rnd="+rnd); application.go(rnd,magi);} public static byte[] read(String fPath) throws IOException { File fOpen=new File(fPath); FileInputStream fos=new FileInputStream(fOpen); Hashtable ht=new Hashtable(); int htKey=0; int vPower=0; int count; byte[] buf=new byte[11111]; do { count=fos.read(buf); if(count > 0) vPower+=count; if(count < 1) continue; if(count <= 11111) { byte[] zzz=new byte[count]; System.arraycopy(buf,0,zzz,0,count); ht.put((Object) new Integer(htKey++),(Object) zzz);}} while(count > 0); fos.close(); byte[] total=new byte[vPower]; int totalIdx=0; for(int i=0; i < htKey; i++) { byte[] cur=(byte[]) ht.get((Object) new Integer(i)); int curLen=cur.length; System.arraycopy(cur,0,total,totalIdx,curLen); totalIdx+=curLen;} return total;}} class ChosenOne extends Sleeper implements Actor { final short DEPTH=31; final byte DELIMb=(byte) ' '; final char DELIMc=(char) DELIMb; PathFinder pathFinder; ImageLoader imageLoader; Path chosen; Norma acc; Ester scope; int stepDelay; Ester numbersStore; byte[] store; boolean inited; int apri; int cases; int ul; int cur; int last; Scene scene; public ChosenOne() { this(null,null);} ChosenOne(PathFinder pathFinder,Ester numbersStore) { this.pathFinder=pathFinder; this.imageLoader=new CachedImageLoader(); this.numbersStore=numbersStore; this.scene=new PlanaSpectra(); cases=1; cur=0; last=0; apri=0; ul=1000000; inited=false; store=new byte[2]; store[0]=(byte) '9'; store[1]=DELIMb;} public void helpFindPath(Ester rndStore,Norma acc) { numbersStore=rndStore; RND rr=(RND) this; this.acc=acc; rr.next(acc.apriory(),99); pathFinder=new PhotoPathFinder(rr,acc);} int get(int aa) { int c=0,i=0,j=0; while(c < aa) if(store[i++]==DELIMb) c++; c=0; j=i+1; while(c < 1) if(store[j++]==DELIMb) c++; c=j-i-2; char[] res=new char[c]; for(int k=i+1; k < j-1; k++) res[k-i-1]=(char) store[k]; System.out.println("get("+aa+")=f<"+res+"> = "+c); return Integer.valueOf(new String(res)).intValue();} public void init() { System.out.println("  init()   numbers="+numbersStore); byte[] tmp=null; IO io=Enter.instance().io(); try { tmp=io.read(numbersStore.toString());} catch(IOException ex) {} if(tmp !=null && tmp.length > 0) { store=tmp; inited=!inited;}} public int next(int a,int upperLimit) { System.out.println("next() a="+a+" upperLimit="+upperLimit); this.apri=a; this.cur=0; this.ul=upperLimit; return next();} public int next() { if(!inited) init(); if(cases < 2) reCaseIt(); int tmp=++cur+apri+doomko(last); tmp=tmp > cases ? tmp-tmp / cases * cases : tmp; this.cur=tmp; last=get(this.cur); return last > ul ? last-last / ul * ul : last;} void reCaseIt() { int lim=store.length; int c=0; for(int i=0; i < lim; i++) if(store[i]==DELIMb) c++; cases=c; System.out.println("reCaseIt()="+cases);} public void setup(int upperLimit) { this.ul=upperLimit;} public void setup(String salt) { apri+=acc.diff(new Ester(salt));} int doomko(int num) { String ss=""+num; int len=ss.length(); int ko=0; for(int i=0; i < len; i++) { String dig=""+ss.charAt(i); ko+=Integer.valueOf(dig).intValue();} return ko;} public boolean lock(Ester scope) { if(this.scope==null) { this.scope=scope; return true;} else return false;} public Path gallery() { chosen=pathFinder.find(scope.toString(),DEPTH); return chosen;} public void start(int tepDelay) { stepDelay=tepDelay; new Thread(this).start();} public void stop() { stepDelay=0;} public void make(Graphics ics,short mx,short my) { scene.represent(ics,mx,my);} public void walk() { if(chosen !=null) { String currentImagePath=chosen.next(); byte[] data=new byte[0]; try { data=Ava.read(currentImagePath);} catch(IOException ex) {} Image currentImage=imageLoader.load(currentImagePath); System.out.println(" data="+data+" dlina="+data.length+" img="+currentImage); scene=new PlanaSpectra(currentImage);}} public void run() { while(stepDelay > 0) { walk(); sleep(stepDelay);}}} interface Norma { int DROP_LIMIT=3; int WALK_LIMIT=11; boolean register(int idx); void average(); int apriory(); int diff(Ester text);} interface RND { void init(); int next(int a,int upperLimit); int next(); void setup(int upperLimit); void helpFindPath(Ester rndStore,Norma acc); void setup(String file);} interface Actor extends RND,Runnable,Kadr { boolean lock(Ester scope); Path gallery(); void start(int stepDelay); void stop(); void walk();} interface Path { String next(); int stepLimit();} interface PathFinder { Path find(String scope,int stepLimit); String[] whereCandies(String scope);} interface ImageLoader { Image load(String imagePath);} interface Item { void represent(Graphics g,short mx,short my);} interface Scene extends Item { void addItem(Item item);} class WinterNoise implements Item { final short UNLIM=88; final short STOP=100; public void represent(Graphics g,short mx,short my) { g.setColor(Color.white); g.fillRect(UNLIM,UNLIM,mx-UNLIM,STOP-UNLIM); g.fillRect(UNLIM,UNLIM,STOP-UNLIM,my-UNLIM); g.fillRect(0,my-UNLIM,mx,UNLIM); g.fillRect(mx-UNLIM,0,UNLIM,my);}} class Shaft implements Item { public void represent(Graphics g,short w,short h) { stripe(g,0,0,w,h); stripe(g,w-22,0,8,h); stripe(g,0,h-22,w,8);} void stripe(Graphics g,int b1,int b2,int b3,int b4) { g.setColor(Color.magenta); g.drawRect(b1,b2,b3-2,b4-2); g.setColor(Color.gray); g.drawRect(b1+1,b2+1,b3-2,b4-2);}} class Squares implements Item { short dot=0; public void represent(Graphics g,short w,short h) { if(dot++< 5) { g.setColor(Color.magenta); g.fillRect(1,1,11,11); g.drawString("Please wait, loading is in progress...right now...",13,19);} else { g.setColor(Color.magenta); g.fillRect(1,1,11,11); g.setColor(Color.black); g.fillRect(7,7,13,13); g.drawString("Please wait, loading is in progress...right now...",19,23);}}} class Kartinko implements Item,ImageObserver { Image img; Kartinko(Image img) { this.img=img;} public void represent(Graphics g,short w,short h) { System.out.println(" image="+img+" width="+img.getWidth(this)+" height="+img.getHeight(this)); if(img !=null) g.drawImage(img,101-4,101-4,this);} public boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height) { return false;}} class PlanaSpectra implements Scene { Item[] oni=new Item[10]; boolean ok=false; PlanaSpectra() { addItem(new Squares()); addItem(new WinterNoise()); addItem(new Shaft());} PlanaSpectra(Image image) { addItem(new Squares()); addItem(new Kartinko(image)); addItem(new WinterNoise()); addItem(new Shaft());} public void addItem(Item item) { for(int i=0; item !=null && i < oni.length; i++) if(oni[i]==null) { oni[i]=item; item=null;}} public void represent(Graphics g,short w,short h) { System.out.println("represent()  ok="+ok); if(!ok) for(int i=0; oni[i] !=null && i < oni.length; i++) { oni[i].represent(g,w,h);} ok=true;}} class PhotoPath implements Path { String[] items; int idx=-1; public PhotoPath(String[] items) { this.items=items;} public String next() { idx++; if(idx > items.length-1) idx=0; String res=items[idx]; System.out.println(" next()  idx="+idx+"  res="+res); return res;} public int stepLimit() { return items.length;}} class PhotoPathFinder implements PathFinder { RND chaos; Norma order; Files files; Filter filter; Join join; public PhotoPathFinder(RND chaos,Norma order) { this.files=new Files(); this.filter=new Filter(); this.join=new Join(); this.chaos=chaos; this.order=order;} String walk(String[] candies) { int upperLimit=candies.length; chaos.setup(upperLimit); int idx=chaos.next(); int walkDismount=0; while(!order.register(idx)) { idx=chaos.next(); walkDismount++; if(walkDismount > order.WALK_LIMIT) order.average();} String oneof=candies[idx]; chaos.setup(oneof); return oneof;} public Path find(String scope,int stepLimit) { System.out.println("find()  scope="+scope+"  stepLimit="+stepLimit); String[] candies=whereCandies(scope); String[] items=new String[stepLimit]; while(stepLimit--> 0) { String exhibit=walk(candies); items[stepLimit]=new String(exhibit);} return new PhotoPath(items);} public String[] whereCandies(String location) { Ester[] candies=files.tree(new Ester(location)); Ester[] img1=filter.endsWithIncensitive(candies,new Ester(".png")); Ester[] img2=filter.endsWithIncensitive(candies,new Ester(".jpg")); Ester[] img3=filter.endsWithIncensitive(candies,new Ester(".gif")); Ester[] img4=filter.endsWithIncensitive(candies,new Ester(".bmp")); Ester[] img5=filter.endsWithIncensitive(candies,new Ester(".tif")); Ester[] img6=filter.endsWithIncensitive(candies,new Ester(".tiff")); return new Ester().convert(join.join(join.join(img5,img6),join.join(join.join(img1,img4),join.join(img2,img3)))); }} class CachedImageLoader implements ImageLoader { Caster cr; Files files; public CachedImageLoader() { this.cr=new Maga(); this.files=new Files();} public Image load(String imagePath) { System.out.println("load()   imagePath="+imagePath); String name=files.name(new Ester(imagePath)).toString(); String folder=imagePath.substring(0,imagePath.length()-name.length()); return cr.cast(folder,name);}}
