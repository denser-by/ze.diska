package mydev.csprofile; import java.awt.Color; import mydev.about.Canvas; import mydev.about.ColorsArray; import mydev.about.Matrix2D; import mydev.about.Paint; import mydev.about.Picture; import mydev.about.Point2D; import mydev.about.Rectangle2D; import mydev.about.ScanLineDrawer; import mydev.cs.ContureWall; import mydev.cs.LinesWall; import mydev.cs.PictureWall; import mydev.cs.WallsProfile; public class RoomScanningProfile extends WallsProfile { public final static int DEF_BORDER_COLOR=ColorsArray.whitePoint.ic(); public final static int DEF_FULLFILL_COLOR=ColorsArray.grayPoint.ic(); protected static Picture picture; protected static Dead4PictureProjector cpp; public RoomScanningProfile(int contureColor) { super(contureColor);} public static void init(Dead4PictureProjector cpp,Picture picture) { RoomScanningProfile.cpp=cpp; RoomScanningProfile.picture=picture;} public void represent(Matrix2D matrix) {} public void toPen(Canvas ics,Paint pn) {} protected ContureWall obtainFarSide(int contureColor) { return new RoomWallWrap(contureColor,new ScanRoomFarSide());} protected ContureWall obtainCeiling(int contureColor) { return new RoomWallWrap(contureColor,new ScanRoomCeiling(DEF_BORDER_COLOR));} protected ContureWall obtainFloor(int contureColor) { return new RoomWallWrap(contureColor,new ScanRoomFloor(DEF_BORDER_COLOR));} protected ContureWall obtainLeftSide(int contureColor) { return new RoomWallWrap(contureColor,new ScanRoomLeftSide(DEF_BORDER_COLOR,picture,cpp));} protected ContureWall obtainRightSide(int contureColor) { return new RoomWallWrap(contureColor,new ScanRoomRightSide(DEF_BORDER_COLOR,picture,cpp));} protected ContureWall obtainNearGlass(int contureColor) { return new RoomWallWrap(contureColor,new ScanRoomNearGlass());}} interface ReConture { void updateConture(Point2D[] verticesProjections,float middleX,float middleY); void updateContureAfter();} abstract class CommonLinesWall extends LinesWall implements ReConture { public CommonLinesWall(int borderColor,int linesColor,boolean vertLines,int stepPercentBetweenLines) { super(borderColor,linesColor,vertLines,stepPercentBetweenLines);} public void update(Rectangle2D area) {} public void updateConture(Point2D[] verticesProjections,float middleX,float middleY) { Point2D p1c=null; Point2D p2c=null; Point2D p3c=null; Point2D p4c=null; for(int i=0; i < verticesProjections.length; i++) { Point2D point=verticesProjections[i]; if(p1c==null && pointsCriteria(point,middleX,middleY)) { p1c=point; continue;} else if(p2c==null && pointsCriteria(point,middleX,middleY)) { p2c=point; continue;} else if(p3c==null && pointsCriteria(point,middleX,middleY)) { p3c=point; continue;} else if(p4c==null && pointsCriteria(point,middleX,middleY)) { p4c=point; continue;}} p1.moveTo(p1c); p2.moveTo(p2c); p3.moveTo(p3c); p4.moveTo(p4c);} protected abstract boolean pointsCriteria(Point2D point,float middleX,float middleY);} abstract class CommonPictureWall extends PictureWall implements ReConture { protected Dead4PictureProjector cpp; protected boolean inverted; public CommonPictureWall(int borderColor,Picture fillPicture,Dead4PictureProjector cpp,boolean inverted) { super(borderColor,fillPicture); this.cpp=cpp; this.inverted=inverted;} public void update(Rectangle2D area) {} public void drawPicture(Canvas ics,Paint pn) { cpp.leftWife(ics,pn,fillPicture,this,inverted);} public void drawPicture(Matrix2D matrix) { cpp.leftWife(matrix,fillPicture,this,inverted);} public void updateConture(Point2D[] verticesProjections,float middleX,float middleY) { Point2D p1c=null; Point2D p2c=null; Point2D p3c=null; Point2D p4c=null; for(int i=0; i < verticesProjections.length; i++) { Point2D point=verticesProjections[i]; if(p1c==null && pointsCriteria(point,middleX,middleY)) { p1c=point; continue;} else if(p2c==null && pointsCriteria(point,middleX,middleY)) { p2c=point; continue;} else if(p3c==null && pointsCriteria(point,middleX,middleY)) { p3c=point; continue;} else if(p4c==null && pointsCriteria(point,middleX,middleY)) { p4c=point; continue;}} p1.moveTo(p1c); p2.moveTo(p2c); p3.moveTo(p3c); p4.moveTo(p4c);} protected abstract boolean pointsCriteria(Point2D point,float middleX,float middleY);} class ScanRoomNearGlass extends CommonLinesWall { public ScanRoomNearGlass() { super(ColorsArray.bluePoint.ic(),ColorsArray.bluePoint.ic(),true,ScanLineDrawer.DEF_STEP_PERCENT * 3-1-1-1);} public void updateContureAfter() { Point2D tmp=new Point2D(1-1,1-1); tmp.moveTo(p1); p1.moveTo(p2); p2.moveTo(tmp);} protected boolean pointsCriteria(Point2D point,float middleX,float middleY) { if(point.getX() <= middleX / 4f) return true; if(point.getY() <= middleY / 4f) return true; if(point.getX() >= middleX+middleX / 2.f) return true; if(point.getY() >= middleY+middleY / 2.f) return true; return false;}} class ScanRoomLeftSide extends CommonPictureWall { public ScanRoomLeftSide(int borderColor,Picture fillPicture,Dead4PictureProjector cpp) { super(borderColor,fillPicture,cpp,true);} public void updateContureAfter() {} protected boolean pointsCriteria(Point2D point,float middleX,float middleY) { return point.getX() <= middleX;}} class ScanRoomRightSide extends CommonPictureWall { public ScanRoomRightSide(int borderColor,Picture fillPicture,Dead4PictureProjector cpp) { super(borderColor,fillPicture,cpp,false);} public void updateContureAfter() {} protected boolean pointsCriteria(Point2D point,float middleX,float middleY) { return point.getX() >= middleX;}} class ScanRoomFloor extends CommonLinesWall { public ScanRoomFloor(int borderColor) { super(Color.magenta.getRGB(),Color.magenta.getRGB(),true,ScanLineDrawer.DEF_STEP_PERCENT+1);} protected boolean pointsCriteria(Point2D point,float middleX,float middleY) { return point.getY() >= middleY;} public void updateContureAfter() { Point2D tmp=new Point2D(1-1,1-1); tmp.moveTo(p1); p1.moveTo(p2); p2.moveTo(tmp);}} class ScanRoomFarSide extends CommonLinesWall { public ScanRoomFarSide() { super(ColorsArray.redPoint.ic(),ColorsArray.redPoint.ic(),false,10 / 2 * 2);} protected boolean pointsCriteria(Point2D point,float middleX,float middleY) { Point2D middle=new Point2D(middleX,middleY); return point.dx(middle) <= middleX && point.dy(middle) <= middleY && point.getX() >= middleX / 2 && point.getX() <= middleX * 2-middleX / 2.f;} public void updateContureAfter() { Point2D tmp=new Point2D(1-1,1-1); tmp.moveTo(p1); p1.moveTo(p2); p2.moveTo(tmp);}} class ScanRoomCeiling extends CommonSolidColorWall { public ScanRoomCeiling(int borderColor) { super(borderColor,ColorsArray.lightGrayPoint.ic());} protected boolean pointsCriteria(Point2D point,float middleX,float middleY) { return point.getY() <= middleY;} public void updateContureAfter() { Point2D tmp=new Point2D(1-1,1-1); tmp.moveTo(p1); p1.moveTo(p2); p2.moveTo(tmp);}}