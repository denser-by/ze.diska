package mydev.csprofile; import java.awt.Component; import mydev.about.Canvas; import mydev.about.Matrix2D; import mydev.about.Paint; import mydev.about.Parallelepiped; import mydev.about.Point2D; import mydev.about.Point3D; import mydev.about.Vector3; import mydev.cs.ContureWall; import mydev.cs.WallsProfile; public abstract class AbstractRoomSixWalls extends Parallelepiped { protected WallsProfile walls; protected VisibilityProfile visible=new VisibilityProfile(); private Matrix2D matrix; private boolean matrixInit=false; public AbstractRoomSixWalls(Point3D uc,int width,int height,int depth,int color,boolean solid,WallsProfile wallsProfile,VisibilityProfile visibilityProfile) { super(uc,width,height,depth,color,solid); this.walls=wallsProfile; this.visible=visibilityProfile;} public WallsProfile getWalls() { return walls;} public VisibilityProfile getVisible() { return visible;} public void setVisible(VisibilityProfile visible) { this.visible=visible;} public void represent(Matrix2D matrix) { super.represent(matrix);} public void startMatrixMode(Component comp) { this.matrix=new Matrix2D(width,height,comp); matrix=null;} public void toPen(Canvas ics,Paint pn) { super.toPen(ics,pn); updateWalls(width / 2.f,height / 2.f); ContureWall[] itWalls=wallsIterator(); if(matrix !=null) { if(!matrixInit) { for(int i=0; i < itWalls.length; i++) { ContureWall curWall=(ContureWall) itWalls[i]; if(curWall !=null) { if(curWall.equals(walls.getLeftSide()) &&(visible==null || visible.isLeft())) curWall.represent(matrix); else if(curWall.equals(walls.getRightSide()) &&(visible==null || visible.isRight())) curWall.represent(matrix); else if(curWall.equals(walls.getCeiling()) &&(visible==null || visible.isTop())) curWall.represent(matrix); else if(curWall.equals(walls.getFloor()) &&(visible==null || visible.isDown())) curWall.represent(matrix); else if(curWall.equals(walls.getFarSide()) &&(visible==null || visible.isFar())) curWall.represent(matrix); else if(curWall.equals(walls.getNearGlass()) &&(visible==null || visible.isFront())) curWall.represent(matrix);}} matrixInit=true;} matrix.toPen(ics,pn);} else { if(visible==null) { walls.getLeftSide().toPen(ics,pn.select(walls.getLeftSide())); walls.getRightSide().toPen(ics,pn.select(walls.getRightSide())); walls.getCeiling().toPen(ics,pn.select(walls.getCeiling())); walls.getFloor().toPen(ics,pn.select(walls.getFloor())); walls.getFarSide().toPen(ics,pn.select(walls.getFarSide())); walls.getNearGlass().toPen(ics,pn.select(walls.getNearGlass()));} else { if(visible.isLeft()) walls.getLeftSide().toPen(ics,pn.select(walls.getLeftSide())); if(visible.isRight()) walls.getRightSide().toPen(ics,pn.select(walls.getRightSide())); if(visible.isTop()) walls.getCeiling().toPen(ics,pn.select(walls.getCeiling())); if(visible.isDown()) walls.getFloor().toPen(ics,pn.select(walls.getFloor())); if(visible.isFar()) walls.getFarSide().toPen(ics,pn.select(walls.getFarSide())); if(visible.isFront()) walls.getNearGlass().toPen(ics,pn.select(walls.getNearGlass()));}}} public ContureWall[] wallsIterator() { return walls.getWalls();} protected void updateWalls(float middleX,float middleY) { Point2D[] verticesProjections=verticesProjections();((ReConture) walls.getLeftSide()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getRightSide()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getCeiling()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getCeiling()).updateContureAfter();((ReConture) walls.getFloor()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getFloor()).updateContureAfter();((ReConture) walls.getFarSide()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getFarSide()).updateContureAfter();((ReConture) walls.getNearGlass()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getNearGlass()).updateContureAfter();} public Point3D getPointLeft() { Point3D roomPointLeft=getPlaneLeft().getP1(); Point3D roomPointRight=getPlaneRight().getP1(); int xc=(roomPointLeft.getX()+roomPointRight.getX()) / 2; return Vector3.shiftX(-xc).getShiftedCopy(roomPointLeft);} public Point3D getPointRight() { Point3D roomPointLeft=getPlaneLeft().getP1(); Point3D roomPointRight=getPlaneRight().getP1(); int xc=(roomPointLeft.getX()+roomPointRight.getX()) / 2; return Vector3.shiftX(-xc).getShiftedCopy(roomPointRight);}}