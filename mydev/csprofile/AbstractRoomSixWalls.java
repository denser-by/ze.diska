package mydev.csprofile; import java.awt.Component; import mydev.about.Canvas; import mydev.about.Matrix2D; import mydev.about.Paint; import mydev.about.Parallelepiped; import mydev.about.Point2D; import mydev.about.Point3D; import mydev.about.Vector3; import mydev.cs.ContureWall; import mydev.cs.WallsProfile; public abstract class AbstractRoomSixWalls extends Parallelepiped { protected WallsProfile walls; protected VisibilityProfile visible=new VisibilityProfile(); private Matrix2D matrix; private boolean matrixInit=false; public AbstractRoomSixWalls(Point3D uc,int width,int height,int depth,int color,boolean solid,WallsProfile wallsProfile,VisibilityProfile visibilityProfile) { super(uc,width,height,depth,color,solid); this.walls=wallsProfile; this.visible=visibilityProfile;} public WallsProfile getWalls() { return walls;} public VisibilityProfile getVisible() { return visible;} public void setVisible(VisibilityProfile visible) { this.visible=visible;} public void represent(Matrix2D matrix) { super.represent(matrix);} public void startMatrixMode(Component comp) { this.matrix=new Matrix2D(width,height,comp); matrix=null;} public void toPen(Canvas ics,Paint pn) { super.toPen(ics,pn); updateWalls(width / 2.f,height / 2.f); ContureWall[] itWalls=wallsIterator(); if(matrix !=null) { if(!matrixInit) { for(int i=0; i < itWalls.length; i++) { ContureWall curWall=(ContureWall) itWalls[i]; if(curWall !=null) { if(curWall.equals(walls.getLeftSide()) &&(visible==null || visible.isWallLeft())) curWall.represent(matrix); else if(curWall.equals(walls.getRightSide()) &&(visible==null || visible.isWallRight())) curWall.represent(matrix); else if(curWall.equals(walls.getCeiling()) &&(visible==null || visible.isWallTop())) curWall.represent(matrix); else if(curWall.equals(walls.getFloor()) &&(visible==null || visible.isWallDown())) curWall.represent(matrix); else if(curWall.equals(walls.getFarSide()) &&(visible==null || visible.isWallFar())) curWall.represent(matrix); else if(curWall.equals(walls.getNearGlass()) &&(visible==null || visible.isWallNear())) curWall.represent(matrix);}} matrixInit=true;} matrix.toPen(ics,pn);} else for(int i=0; i < itWalls.length; i++) { ContureWall curWall=(ContureWall) itWalls[i]; if(curWall !=null) { if(curWall.equals(walls.getLeftSide()) &&(visible==null || visible.isWallLeft())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getRightSide()) &&(visible==null || visible.isWallRight())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getCeiling()) &&(visible==null || visible.isWallTop())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getFloor()) &&(visible==null || visible.isWallDown())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getFarSide()) &&(visible==null || visible.isWallFar())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getNearGlass()) &&(visible==null || visible.isWallNear())) curWall.toPen(ics,pn.select(curWall));}}} public void toPen2(Canvas ics,Paint pn) { super.toPen(ics,pn); updateWalls(width / 2.f,height / 2.f); ContureWall[] itWalls=wallsIterator(); for(int i=0; i < itWalls.length; i++) { ContureWall curWall=(ContureWall) itWalls[i]; if(curWall !=null) { if(curWall.equals(walls.getLeftSide()) &&(visible==null || visible.isWallLeft())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getRightSide()) &&(visible==null || visible.isWallRight())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getCeiling()) &&(visible==null || visible.isWallTop())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getFloor()) &&(visible==null || visible.isWallDown())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getFarSide()) &&(visible==null || visible.isWallFar())) curWall.toPen(ics,pn.select(curWall)); else if(curWall.equals(walls.getNearGlass()) &&(visible==null || visible.isWallNear())) curWall.toPen(ics,pn.select(curWall));}}} public ContureWall[] wallsIterator() { return walls.getWalls();} protected void updateWalls(float middleX,float middleY) { Point2D[] verticesProjections=verticesProjections();((ReConture) walls.getLeftSide()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getRightSide()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getCeiling()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getCeiling()).updateContureAfter();((ReConture) walls.getFloor()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getFloor()).updateContureAfter();((ReConture) walls.getFarSide()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getFarSide()).updateContureAfter();((ReConture) walls.getNearGlass()).updateConture(verticesProjections,middleX,middleY);((ReConture) walls.getNearGlass()).updateContureAfter();} public Point3D getPointLeft() { Point3D roomPointLeft=getPlaneLeft().getP1(); Point3D roomPointRight=getPlaneRight().getP1(); int xc=(roomPointLeft.getX()+roomPointRight.getX()) / 2; return Vector3.shiftX(-xc).getShiftedCopy(roomPointLeft);} public Point3D getPointRight() { Point3D roomPointLeft=getPlaneLeft().getP1(); Point3D roomPointRight=getPlaneRight().getP1(); int xc=(roomPointLeft.getX()+roomPointRight.getX()) / 2; return Vector3.shiftX(-xc).getShiftedCopy(roomPointRight);}}