package mydev.oki; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Color; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Label; import java.awt.Panel; import java.io.IOException; import java.net.Socket; import java.net.UnknownHostException; import java.util.Enumeration; import java.util.Vector; public class Totalic { static int DEF_TIMEOUT=40; static String DEF_NAME="student"; static String DEF_SPLIT=": "; static String DEF_STT=" has changed status to "; static String DEF_REN=" has renamed to "; static String MG_START="Hello"; static String MG_RENAME="RN"; static String MG_STATUS="CS"; static String MG_MSG="MG"; static String MG_REPLY="ok"; static String MG_TOTAL="TL"; static String MG_LISTEN="LT"; static Color mainColor=Color.yellow; static Color defaultColor=Color.lightGray; static Color editColor=Color.white; static String ST_AWAY="Away"; static String ST_ONLINE="Online"; static String ST_BUSY="Busy"; static String BT_SUBMIT="Submit"; static String BT_CONNECT="Connect"; static String BT_LEAVE="Leave"; static String BT_LUNCH="Lunch"; static String BT_STOP_SRV="Stop Server"; static String LB_PORT="Port:"; static String LB_SRV="Server:"; static String LB_MSG="Message:"; static String LB_NMS="Name:"; static String LB_ST="Status:"; static String LB_CNCT="Connections:"; static String DEF_HOST="localhost"; static int DEF_PORT=1123; static int DEF_CONN=0; static String STOP="z"; MiniFrame view; public Totalic() {} public static void main(String[] args) { Totalic obj=new Totalic(); while(obj.organise()) { try { Thread.sleep(Totalic.DEF_TIMEOUT);} catch(Throwable e) { e.getMessage();}} System.exit(1-1);} boolean organise() { if(view==null) construct(); if(view.ls !=null && view.ls.toUpdate >= 1) { view.ls.toUpdate=0; view.pnSrv.updateConnections(view.ls.getConnections()); if(view.ls.locMsg.hasPending()) view.pnHist.updateServiceMessages(view.ls.locMsg.popMesages());} if(view.cht !=null && view.cht.toUpdate >= 1) { view.cht.toUpdate=0; view.pnConts.updateContacts(view.cht.getContacts()); view.pnHist.updateIncoming(view.cht.getIncomings()); if(view !=null && view.cht !=null && view.cht.locMsg !=null && view.cht.locMsg.hasPending()) view.pnHist.updateServiceMessages(view.cht.locMsg.popMesages());} return view.stopped==null;} void construct() { view=new MiniFrame("Knopy"); view.setLayout(new BorderLayout()); view.add("North",view.pnSrv=new ServerPanel()); view.add("Center",view.pnClnt=new Panel()); view.pnClnt.setLayout(new BorderLayout()); view.pnClnt.add("North",view.pnConnect=new ConnecterPanel()); view.pnClnt.add("West",view.pnConts=new ContactsView()); view.pnClnt.add("Center",view.pnHist=new TemporaryView()); view.pnClnt.add("South",view.pnCreate=new PublishingPanel()); view.pack(); view.show();}} class PublishingPanel extends Panel { OptionsField opStat; EditField efMsg; EditField efName; Button btSubmit; public PublishingPanel() { setLayout(new FlowLayout()); add(new Label(Totalic.LB_MSG)); add(efMsg=new EditField(31)); add(new Label(Totalic.LB_ST)); add(opStat=new OptionsField()); add(new Label(Totalic.LB_NMS)); add(efName=new EditField(9)); add(btSubmit=new Button(Totalic.BT_SUBMIT)); setBackground(Totalic.defaultColor); opStat.addItem(Totalic.ST_AWAY); opStat.addItem(Totalic.ST_ONLINE); opStat.addItem(Totalic.ST_BUSY); opStat.select(Totalic.ST_ONLINE); efName.setText(Totalic.DEF_NAME);} public ClientRecord submitPressed() { String usrMessage=efMsg.getText(); String usrName=efName.getText(); String usrStatus=opStat.getSelectedItem(); efMsg.setText(""); return new ClientRecord(usrName,usrStatus,usrMessage);}} class ConnecterPanel extends Panel { EditField tfServer; EditField tfPort; Button btConnect; Button btLeave; public ConnecterPanel() { setLayout(new FlowLayout()); add(new Label(Totalic.LB_SRV)); add(tfServer=new EditField(9)); add(new Label(Totalic.LB_PORT)); add(tfPort=new EditField(7)); add(btConnect=new Button(Totalic.BT_CONNECT)); add(btLeave=new Button(Totalic.BT_LEAVE)); setBackground(Totalic.defaultColor); tfServer.setText(Totalic.DEF_HOST); tfPort.setText(new Integer(Totalic.DEF_PORT).toString()); btLeave.enable(1==1+1);} void connectPressed() { btLeave.enable(); tfServer.enable(false); tfPort.enable(false); btConnect.enable(false);} public void leavePressed() { tfServer.enable(); tfPort.enable(); btConnect.enable(); btLeave.enable(1==1+1);} public int getPort() { int selected=Integer.valueOf(tfPort.getText()).intValue(); return selected;} public String getHost() { String host1=tfServer.getText(); return ""+host1;}} class ServerPanel extends Panel { EditField tfPort; Button btLunch; Button btClose; EditField tfAlive; public ServerPanel() { setLayout(new FlowLayout()); add(new Label(Totalic.LB_PORT)); add(tfPort=new EditField(7)); add(btLunch=new Button(Totalic.BT_LUNCH)); add(btClose=new Button(Totalic.BT_STOP_SRV)); add(new Label(Totalic.LB_CNCT)); add(tfAlive=new EditField(3)); setBackground(Totalic.mainColor); tfPort.setText(new Integer(Totalic.DEF_PORT).toString()); btClose.enable(1==1+1); tfAlive.setText(new Integer(Totalic.DEF_CONN).toString()); tfAlive.enable(false);} void updateConnections(int items) { tfAlive.enable(!false); tfAlive.setText(new Integer(items).toString()); tfAlive.enable(false);} void lunchPressed() { btClose.enable(); tfPort.enable(false); btLunch.enable(false);} public void closePressed() { tfPort.enable(); btLunch.enable(); btClose.enable(1==1+1);} public int getPort() { int selected=Integer.valueOf(tfPort.getText()).intValue(); return selected;}} class MiniFrame extends Frame { Object stopped; ServerPanel pnSrv; LocalServer ls; Panel pnClnt; ConnecterPanel pnConnect; ContactsView pnConts; TemporaryView pnHist; PublishingPanel pnCreate; Talking cht; Reviewer station; public MiniFrame(String cs) { super(cs); stopped=null; setBackground(Totalic.mainColor);} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) { processClose(); hide(); dispose(); stopped=new Integer(et.hashCode()+1);} if(et.id==Event.ACTION_EVENT && et.target==pnSrv.btLunch) processLunch(); if(et.id==Event.ACTION_EVENT && et.target==pnSrv.btClose) processClose(); if(et.id==Event.ACTION_EVENT && et.target==pnConnect.btConnect) processConnect(); if(et.id==Event.ACTION_EVENT && et.target==pnConnect.btLeave) processLeave(); if(et.id==Event.ACTION_EVENT && et.target==pnCreate.btSubmit) processSubmit(); return super.handleEvent(et);} private void processSubmit() { ClientRecord up=pnCreate.submitPressed(); if(cht !=null) { cht.submit(up); if(cht.locMsg.hasPending()) pnHist.updateServiceMessages(cht.locMsg.popMesages());}} private void processLeave() { pnConnect.leavePressed(); if(cht !=null) { cht.leave(); if(cht.locMsg.hasPending()) pnHist.updateServiceMessages(cht.locMsg.popMesages());} cht=null;} private void processConnect() { pnConnect.connectPressed(); if(station==null) station=new Reviewer(); cht=new Talking(); cht.setObserver(station); String srvHost=pnConnect.getHost(); int srvPort=pnConnect.getPort(); cht.assignServer(srvHost,srvPort);} private void processClose() { pnSrv.closePressed(); if(ls !=null) { ls.closeServer(); if(ls.locMsg.hasPending()) pnHist.updateServiceMessages(ls.locMsg.popMesages());} ls=null;} private void processLunch() { pnSrv.lunchPressed(); if(station==null) station=new Reviewer(); ls=new LocalServer(station); ls.lunchServer(pnSrv.getPort());}} class ObservableItem { static int TP_LOCAL=1; static int TP_IMPORTED=10; static int TP_OBSERVER=100; private boolean displayLocaly; private boolean retranslateLocaly; private int type; String info; boolean done; Vector ack; public ObservableItem(String msg,int tp) { info=msg; type=tp; done=false; displayLocaly=false; retranslateLocaly=false; ack=new Vector();} public ObservableItem(String msg) { info=msg; type=TP_OBSERVER; done=false; displayLocaly=false; retranslateLocaly=false; ack=new Vector();} ObservableItem(String msg,boolean b) { info=msg;} static public ObservableItem search(String msg) { return new ObservableItem(msg,false);} public boolean isImported() { return type==TP_IMPORTED;} public String getInfo() { return info;} public boolean isDone() { return done;} public void neverDone() { done=false;} public void markRead() { done=true;} public String extractMessage(String forName) { String result=null; if(!ack.contains(forName)) { ack.addElement(forName); result=info;} return result;} public String extractFor(String username) { String result=null; if(!ack.contains(username)) { ack.addElement(username); result=info;} return result;} public String extractDisplayLocaly() { String result=null; if(!displayLocaly) { displayLocaly=true; result=info;} return result;} public String extractRetranslateLocaly() { String result=null; if(!retranslateLocaly) { retranslateLocaly=true; result=info;} return result;} public int hashCode() { return 1+info.hashCode();} public boolean equals(Object obj) { if(this==obj) return true; ObservableItem other=(ObservableItem) obj; if(other==null) return false; if(info==null) return true; if(other==null) return false; return info.equals(other.info);}} class MessageProcessor implements Runnable { private Connection[] clientConnections; private Reviewer rep; Object stop; Thread working; int rqCount; public MessageProcessor() { rqCount=0; stop=null; clientConnections=new Connection[0];} public void setObserver(Reviewer observer) { rep=observer;} public void run() { boolean worked; while(stop==null) { worked=false; for(int i=0; i < clientConnections.length; i++) { Connection c1=clientConnections[i]; if(c1.hasBytes()) { String rq=getRq(c1); rqCount++; if(rq.equals(Totalic.MG_TOTAL)) { String cntList=prepareContacts(); c1.writeRead(Totalic.MG_TOTAL+cntList,Totalic.MG_REPLY);} else if(rq.equals(Totalic.MG_LISTEN)) { String name=getUsername(c1); String msgList=prepareMessaging(name); c1.writeRead(Totalic.MG_LISTEN+msgList,Totalic.MG_REPLY);} else { MsgParser sm=null; try { sm=fetchMessage(c1,rq);} catch(java.io.IOException e) { e.getMessage();} if(sm.type.equals(Totalic.MG_MSG) && !rep.serverHasClient(sm.name)) { processMessage(new MsgParser(Totalic.MG_RENAME,sm.name,sm.name),c1); c1.writeAnswer(0,Totalic.MG_REPLY);} else if(sm.type.equals(Totalic.MG_STATUS) && !rep.serverHasClient(sm.name)) c1.writeAnswer(4,Totalic.MG_REPLY); else if(sm.type.equals(Totalic.MG_RENAME) && sm.name.equals(sm.lastName) && !rep.serverHasClient(sm.name)) c1.writeAnswer(0,Totalic.MG_REPLY); else if(sm.type.equals(Totalic.MG_RENAME) && !sm.name.equals(sm.lastName) && !rep.serverHasClient(sm.name)) c1.writeAnswer(0,Totalic.MG_REPLY); else if(sm.type.equals(Totalic.MG_RENAME)) c1.writeAnswer(2,Totalic.MG_REPLY); else c1.writeAnswer(sm !=null ? 0 : 1,Totalic.MG_REPLY); processMessage(sm,c1);} worked=true;}} if(!worked) try { Thread.sleep(Totalic.DEF_TIMEOUT);} catch(Throwable e) { e.getMessage();}} for(int i=0; i < clientConnections.length; i++) { Connection c1=clientConnections[i]; c1.closed();} clientConnections=new Connection[0];} private String prepareMessaging(String forName) { String[] total=rep.getServerMessages(forName); String prepared=new Replacer().dlina(total.length); for(int j=0; j < total.length; j++) prepared+=new Replacer().dlina(total[j].length())+total[j]; return prepared;} private String prepareContacts() { String[] total=rep.getClients(); String result=new Replacer().dlina(total.length); for(int i=0; i < total.length; i++) result+=new Replacer().dlina(total[i].length())+total[i]; return result;} private void processMessage(MsgParser sm,Connection c1) { ClientRecord record=null; if(sm.type.equals(Totalic.MG_RENAME)) { if(!rep.serverHasClient(sm.name)) { record=rep.serverCreateClientRename(sm.lastName,sm.name); c1.setUserItem(record);}} else if(sm.type.equals(Totalic.MG_STATUS)) { record=c1.getUserItem(); if(record==null) { record=new ClientRecord("",sm.status); c1.setUserItem(record);} else record.usrStatus=sm.status;} else if(sm.type.equals(Totalic.MG_MSG)) { record=c1.getUserItem(); if(record==null) { record=new ClientRecord("",Totalic.ST_AWAY); c1.setUserItem(record);} rep.pushServerMessage(record,sm.message);}} private String getRq(Connection c1) { byte b1=(byte) 'a'; byte b2=(byte) 'a'; try { b1=c1.readByte(); b2=c1.readByte();} catch(java.io.IOException e) { e.getMessage();} String RQ=""+(char) b1+(char) b2; return RQ;} private String getUsername(Connection c1) { String username=""; try { int size=new Replacer().fetchDlina(c1); if(size > 0) while(size--> 0) username+=(char) c1.readByte();} catch(java.io.IOException e) { e.getMessage();} return username;} private MsgParser fetchMessage(Connection c1,String RQ) throws java.io.IOException { byte b1=(byte) RQ.charAt(0); MsgParser msg=null; if(RQ.compareTo(Totalic.MG_MSG)==0) { int msgSize=new Replacer().fetchDlina(c1); if(msgSize > 0) { msg=new MsgParser(Totalic.MG_MSG); while(msgSize--> 0) msg.feedMessageChar((char) c1.readByte());} int size=new Replacer().fetchDlina(c1); if(size > 0 && msg !=null) while(size--> 0) msg.feedNameChar((char) c1.readByte());} else if(RQ.compareTo(Totalic.MG_STATUS)==0) { msg=new MsgParser(RQ); b1=c1.readByte(); if(Totalic.ST_AWAY.charAt(0)==(char) b1) { msg.feedStatusChar((char) b1); for(int i=0; i < Totalic.ST_AWAY.length()-1; i++) msg.feedStatusChar((char) c1.readByte()); if(msg.statusNot(Totalic.ST_AWAY)) msg=null;} else if(Totalic.ST_BUSY.charAt(0)==(char) b1) { msg.feedStatusChar((char) b1); for(int i=0; i < Totalic.ST_BUSY.length()-1; i++) msg.feedStatusChar((char) c1.readByte()); if(msg.statusNot(Totalic.ST_BUSY)) msg=null;} else if(Totalic.ST_ONLINE.charAt(0)==(char) b1) { msg.feedStatusChar((char) b1); for(int i=0; i < Totalic.ST_ONLINE.length()-1; i++) msg.feedStatusChar((char) c1.readByte()); if(msg.statusNot(Totalic.ST_ONLINE)) msg=null;} int size=new Replacer().fetchDlina(c1); if(size > 0 && msg !=null) while(size--> 0) msg.feedNameChar((char) c1.readByte());} else if(RQ.compareTo(Totalic.MG_RENAME)==0) { int size=new Replacer().fetchDlina(c1); if(size > 0) { msg=new MsgParser(RQ); while(size--> 0) msg.feedLastNameChar((char) c1.readByte()); size=new Replacer().fetchDlina(c1); if(size > 0) while(size--> 0) msg.feedNameChar((char) c1.readByte()); else msg=null;}} return msg;} public void newConnection(Connection c1) { Connection[] tmp=new Connection[clientConnections.length+1]; for(int i=0; i < clientConnections.length; i++) tmp[i]=clientConnections[i]; tmp[clientConnections.length]=c1; clientConnections=tmp;} public int countConnections() { return clientConnections.length;}} class LocalServer implements Runnable { private Thread starting; private int srvPort; private Object stop; private java.net.ServerSocket srvSct; private Vector applied; private MessageProcessor rcv; protected Reviewer observer; int toUpdate; LocalNotifications locMsg; public LocalServer(Reviewer rv) { observer=rv; srvPort=-1; stop=null; srvSct=null; applied=new Vector(); locMsg=new LocalNotifications();} public int getRequests() { return rcv.rqCount;} public int getConnections() { int sz1=rcv.countConnections(); return sz1;} public void run() { while(stop==null) { if(srvPort > 0 && srvSct==null) try { srvSct=new java.net.ServerSocket(srvPort);} catch(java.io.IOException e) { e.getMessage();} if(srvPort > 0 && srvSct !=null) try { java.net.Socket accepted=srvSct.accept(); if(accepted !=null) applied.addElement(accepted); proceedHello(accepted);} catch(java.io.IOException e) { e.getMessage();} try { Thread.sleep(Totalic.DEF_TIMEOUT);} catch(Throwable e) { e.getMessage();}} if(srvSct !=null) { try { srvSct.close();} catch(java.io.IOException e) { e.getMessage();} srvSct=null;}} private void proceedHello(java.net.Socket accepted) { int fail=0; if(!new Replacer().readWrite(Totalic.MG_START,Totalic.MG_REPLY,accepted)) fail+=1; if(fail==0) { rcv.newConnection(new Connection(accepted)); locMsg.addMessage("connected."); toUpdate=1;} else { reportConnectionFailure(); try { accepted.getInputStream().close(); accepted.getOutputStream().close(); accepted.close();} catch(Throwable e) { e.getMessage();} if(accepted !=null) applied.removeElement(accepted);}} private void reportConnectionFailure() { locMsg.addMessage("Connection failure has occured."); toUpdate=4;} public void lunchServer(int port) { stop=null; srvPort=port; starting=new Thread(this); starting.start(); rcv=new MessageProcessor(); observer.reinitServer(); rcv.setObserver(observer); rcv.working=new Thread(rcv); rcv.working.start(); locMsg.addMessage("Local server has started on "+port+" port."); toUpdate=2;} public void closeServer() { stop=new Integer(new InterruptedException("xy").hashCode()); try { directConnect();} catch(Throwable e) { e.getMessage();} starting.stop(); starting=null; rcv.stop=new Integer(new InterruptedException("xy").hashCode()); rcv.working.stop(); rcv.working=null; locMsg.addMessage("Local server has stoppped."); toUpdate=3;} private void directConnect() throws UnknownHostException,IOException { Socket cls=new Socket(Totalic.DEF_HOST,srvPort); new Replacer().writeRead(Totalic.MG_START,Totalic.MG_REPLY,cls); cls.close();}} class Connection { private java.net.Socket sct; private ClientRecord record; public Connection(java.net.Socket sct) { this.sct=sct;} public void setUserItem(ClientRecord record) { this.record=record;} public ClientRecord getUserItem() { return record;} public void closed() { if(sct !=null) try { sct.close();} catch(java.io.IOException e) { e.getMessage();} sct=null;} public byte readByte() throws java.io.IOException { int b1=sct.getInputStream().read(); return(byte) b1;} public boolean writeBytes(byte[] cbc) { boolean b=false; if(sct !=null) try { sct.getOutputStream().write(cbc); sct.getOutputStream().flush(); b=true;} catch(java.io.IOException e) { e.getMessage();} return b;} public boolean hasBytes() { boolean b=false; if(sct !=null) try { b=sct.getInputStream().available() > 0;} catch(java.io.IOException e) { e.getMessage();} return b;} public boolean writeRead(String req,String answ) { boolean b1=new Replacer().writeRead(req,answ,sct); return b1;} public void writeAnswer(int fail,String reply) { new Replacer().writeAnswer(fail,Totalic.MG_REPLY,this);}} class EditField extends java.awt.TextField { public EditField(int space) { super(space); setBackground(Totalic.editColor);}} class ContactsView extends java.awt.List { Vector backup; public ContactsView() { super(22,1 > 0); setBackground(Totalic.mainColor); backup=new Vector();} public void updateContacts(String[] totalic) { for(int i=0; i < totalic.length; i++) if(!backup.contains(totalic[i])) { backup.addElement(totalic[i]); addItem(totalic[i]);} Vector step=new Vector(); for(int i=0; i < backup.size(); i++) { String pos=(String) backup.elementAt(i); boolean found=false; for(int j=0; !found && j < totalic.length; j++) if(pos.equals(totalic[j])) found=true; if(!found) step.addElement(pos);} for(int i=0; i < step.size(); i++) { String rem=(String) step.elementAt(i); backup.removeElement(rem); int length=countItems(); for(int j=0; j < length; j++) { if(rem.equals(getItem(j))) { delItem(j); j+=length;}}}}} class OptionsField extends java.awt.Choice { public OptionsField() { super(); setBackground(Totalic.editColor);}} class TemporaryView extends java.awt.TextArea { private LocalNotifications allMsg; public TemporaryView() { super(30,70); enable(false); setText("Start local message server or connect to other party."); setBackground(Totalic.editColor); setForeground(Totalic.defaultColor); allMsg=new LocalNotifications();} public void updateIncoming(String[] incomings) { for(int i=0; i < incomings.length; i++) if(!allMsg.justAdded(incomings[i])) allMsg.addMessage(incomings[i]); republishAll();} public void updateServiceMessages(String[] popMesages) { for(int i=0; i < popMesages.length; i++) allMsg.addMessage(popMesages[i]); republishAll();} void republishAll() { String total=allMsg.snippet(); enable(); appendText(total); enable(1 > 2);}} class LocalNotifications { Vector items; int last; public LocalNotifications() { items=new Vector(); last=-1;} public boolean justAdded(String msg) { boolean result=false; if(msg !=null && msg.length() > 0) for(int i=0; !result && i < 3; i++) { if(items.size()-i >= 0 && items.size()-i < items.size()) { String str=(String) items.elementAt(items.size()-i); if(str.equals(msg)) result=true;}} return result;} public void addMessage(String msg) { if(msg !=null && msg.length() > 0) items.addElement(msg);} public boolean hasPending() { return items !=null && items.size() > 0;} public String[] popMesages() { String retCode[]; retCode=new String[items.size()]; for(int i=0; i < retCode.length; i++) { retCode[i]=(String) items.elementAt(0); items.removeElementAt(0);} return retCode;} public String snippet() { String result; StringBuffer buf=new StringBuffer(); if(last < 0) last=0; buf.setLength(0); int i; for(i=last; i < items.size(); i++) { buf.append('\n'); buf.append((String) items.elementAt(i));} last=i; result=buf.toString(); buf.setLength(0); return result;} public String popMessage() { String retCodes; retCodes=(String) items.elementAt(0); items.removeElementAt(0); return retCodes;} public void republishStatus(String status,String usrName) { if(status !=null && status.length() > 0) items.addElement(Totalic.MG_STATUS+status+new Replacer().dlina(usrName.length())+usrName);} public void publishRename(String usrName,String againName) { if(usrName !=null && usrName.length() > 0 && againName !=null && againName.length() > 0) items.addElement(Totalic.MG_RENAME+new Replacer().dlina(usrName.length())+usrName+new Replacer().dlina(againName.length())+againName);} public void publishMessage(String usrMessage,String usrName) { if(usrMessage !=null && usrMessage.length() > 0) items.addElement(Totalic.MG_MSG+new Replacer().dlina(usrMessage.length())+usrMessage+new Replacer().dlina(usrName.length())+usrName);} public void retranslateMessage(String usrMessage,String usrName) { if(usrMessage !=null && usrMessage.length() > 0) items.addElement(Totalic.STOP+Totalic.MG_MSG+new Replacer().dlina(usrMessage.length())+usrMessage+new Replacer().dlina(usrName.length())+usrName);}} class Talking implements Runnable { private Object stop; private Connection upnect; private int srvPort; private String srvHost; private Thread starting; protected Reviewer rep; int toUpdate; LocalNotifications locMsg; ClientRecord delivered; LocalNotifications deliveryQueue; public Talking() { stop=null; upnect=null; locMsg=new LocalNotifications(); starting=new Thread(this); starting.start(); locMsg.addMessage("Client connect in progress.."); toUpdate=2; deliveryQueue=new LocalNotifications();} public void setObserver(Reviewer observer) { rep=observer;} public String[] getIncomings() { return rep.getImportedMessages();} public String[] getContacts() { return rep.getRetrievedContacts();} public void submit(ClientRecord up) { if(delivered==null) delivered=new ClientRecord(up,true); if(delivered.differentName(up)) deliveryQueue.publishRename(delivered.getUsrName(),up.getUsrName()); if(delivered.differentMessage(up)) { deliveryQueue.publishMessage(up.getUsrMessage(),up.getUsrName()); rep.pushLocalMessage(up.getUsrName()+Totalic.DEF_SPLIT+up.getUsrMessage());} if(delivered.differentStatus(up)) deliveryQueue.republishStatus(up.getUsrStatus(),up.getUsrName()); delivered=up;} public void leave() { stop=new Integer(3); locMsg.addMessage("Client connect has stopped."); toUpdate=3;} private void openChannel() { int fail=0; java.net.Socket s1=null; try { s1=new java.net.Socket(srvHost,srvPort);} catch(Throwable e) { e.getMessage(); fail+=1;} if(!new Replacer().writeRead(Totalic.MG_START,Totalic.MG_REPLY,s1)) fail+=2; if(fail==0) { upnect=new Connection(s1); toUpdate=1;} else { reportConnectionFailure(); try { s1.getInputStream().close(); s1.getOutputStream().close(); s1.close();} catch(Throwable e) { e.getMessage();}}} private void reportConnectionFailure() { locMsg.addMessage("Can not connect to server."); toUpdate=4;} public void run() { while(stop==null) { if(srvPort > 0 && srvHost !=null && srvHost.length() > 0 && upnect==null) openChannel(); if(upnect !=null) { if(deliveryQueue.hasPending()) { String toDeliver=deliveryQueue.popMessage(); boolean z=toDeliver.startsWith(Totalic.STOP); if(z) toDeliver=toDeliver.substring(1); if(!upnect.writeRead(toDeliver,Totalic.MG_REPLY)) { locMsg.addMessage("delivery failed:"+toDeliver); if(toDeliver.startsWith(Totalic.MG_RENAME)) delivered.usrName=toDeliver.substring(toDeliver.indexOf(']')+1,toDeliver.lastIndexOf('['));} else if(!z) explain(delivered !=null ? delivered.usrName : "",toDeliver);} processRestOfMessages(); try { processContacts(upnect); toUpdate=7;} catch(java.io.IOException e) { e.getMessage();} try { String un=""; if(delivered !=null && delivered.usrName !=null) un=delivered.usrName; processMessages(upnect,un); toUpdate=8;} catch(java.io.IOException e) { e.getMessage();}} try { Thread.sleep(Totalic.DEF_TIMEOUT);} catch(Throwable e) { e.getMessage();}} if(upnect !=null) { upnect.closed(); upnect=null;}} private void processRestOfMessages() { String[] notSent=rep.getLocalMesagesNotSent(); if(notSent !=null && notSent.length > 0) { for(int i=0; i < notSent.length; i++) { String msg=notSent[i]; int pos=msg.indexOf(Totalic.DEF_SPLIT); deliveryQueue.retranslateMessage(msg.substring(pos+Totalic.DEF_SPLIT.length()),msg.substring(0,pos));}}} private void processMessages(Connection c1,String usrName) throws java.io.IOException { int fail=0; if(!c1.writeRead(Totalic.MG_LISTEN+new Replacer().dlina(usrName.length())+usrName,Totalic.MG_LISTEN)) fail+=1; if(fail==0) { int incomingNum=new Replacer().fetchDlina(c1); while(incomingNum--> 0) { int length=new Replacer().fetchDlina(c1); String buf=""; while(length--> 0) buf+=(char) c1.readByte(); rep.pushImportedMessage(buf);}} c1.writeAnswer(fail,Totalic.MG_REPLY);} private void processContacts(Connection c1) throws java.io.IOException { int fail=0; if(!c1.writeRead(Totalic.MG_TOTAL,Totalic.MG_TOTAL)) fail+=1; if(fail==0) { rep.initContactRetrieval(); int contactsNum=new Replacer().fetchDlina(c1); while(contactsNum--> 0) { int length=new Replacer().fetchDlina(c1); String buf=""; while(length--> 0) buf+=(char) c1.readByte(); rep.pushRetrievedContact(buf);}} c1.writeAnswer(fail,Totalic.MG_REPLY);} private void explain(String username,String toDeliver) { if(toDeliver.startsWith(Totalic.MG_MSG)) locMsg.addMessage(username+Totalic.DEF_SPLIT+toDeliver.substring(toDeliver.indexOf(']')+1,toDeliver.lastIndexOf('['))); else if(toDeliver.startsWith(Totalic.MG_STATUS)) locMsg.addMessage(username+Totalic.DEF_STT+toDeliver.substring(Totalic.MG_STATUS.length(),toDeliver.indexOf('['))); else if(toDeliver.startsWith(Totalic.MG_RENAME)) { String first=toDeliver.substring(toDeliver.indexOf(']')+1,toDeliver.lastIndexOf('[')); String last=toDeliver.substring(toDeliver.lastIndexOf(']')+1); if(!first.equals(last)) locMsg.addMessage(first+Totalic.DEF_REN+last);} toUpdate=7;} public void assignServer(String host,int port) { srvPort=port; srvHost=host;}} class Replacer { public Replacer() {} public String dlina(int length) { String dl="["+length+"]"; return dl;} public int fetchDlina(Connection c1) { int result=0; byte b1=(byte) 'a'; try { b1=c1.readByte();} catch(java.io.IOException e) { e.getMessage();} String src=""; if((char) b1=='[') { while((char) b1 !=']') { try { b1=c1.readByte();} catch(java.io.IOException e) { e.getMessage();} src+=(char) b1;} if(src.endsWith("]")) { src=src.replace(']',' ').trim(); result=Integer.parseInt(src);} else result=-1;} else result=-1; return result;} public void writeAnswer(int fail,String answer,Connection c1) { byte stdOk[]=new byte[answer.length()]; for(int i=0; i < stdOk.length; i++) stdOk[i]=(byte) answer.charAt(fail==0 ? i : stdOk.length-i-1); c1.writeBytes(stdOk);} public boolean readWrite(String check,String answer,java.net.Socket s1) { int fail=0; int rr[]=new int[check.length()]; for(int i=0; i < rr.length; i++) try { rr[i]=s1.getInputStream().read();} catch(Throwable e) { e.getMessage(); fail=1;} for(int i=0; i < rr.length && fail==0; i++) if(rr[i] !=(int) check.charAt(i)) fail=2; byte stdOk[]=new byte[answer.length()]; for(int i=0; i < stdOk.length; i++) stdOk[i]=(byte) answer.charAt(fail==0 ? i : stdOk.length-i-1); try { s1.getOutputStream().write(stdOk); s1.getOutputStream().flush();} catch(Throwable e) { e.getMessage(); fail=3;} return fail==0;} public boolean writeRead(String req,String answ,java.net.Socket s1) { byte rr[]=new byte[req.length()]; for(int i=0; i < rr.length; i++) rr[i]=(byte) req.charAt(i); int fail=0; try { s1.getOutputStream().write(rr); s1.getOutputStream().flush();} catch(Throwable e) { e.getMessage(); fail=2;} int stdOk[]=new int[answ.length()]; for(int i=0; i < stdOk.length; i++) try { stdOk[i]=s1.getInputStream().read();} catch(Throwable e) { e.getMessage(); fail=1;} for(int i=0; i < stdOk.length && fail==0; i++) if(stdOk[i] !=(int) answ.charAt(i)) fail=3; return fail==0;}} class ClientRecord { private Vector reveals; String usrName; String usrStatus; String usrMessage; boolean another; public ClientRecord(String name) { this.usrName=name;} public ClientRecord(String name,String status) { this.usrName=name; this.usrStatus=status;} public ClientRecord(String usrName,String usrStatus,String usrMessage) { this.usrName=usrName; this.usrStatus=usrStatus; this.usrMessage=usrMessage;} public void appendMessage(String item) { if(reveals==null) reveals=new Vector(); ObservableItem riv=new ObservableItem(item); if(!reveals.contains(riv)) reveals.addElement(riv);} public String[] extractMessages(String forName) { Vector res=new Vector(); if(reveals !=null) for(int i=0; i < reveals.size(); i++) { ObservableItem r=(ObservableItem) reveals.elementAt(i); String msg=r.extractFor(forName); if(msg !=null) res.addElement(usrName+Totalic.DEF_SPLIT+msg);} String[] total=new String[res.size()]; for(int i=0; i < res.size(); i++) total[i]=(String) res.elementAt(i); return total;} public String[] extractMessagesDisplayLocaly() { Vector res=new Vector(); if(reveals !=null) for(int i=0; i < reveals.size(); i++) { ObservableItem r=(ObservableItem) reveals.elementAt(i); String msg=r.extractDisplayLocaly(); if(msg !=null) res.addElement(usrName+Totalic.DEF_SPLIT+msg);} String[] total=new String[res.size()]; for(int i=0; i < res.size(); i++) total[i]=(String) res.elementAt(i); return total;} public String[] extractMessagesRetranslateLocaly() { Vector res=new Vector(); if(reveals !=null) for(int i=0; i < reveals.size(); i++) { ObservableItem r=(ObservableItem) reveals.elementAt(i); String msg=r.extractRetranslateLocaly(); if(msg !=null) res.addElement(usrName+Totalic.DEF_SPLIT+msg);} String[] total=new String[res.size()]; for(int i=0; i < res.size(); i++) total[i]=(String) res.elementAt(i); return total;} public boolean differentMessage(ClientRecord delivered) { boolean retCode=delivered.usrMessage !=null && delivered.usrMessage.length() > 0; return retCode;} public boolean differentName(ClientRecord delivered) { if(another) return true; if(usrName !=null) return !usrName.equals(delivered.usrName); return usrName !=delivered.usrName;} public boolean differentStatus(ClientRecord delivered) { if(another) return true; if(usrStatus !=null) return !usrStatus.equals(delivered.usrStatus); return usrStatus !=delivered.usrStatus;} public ClientRecord(ClientRecord up,boolean b) { this.usrName=up.usrName; this.usrStatus=up.usrStatus; this.usrMessage=up.usrMessage; this.another=true;} public String getUsrName() { return usrName;} public String getUsrStatus() { return usrStatus;} public String getUsrMessage() { return usrMessage;}} class MsgParser { String type; String lastName; String status; String name; String message; public MsgParser(String type) { this.type=type; this.lastName=""; this.status=""; this.name=""; this.message="";} public MsgParser(String type,String lastName,String name) { this.type=type; this.lastName=lastName; this.status=""; this.name=name; this.message="";} public boolean statusNot(String reg) { boolean rawn=status.equalsIgnoreCase(reg); return !rawn;} public void feedStatusChar(char c) { status+=c;} public void feedNameChar(char c) { name+=c;} public void feedLastNameChar(char c) { lastName+=c;} public void feedMessageChar(char c) { message+=c;} public String getLastName() { return lastName;} public String getStatus() { return status;} public String getName() { return name;} public String getMessage() { return message;}} class Reviewer { private Vector scribe; private Vector clientSideContacts; private ContactList serverSideContacts; public Reviewer() { scribe=new Vector(); clientSideContacts=new Vector(); serverSideContacts=new ContactList();} public void reinitServer() { serverSideContacts.clearContactList();} public void pushServerMessage(ClientRecord record,String msg) { record.appendMessage(msg);} public boolean serverHasClient(String skel) { return serverSideContacts.hasContact(skel);} public ClientRecord serverCreateClientRename(String lastName,String name) { ClientRecord record=null; if(serverHasClient(lastName)) { record=serverSideContacts.getContact(lastName); serverSideContacts.deleteContact(lastName); record.usrName=name;} else record=new ClientRecord(name); serverSideContacts.addContact(name,record); return record;} public String[] getClients() { String[] total=new String[serverSideContacts.contactsNum()]; int pos=0; java.util.Enumeration en=serverSideContacts.names(); while(en.hasMoreElements()) { ClientRecord record=serverSideContacts.getContact((String) en.nextElement()); total[pos++]=record.usrName+(record.usrStatus !=null ? Totalic.DEF_SPLIT+record.usrStatus : "");} return total;} public void pushLocalMessage(String local) { ObservableItem item=new ObservableItem(local,ObservableItem.TP_LOCAL); if(!scribe.contains(item)) scribe.addElement(item);} public void pushImportedMessage(String acquired) { ObservableItem item=new ObservableItem(acquired,ObservableItem.TP_IMPORTED); if(!scribe.contains(item)) scribe.addElement(item);} void log(String msg,String[] arr) { System.out.println(msg); for(int i=0; i < arr.length; i++) System.out.println(arr[i]);} public String[] getServerMessages(String forName) { Vector result=new Vector(); java.util.Enumeration en=serverSideContacts.names(); while(en.hasMoreElements()) { ClientRecord record=serverSideContacts.getContact((String) en.nextElement()); if(!forName.equals(record.getUsrName())) { String[] msgs=record.extractMessages(forName); if(msgs !=null && msgs.length > 0) for(int k=0; k < msgs.length; k++) if(!msgs[k].startsWith(forName) && !scribe.contains(ObservableItem.search(msgs[k])) && !result.contains(msgs[k])) result.addElement(msgs[k]);}} ObservableItem item; for(int i=0; i < scribe.size(); i++) { item=(ObservableItem) scribe.elementAt(i); String msgs=item.extractMessage(forName); if(msgs !=null && !msgs.startsWith(forName) && !result.contains(msgs)) result.addElement(msgs);} String[] retCode=new String[result.size()]; for(int i=0; i < retCode.length; i++) retCode[i]=(String) result.elementAt(i); return retCode;} public String[] getImportedMessages() { Vector result=new Vector(); java.util.Enumeration en=serverSideContacts.names(); while(en.hasMoreElements()) { ClientRecord record=serverSideContacts.getContact((String) en.nextElement()); String[] msgs=record.extractMessagesDisplayLocaly(); if(msgs !=null && msgs.length > 0) for(int k=0; k < msgs.length; k++) if(!scribe.contains(ObservableItem.search(msgs[k])) && !result.contains(msgs[k])) result.addElement(msgs[k]);} ObservableItem item; for(int i=0; i < scribe.size(); i++) { item=(ObservableItem) scribe.elementAt(i); if(item.isImported() && !item.isDone()) { if(!result.contains(item.info)) result.addElement(item.info); item.markRead();}} String[] retCode=new String[result.size()]; for(int i=0; i < retCode.length; i++) retCode[i]=(String) result.elementAt(i); return retCode;} public String[] getLocalMesagesNotSent() { Vector result=new Vector(); java.util.Enumeration en=serverSideContacts.names(); while(en.hasMoreElements()) { ClientRecord record=serverSideContacts.getContact((String) en.nextElement()); String[] msgs=record.extractMessagesRetranslateLocaly(); if(msgs !=null && msgs.length > 0) for(int k=0; k < msgs.length; k++) if(!scribe.contains(ObservableItem.search(msgs[k])) && !result.contains(msgs[k])) result.addElement(msgs[k]);} String[] retCode=new String[result.size()]; for(int i=0; i < retCode.length; i++) retCode[i]=(String) result.elementAt(i); return retCode;} public String[] getRetrievedContacts() { String[] total=new String[clientSideContacts.size()]; for(int i=0; i < total.length; i++) total[i]=(String) clientSideContacts.elementAt(i); return total;} public void initContactRetrieval() { clientSideContacts.removeAllElements();} public void pushRetrievedContact(String cnct) { clientSideContacts.addElement(cnct);}} class ContactList { private Vector names; private Vector records; public ContactList() { names=new Vector(); records=new Vector();} public void clearContactList() { names.removeAllElements(); records.removeAllElements();} public void addContact(String name,ClientRecord record) { names.addElement(name); records.addElement(record);} public Enumeration names() { return names.elements();} public int contactsNum() { return names.size();} public void deleteContact(String lastName) { int pos=-1; for(int i=0; pos < 0 && i < names.size(); i++) if(((String) names.elementAt(i)).equals(lastName)) pos=i; names.removeElementAt(pos); records.removeElementAt(pos);} public ClientRecord getContact(String lastName) { int pos=-1; for(int i=0; pos < 0 && i < names.size(); i++) if(((String) names.elementAt(i)).equals(lastName)) pos=i; ClientRecord record=(ClientRecord) records.elementAt(pos); return record;} public boolean hasContact(String skel) { return names.contains(skel);}}
