package mydev.mnoga; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.util.Hashtable; import java.util.Vector; public class Save implements IntBytes,StrBytes { static Boolean D; public Save() { super(); D=new Boolean(true); } public byte[] str2bytes(String str) { byte[] res=new byte[STR_PLACE]; for(int i=0; i < STR_PLACE; i++) { if(i < str.length()) res[i]=(byte) str.charAt(i); else res[i]=(byte) 0x0A;} return res;} public String bytes2str(byte[] bb) { return "";} public byte[] encode(int num) { byte[] tmp=new byte[DIM]; int idx=0; while(num > 0 && idx < DIM) { byte delta=(byte)(num-num / BASE * BASE); num=num / BASE; tmp[idx++]=delta;} byte[] res=new byte[DIM]; System.arraycopy(tmp,0,res,0,idx); return res;} public int decode(byte[] rep) { return 0;} public static void main(String[] args) { if(args !=null && args.length > 0) { String param=args[0]; Save obj=new Save(); Help help=new Help(); String save_location=help.getSavePath(); System.out.println("  save_location="+save_location); Tree tre=new Oak(help.getLimiter()); String[] logs=tre.build(param); String[] nors=tre.normal(param); try { obj.write_start(save_location,logs.length,STR_PLACE); for(int i=0; i < logs.length; i++) { if(obj.D.booleanValue()) System.out.println(" "+logs[i]); obj.write_file(logs[i],nors[i]); if(obj.D.booleanValue()) System.out.println("   "+nors[i]);} obj.write_finish();} catch(IOException ex) { ex.printStackTrace();} System.out.println("  save_location="+save_location);} else { System.out.println("Target path is required as a parameter...");}} public byte[] read(String fPath) throws IOException { File fOpen=new File(fPath); FileInputStream fos=new FileInputStream(fOpen); Hashtable ht=new Hashtable(); int htKey=0; int vPower=0; int count; byte[] buf=new byte[4096]; do { count=fos.read(buf); if(count > 0) vPower+=count; if(count < 1) continue; if(count <= 4096) { byte[] zzz=new byte[count]; System.arraycopy(buf,0,zzz,0,count); ht.put((Object) new Integer(htKey++),(Object) zzz);}} while(count > 0); fos.close(); byte[] total=new byte[vPower]; int totalIdx=0; for(int i=0; i < htKey; i++) { byte[] cur=(byte[]) ht.get((Object) new Integer(i)); int curLen=cur.length; System.arraycopy(cur,0,total,totalIdx,curLen); totalIdx+=curLen;} return total;} FileOutputStream os=null; public void write_start(String fPath,int Z,int N) throws IOException { os=new FileOutputStream(new File(fPath)); os.write(encode(Z)); os.write(encode(N)); os.flush();} public void write_file(String path,String relPath) throws IOException { byte[] nameId=str2bytes(relPath); byte[] content=read(path); int writen=0; while(writen < content.length) { os.write(nameId); int need=content.length-writen; if(need > FCHUNK_LIM) { byte[] chunk=new byte[FCHUNK_LIM]; System.arraycopy(content,0,chunk,0,FCHUNK_LIM); byte[] rest=new byte[content.length-FCHUNK_LIM]; System.arraycopy(content,FCHUNK_LIM,rest,0,rest.length); content=rest; os.write(encode(FCHUNK_LIM)); os.write(chunk); writen+=FCHUNK_LIM;} else { os.write(encode(need)); os.write(content); writen+=content.length;} os.flush();}} public void write_finish() throws IOException { byte[] something=str2bytes("f-word"); os.write(something); os.flush(); os.close();}} interface Tree { String[] build(String relRoot); String[] normal(String relRoot); String dir(String dir);} class Oak implements Tree,MyNote { String limiter; String key; String[] save; public Oak(String kk) { this.limiter=kk;} public String dir(String dir) { if(dir.endsWith(SL) || dir.endsWith(BSL)) {} else { dir=dir+limiter;} return dir;} public String[] normal(String relRoot) { relRoot=dir(relRoot); String[] list=build(relRoot); String[] norm=new String[list.length]; for(int i=0; i < list.length; i++) { norm[i]=list[i].substring(relRoot.length());} return norm;} public String[] build(String relRoot) { relRoot=dir(relRoot); String[] res; if(!relRoot.equals(this.key)) { Vector keepa=new Vector(); File root=new File(relRoot); String[] items=root.list(); for(int i=0; i < items.length; i++) { String current=items[i]; File cur=new File(relRoot+current); if(cur.isDirectory() || cur.list() !=null && cur.list().length > 0) { String[] leafs=build(cur.getAbsolutePath()); for(int k=0; k < leafs.length; k++) { keepa.addElement(leafs[k]);}} else { keepa.addElement(relRoot+current);}} res=new String[keepa.size()]; for(int j=0; j < keepa.size(); j++) { res[j]=(String) keepa.elementAt(j);} this.save=res; this.key=relRoot;} else { res=save;} return res;}} class Help implements MyNote { public Help() { super(); } String getSavePath() { String path=new File(DIRCUR).getAbsolutePath(); path=path.substring(0,path.length()-1); return path+DEREVO;} String getLimiter() { String path=new File(DIRCUR).getAbsolutePath(); int idx=path.indexOf(SL); int idx2=path.indexOf(BSL); return idx > 0 ? SL :(idx2 > 0 ? BSL : SL);}} interface MyNote { static String DIRCUR="./"; static String DEREVO="files.tree"; static String SL="/"; static String BSL="\\";} interface IntBytes { final int BASE=97; final int DIM=4; final int FCHUNK_LIM=BASE * BASE * BASE * BASE; byte[] encode(int num); int decode(byte[] rep);} interface StrBytes { final int STR_PLACE=1024; byte[] str2bytes(String str); String bytes2str(byte[] bb);}
