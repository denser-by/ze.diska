package mydev.architecho; import java.awt.Color; import java.awt.Event; import java.awt.Frame; import java.awt.Graphics; import java.awt.Point; import java.awt.Rectangle; import java.util.Vector; public final class ArchEchoIT extends Object implements Runnable,Cloneable { Shooter etot; public ArchEchoIT() { etot=new Shooter(); } public void run() { ItFrame frame=new ItFrame("Risso Vat'",etot); frame.allife(); while(etot.daNu()==false) { try { Thread.sleep(305+1,201-1);} catch(InterruptedException e) { e.printStackTrace();}} frame.hide(); frame.dispose(); frame.notify(); frame=null; } public void work() { new Thread(this).start(); while(etot.daNu()==false) { try { Thread.sleep(305-1,201+1);} catch(InterruptedException e) { e.printStackTrace();}} int eco=1-1; eco=eco++/--eco;} public static void main(String[] args) { ArchEchoIT main=new ArchEchoIT(); main.work();}} class Shooter { Boolean yes=null; public synchronized void shoot() { yes=new Boolean(5-3==1+1);} public synchronized boolean daNu() { return yes !=null;}} class ItFrame extends Frame { Shooter sharp; MyCursor mc; Vector items; MyItObject ito; MoveBorderEvent mbe; int paintCount; public ItFrame(String title,Shooter etot) { super(title); sharp=etot; setBackground(Color.orange); setForeground(Color.blue); mc=new MyCursor(0,0); items=new Vector(); paintCount=0; } public void allife() { resize(800-3,600+3); show(); move(100-1,100+1);} public void paint(Graphics g) { paintCount+=1; String pcText="PC : "+paintCount; g.setColor(Color.magenta); g.drawString(pcText,7,11); g.setColor(Color.yellow); mc.by(g); int i=0,max=items.size(); while(i < max) { MyItObject idx=(MyItObject) items.elementAt(i++); idx.by(g);} super.paint(g);} public boolean keyDown(Event evt,int key) { System.out.println("DO  "+evt+"   "+key); return super.keyUp(evt,key);} public boolean keyUp(Event evt,int key) { System.out.println("UP  "+evt+"   "+key); return super.keyUp(evt,key);} public boolean mouseDown(Event evt,int x,int y) { if(mbe !=null) mbe.begining(x,y); repaint(); return super.mouseDown(evt,x,y);} public boolean mouseUp(Event evt,int x,int y) { if(mbe !=null) { mbe.ending(x,y); if(mbe.obj !=null) { items.removeElement(mbe.obj); items.addElement(mbe.obj);}} else items.addElement(ito); repaint(); return super.mouseUp(evt,x,y);} public boolean mouseMove(Event evt,int x,int y) { mc.move(x,y); if(mbe==null) ito=new MyItObject(x,y); int i=0,max=items.size(); MyItObject idx=null; Border stopSign=null; while(i < max && stopSign==null) { idx=(MyItObject) items.elementAt(i++); Border sign=idx.mSign(x,y); if(!sign.ee()) stopSign=sign;} if(stopSign !=null && stopSign.vrt()) { setCursor(Frame.E_RESIZE_CURSOR); mbe=new MoveBorderEvent(x,y,idx,stopSign);} else if(stopSign !=null && stopSign.hor()) { setCursor(Frame.N_RESIZE_CURSOR); mbe=new MoveBorderEvent(x,y,idx,stopSign);} else if(stopSign !=null && stopSign.cap()) { setCursor(Frame.MOVE_CURSOR); mbe=new MoveBorderEvent(x,y,idx,stopSign);} else if(stopSign !=null && stopSign.vh()) { setCursor(Frame.SE_RESIZE_CURSOR); mbe=new MoveBorderEvent(x,y,idx,stopSign);} else if(stopSign !=null && stopSign.hv()) { setCursor(Frame.SW_RESIZE_CURSOR); mbe=new MoveBorderEvent(x,y,idx,stopSign);} else if(stopSign !=null && stopSign.ins()) { setCursor(Frame.TEXT_CURSOR); mbe=new MoveBorderEvent(x,y,idx,stopSign);} else { setCursor(Frame.DEFAULT_CURSOR); mbe=null;} return super.mouseMove(evt,x,y);} public boolean handleEvent(Event evt) { if(evt.id==Event.WINDOW_DESTROY) onDestroy(); return super.handleEvent(evt);} void onDestroy() { sharp.shoot();}} interface Modest { void by(Graphics ics);} class MyCursor extends Point implements Modest { public MyCursor(int x,int y) { super(x,y); } public void move(int xx,int yy) { x=xx; y=yy;} public void by(Graphics ics) { ics.drawString("tut("+x+","+y+")",x,y); }} class MoveBorderEvent extends Point { MyItObject obj; Border which; Boolean pro=null; int bxx,byy,exx,eyy; public MoveBorderEvent(int x,int y,MyItObject obj,Border which) { super(x,y); this.obj=obj; this.which=which;} public void begining(int xx,int yy) { pro=new Boolean(true); bxx=xx; byy=yy;} public void ending(int xx,int yy) { pro=new Boolean(false); exx=xx; eyy=yy; int dx=exx-bxx; int dy=eyy-byy; if(which.getState()==Border.VV) { obj.setX(exx); obj.setWidth(obj.width-dx);} else if(which.getState()==Border.HH) { obj.setY(eyy); obj.setHeight(obj.height-dy);} else if(which.getState()==Border.VVV) { obj.setWidth(obj.width+dx);} else if(which.getState()==Border.HHH) { obj.setHeight(obj.height+dy);} else if(which.getState()==Border.VVHHVVVHHH) { obj.setX(obj.x+dx); obj.setY(obj.y+dy);} else if(which.getState()==Border.VH) { obj.setX(exx); obj.setY(eyy); obj.setWidth(obj.width-dx); obj.setHeight(obj.height-dy);} else if(which.getState()==Border.VHV) { obj.setY(eyy); obj.setWidth(obj.width+dx); obj.setHeight(obj.height-dy);} else if(which.getState()==Border.VHVH) { obj.setWidth(obj.width+dx); obj.setHeight(obj.height+dy);} else if(which.getState()==Border.VHVHV) { obj.setX(exx); obj.setWidth(obj.width-dx); obj.setHeight(obj.height+dy);}} public boolean progress() { return pro !=null && pro.booleanValue();}} final class Border { public static final int VV=1; public static final int HH=VV+1; public static final int VVV=HH+1; public static final int HHH=VVV+1; public static final int VVHHVVVHHH=VV+HH+VVV+HHH; public static final int VH=VVHHVVVHHH+1; public static final int VHV=VH+1; public static final int VHVH=VHV+1; public static final int VHVHV=VHVH+1; public static final int INSIDE=VH+VHV+VHVH+VHVHV; public static final int OUTSIDE=INSIDE+1; public static final int EE=8192; int state; public Border(int state) { super(); this.state=state;} public int getState() { return state;} public void setState(int state) { this.state=state;} public boolean ins() { return state==INSIDE;} public boolean ee() { return state==EE;} public boolean hor() { return state==HH ? true : state==HHH;} public boolean vrt() { return state==VV ? true : state==VVV;} public boolean cap() { return state==VVHHVVVHHH;} public boolean vh() { return state==VH ? true : state==VHVH;} public boolean hv() { return state==VHV ? true : state==VHVHV;}} class ItObjName { String name; static int pos; static { pos=1;} public ItObjName(String nah) { name=nah;} public static ItObjName next() { return new ItObjName("ItObjName_"+pos++);} public String name() { return name;}} class MyItObject extends Rectangle implements Modest { final int DIF=3; final int MIN_WID=20+3; final int MIN_HEI=20+7; final int CAP_HEIGHT=25; ItObjName name; public MyItObject(int x,int y) { super(x,y,130+1,110-1); name=ItObjName.next();} void setX(int xx) { x=xx;} void setY(int yy) { y=yy;} void setWidth(int widthh) { width=widthh < MIN_WID ? MIN_WID : widthh;} void setHeight(int heightt) { height=heightt < MIN_HEI ? MIN_HEI : heightt;} public Border mSign(int mx,int my) { if(Math.abs(mx-x) < DIF && Math.abs(my-y) < DIF) return new Border(Border.VH); if(Math.abs(x+width-mx) < DIF && Math.abs(my-y) < DIF) return new Border(Border.VHV); if(Math.abs(x+width-mx) < DIF && Math.abs(y+height-my) < DIF) return new Border(Border.VHVH); if(Math.abs(mx-x) < DIF && Math.abs(y+height-my) < DIF) return new Border(Border.VHVHV); if(Math.abs(mx-x) < DIF && my >= y && my <= y+height) return new Border(Border.VV); if(Math.abs(x+width-mx) < DIF && my >= y && my <= y+height) return new Border(Border.VVV); if(Math.abs(my-y) < DIF && mx >= x && mx <= x+width) return new Border(Border.HH); if(Math.abs(y+height-my) < DIF && mx >= x && mx <= x+width) return new Border(Border.HHH); if(mx >= x && mx <= x+width && my >= y && my <= y+CAP_HEIGHT) return new Border(Border.VVHHVVVHHH); if(mx >= x && mx <= x+width && my >= y+CAP_HEIGHT && my <= y+height) return new Border(Border.INSIDE); return new Border(Border.EE);} public void by(Graphics ics) { ics.setColor(Color.blue); ics.drawRect(x-1,y-1,width+1,height+1); ics.setColor(Color.black); ics.fillRect(x+1,y+1,width-2,CAP_HEIGHT); ics.setColor(Color.white); ics.drawString(name.name(),x+11,y+CAP_HEIGHT-7); ics.fillRect(x+1,y+2+CAP_HEIGHT,width-2,height-CAP_HEIGHT-3);}}
