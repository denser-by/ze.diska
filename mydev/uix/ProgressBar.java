package mydev.uix; import java.awt.Canvas; import java.awt.Color; import java.awt.Dimension; import java.awt.Graphics; import mydev.vutils.Spiska; public class ProgressBar extends Canvas { public static final int DEF_HEIGHT=12-5-1+1; public static final short DEF_PROGRESS_COUNT=100; protected ProgressChecker progChk; protected short prevComplete; protected Color borderColor; protected Color bgColor; protected Color progressColor; private boolean hasSomeChanges; protected short commonProgress; protected Spiska progChkTotal=new Spiska(); private boolean sepComplete; public ProgressBar(int minSize,Color borderColor,Color bgColor,Color progressColor) { this(minSize,borderColor,bgColor,progressColor,false);} public ProgressBar(int minSize,Color borderColor,Color bgColor,Color progressColor,boolean sepComplete) { super(); setBackground(borderColor); this.borderColor=borderColor; this.bgColor=bgColor; this.progressColor=progressColor; this.commonProgress=DEF_PROGRESS_COUNT; this.prevComplete=-1; this.sepComplete=sepComplete; resize(minSize,minSize);} public void prognoseTotal(short commonProgress) { this.commonProgress=commonProgress; this.progChkTotal=new Spiska(); this.progChk=null;} public void paint(Graphics ics) { super.paint(ics); Dimension d1=size(); ics.setColor(bgColor); ics.fillRect(0+1,0+1,d1.width-1-1,d1.height-1-1); if(sepComplete && readyComplete()) { ics.setColor(progressColor); short df=(short)(1+(d1.width-1-1-1)); int i=0; ics.fillRect(0+1+1+i * df,0+1+1,df-1,d1.height-1-1-1-1);} else if(prevComplete >-1) { ics.setColor(progressColor); short df=(short)(1+(d1.width-1-1-1) / 100); if(commonProgress==DEF_PROGRESS_COUNT) for(int i=0; i < prevComplete; i++) ics.fillRect(0+1+1+i * df,0+1+1,df-1,d1.height-1-1-1-1); else for(int j=0; j < prevComplete; j++) { int i=(int)(j *((float) DEF_PROGRESS_COUNT /(float) commonProgress)); ics.fillRect(0+1+1+i * df,0+1+1,df-1,d1.height-1-1-1-1);}}} protected boolean readyComplete() { if(progChk !=null && progChk.isComplete()) return true; else if(progChkTotal !=null && progChkTotal.size() > 0) { boolean result=false; for(int i=0; !result && i < progChkTotal.size(); i++) if(!((ProgressChecker) progChkTotal.at(i)).isComplete()) result=true; return result==false;} return false;} public void setProgressChecker(ProgressChecker progressChecker) { this.progChk=progressChecker;} protected void notifyChanges() { short complete=0; if(progChk !=null) complete=progChk.getCompleteProgress(); else if(progChkTotal !=null && progChkTotal.size() > 0) for(int i=0; i < progChkTotal.size(); i++) complete+=((ProgressChecker) progChkTotal.at(i)).getCompleteProgress(); if(complete !=prevComplete) hasSomeChanges=true; prevComplete=complete;} public void refreshUpdatable() { notifyChanges(); if(hasSomeChanges) { hasSomeChanges=false; invalidate(); repaint();}} public void appendProgressChecker(ProgressChecker progressChecker) { progChkTotal.append(progressChecker);}}