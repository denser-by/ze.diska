package mydev.uix; import java.awt.Color; import mydev.about.Canvas; import mydev.about.Paint; import mydev.about.Point2D; import mydev.about.Rectangle2D; import mydev.vutils.Queue; public class ProgressBar extends CommonCanvas { public static final int DEF_HEIGHT=12-5-1+1; public static final short DEF_PROGRESS_COUNT=100; protected ProgressChecker progChk; protected short prevComplete; protected Color borderColor; protected Color bgColor; protected Color progressColor; protected short commonProgress; protected Queue progChkTotal=new Queue(); private boolean sepComplete; public ProgressBar(int minSize,Color borderColor,Color bgColor,Color progressColor) { this(minSize,borderColor,bgColor,progressColor,false);} public ProgressBar(int minSize,Color borderColor,Color bgColor,Color progressColor,boolean sepComplete) { super(minSize,minSize,bgColor,borderColor); setBackground(bgColor); this.borderColor=borderColor; this.bgColor=bgColor; this.progressColor=progressColor; this.commonProgress=DEF_PROGRESS_COUNT; this.prevComplete=-1; this.sepComplete=sepComplete;} public void prognoseTotal(short commonProgress) { this.commonProgress=commonProgress; this.progChkTotal.clearQueue(); this.progChk=null; this.prevComplete=-1;} public void clearItems() { progChkTotal.clearQueue(); progChk=null; commonProgress=DEF_PROGRESS_COUNT; prevComplete=-1;} protected void drawItems(Canvas ics,Paint pn) { pn.setColor(progressColor); short df=(short)(1+(sCur.width-1-1-1)); int i=0; if(sepComplete && readyCompleteSingle()) { Rectangle2D rect=new Rectangle2D(new Point2D(0+1+1+i * df,0+1+1),df-1-1,sCur.height-1-1-1-1,progressColor.getRGB(),true); rect.toPen(ics,pn);} else if(sepComplete && readyCompleteTotal() && commonProgress==prevComplete) { Rectangle2D rect=new Rectangle2D(new Point2D(0+1+1+i * df,0+1+1),df-1-1,sCur.height-1-1-1-1,progressColor.getRGB(),true); rect.toPen(ics,pn);} else if(prevComplete >-1) { short dfi=(short)(df / DEF_PROGRESS_COUNT); short spsi=(short)(df-dfi * DEF_PROGRESS_COUNT); if(commonProgress==DEF_PROGRESS_COUNT) for(i=0; i < prevComplete; i++) { Rectangle2D rect=new Rectangle2D(new Point2D(0+1+1+i * dfi,0+1+1),dfi-1,sCur.height-1-1-1-1,progressColor.getRGB(),true); rect.toPen(ics,pn);} else for(int j=0; j < prevComplete; j++) { i=(int)(j *((float) DEF_PROGRESS_COUNT /(float) commonProgress)); Rectangle2D rect=new Rectangle2D(new Point2D(0+1+1+i * dfi,0+1+1),dfi-1,sCur.height-1-1-1-1,progressColor.getRGB(),true); rect.toPen(ics,pn);}}} protected boolean readyCompleteSingle() { if(progChk !=null && progChk.isComplete() && prevComplete <= DEF_PROGRESS_COUNT && !hasTotalProgress()) return true; return false;} private boolean hasTotalProgress() { return progChkTotal !=null && progChkTotal.sizeOfQueue() > 0;} protected boolean readyCompleteTotal() { if(hasTotalProgress() && prevComplete >= DEF_PROGRESS_COUNT) { boolean allComplete=true; Object[] queueRecordsArray=progChkTotal.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { ProgressChecker pc=(ProgressChecker) queueRecordsArray[i]; if(pc.isComplete()==false) return false;} return true;} return false;} public void setProgressChecker(ProgressChecker progressChecker) { this.progChk=progressChecker; this.prevComplete=-1;} protected void notifyChanges() { short complete=0; if(progChk !=null) complete=progChk.getCompleteProgress(); else if(hasTotalProgress()) { Object[] queueRecordsArray=progChkTotal.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { ProgressChecker pc=(ProgressChecker) queueRecordsArray[i]; complete+=pc.getCompleteProgress();}} if(complete !=prevComplete) markChanges(); prevComplete=complete;} public void refreshUpdatable() { notifyChanges(); if(hasChanges()) { clearChangesMark(); invalidate(); repaint();}} public void appendProgressChecker(ProgressChecker progressChecker) { progChkTotal.enqueueQueueRecord(progressChecker);}}