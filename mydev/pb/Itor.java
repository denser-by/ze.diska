package mydev.pb; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Canvas; import java.awt.Choice; import java.awt.Color; import java.awt.Dimension; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Graphics; import java.awt.Image; import java.awt.Label; import java.awt.List; import java.awt.Panel; import java.awt.TextArea; import java.awt.TextField; import java.awt.Toolkit; import java.awt.image.ColorModel; import java.awt.image.DirectColorModel; import java.awt.image.ImageConsumer; import java.awt.image.ImageObserver; import java.awt.image.MemoryImageSource; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Date; import java.util.Hashtable; import mydev.aaa.Sleeper; import mydev.vutils.AverageRec; import mydev.vutils.Data; import mydev.vutils.Ester; import mydev.vutils.ExpectHere; import mydev.vutils.Files; import mydev.vutils.Filter; import mydev.vutils.Karta; import mydev.vutils.Metr; import mydev.vutils.Spiska; import mydev.vutils.Stachko; import mydev.vutils.Stoish; import mydev.vutils.Time; public class Itor extends Frame { final static boolean D=false; final static boolean PROC=false; final static int DEF_INTEGRATION_TYPE=1+1; protected PathPanel pathPanel; protected LeftPanel leftPanel; protected RightPanel rightPanel; protected BcController bcCtrl; protected ImageBackupPreviewCanvas cv; protected LogPanel logPanel; private long lastTime=new Date().getTime(); private CommandQueue cq=new CommandQueue(); Command cmdEnable=null; public Itor() { super(); setLayout(new BorderLayout()); setBackground(Color.darkGray); add("North",pathPanel=new PathPanel()); add("West",leftPanel=new LeftPanel()); add("East",rightPanel=new RightPanel()); logPanel=new LogPanel(); add("Center",cv=new ImageBackupPreviewCanvas(logPanel)); add("South",logPanel); this.bcCtrl=new BcController(leftPanel,rightPanel,pathPanel);} public static void main(String[] args) { System.out.println(""+Toolkit.getDefaultToolkit().getScreenSize().toString()); Itor main=new Itor(); main.setTitle("Leaves Days Integrity"); main.show(); main.reMoveRnd(); main.resize(1024,768); if(args.length > 0) main.setInputFolder(args[0]); Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { main.refreshUpdatable(); sleeper.sleep(321);} main.hide(); main.dispose(); System.exit(1-1);} protected void reMoveRnd() { long x1=new Date().getTime(); if(x1 < 0) x1 *=-1; x1=10+3 *(x1 % 100); long y1=new Date().getTime(); if(y1 < 0) y1 *=-1; y1=10+2 *(y1 % 100); move((int) x1,(int) y1);} public void setInputFolder(String pathParam) { pathPanel.tfPath.setText(pathParam);} private void refreshUpdatable() { if(cq.hasSomeWork()) { Command cmd=cq.nextCurrent(); if(D) if(cq.current==3) System.out.println("nt =="); if(cmd.getId()==Command.ID_ENABLE_CTRLS) { cmdEnable=cmd;} else if(cmd.getId()==Command.ID_SCAN_LEFT && cq.hasConditionComplete(cmd)) { if(cq.hasRunAgainCondition(cmd)) { String path=pathPanel.tfPath.getText(); leftPanel.clearItems(); new Thread(new ScanLeft(leftPanel,path,logPanel,bcCtrl,cmd)).start(); if(D) System.out.println("Scan left scanning..."+cq.current);} else { if(D) System.out.println("Scan left pass"+cq.current);}} else if(cmd.getId()==Command.ID_SCAN_RIGHT && cq.hasConditionComplete(cmd)) { if(cq.hasRunAgainCondition(cmd)) { String path=pathPanel.tfPath.getText(); rightPanel.clearItems(); new Thread(new ScanRight(rightPanel,path,logPanel,bcCtrl,cmd)).start(); if(D) System.out.println("Scan right scanning..."+cq.current);} else { if(D) System.out.println("Scan right pass"+cq.current);}} else if(cmd.getId()==Command.ID_BACKUP_ALL_LEFT && cq.hasConditionComplete(cmd)) { bcCtrl.disableBackupCtrls(); rightPanel.clearItems(); new Thread(new BackupAllLeftTask(leftPanel,cv,bcCtrl,logPanel,cmd)).start(); if(D) System.out.println("Backup All left"+cq.current);} else if(cmd.getId()==Command.ID_VIEW_ALL_RIGHT && cq.hasConditionComplete(cmd)) { bcCtrl.disableBackupCtrls(); new Thread(new ViewAllRightTask(rightPanel,cv,logPanel,bcCtrl,cmd)).start(); if(D) System.out.println("View All right"+cq.current);} else if(cmd.getId()==Command.ID_DELETE_ALL_RIGHT && cq.hasConditionComplete(cmd)) { bcCtrl.disableBackupCtrls(); new Thread(new EraseAllRightTask(rightPanel,logPanel,bcCtrl,cmd)).start(); if(D) System.out.println("Delete All right"+cq.current);} else if(cmd.getId()==Command.ID_INTEGRATE_ALL_RIGHT && cq.hasConditionComplete(cmd)) { bcCtrl.disableBackupCtrls(); String path=pathPanel.tfPath.getText(); int type=Itor.DEF_INTEGRATION_TYPE; new Thread(new IntegrateAllRightTask(leftPanel,rightPanel,cv,logPanel,bcCtrl,type,path,cmd)).start(); if(D) System.out.println("Integrate All right"+cq.current);} else { if(D) System.out.println("Wait for condition completeness."+cmd+" "+cq+" "+cq.current); cq.rollbackCurrent();}} if(cmdEnable !=null && cmdEnable.getId()==Command.ID_ENABLE_CTRLS) { if(cmdEnable.isComplete()) { bcCtrl.enableBackupCtrls(); cmdEnable=null;}} leftPanel.updateOnUiThread(); rightPanel.updateOnUiThread();} public boolean handleEvent(Event et) { Command c1; Command c2; Command c3; Command c4; Command c5; if(et.id==Event.WINDOW_DESTROY) WorkingHolder.working=false; if(et.id==Event.ACTION_EVENT && et.target==this.pathPanel.btScan) { bcCtrl.disableBackupCtrls(); cq.push(c1=Command.create(Command.ID_SCAN_LEFT,null)); cq.push(c2=Command.create(Command.ID_SCAN_RIGHT,null)); Spiska complete=createComplete(c1,c2); cq.push(Command.createComposite(Command.ID_ENABLE_CTRLS,complete)); if(PROC) updateInfo(new Date().getTime());} if(et.id==Event.ACTION_EVENT && et.target==this.leftPanel.getBackupBtn()) { bcCtrl.disableBackupCtrls(); cq.push(c1=Command.create(Command.ID_SCAN_LEFT,null)); cq.push(c2=Command.create(Command.ID_BACKUP_ALL_LEFT,c1)); cq.push(c3=Command.create(Command.ID_SCAN_RIGHT,c2)); Spiska complete=createComplete(c1,c2,c3); cq.push(Command.createComposite(Command.ID_ENABLE_CTRLS,complete)); if(PROC) backupAllLeftImages();} if(et.id==Event.ACTION_EVENT && et.target==this.rightPanel.getIntegrateBtn()) { bcCtrl.disableBackupCtrls(); cq.push(c1=Command.create(Command.ID_SCAN_LEFT,null)); cq.push(c2=Command.create(Command.ID_BACKUP_ALL_LEFT,c1)); cq.push(c3=Command.create(Command.ID_SCAN_RIGHT,c2)); cq.push(c4=Command.create(Command.ID_INTEGRATE_ALL_RIGHT,c3)); cq.push(c5=Command.create(Command.ID_SCAN_RIGHT,c4)); Spiska complete=createComplete(c1,c2,c3,c4,c5); cq.push(Command.createComposite(Command.ID_ENABLE_CTRLS,complete)); if(PROC) integrateAllRightImages();} if(et.id==Event.ACTION_EVENT && et.target==this.rightPanel.getDelAllBtn()) { bcCtrl.disableBackupCtrls(); cq.push(c1=Command.create(Command.ID_SCAN_RIGHT,null)); cq.push(c2=Command.create(Command.ID_DELETE_ALL_RIGHT,c1)); cq.push(c3=Command.create(Command.ID_SCAN_RIGHT,c2)); cq.push(c4=Command.create(Command.ID_SCAN_LEFT,c2)); Spiska complete=createComplete(c1,c2,c3,c4); cq.push(Command.createComposite(Command.ID_ENABLE_CTRLS,complete)); if(PROC) eraseAllRightImages();} if(et.id==Event.ACTION_EVENT && et.target==leftPanel.getChoiceExtension()) processFormatSelection(); if(et.id==Event.ACTION_EVENT && et.target==this.rightPanel.getViewAllBtn()) { bcCtrl.disableBackupCtrls(); cq.push(c1=Command.create(Command.ID_SCAN_LEFT,null)); cq.push(c2=Command.create(Command.ID_SCAN_RIGHT,null)); cq.push(c3=Command.create(Command.ID_VIEW_ALL_RIGHT,c2)); Spiska complete=createComplete(c1,c2,c3); cq.push(Command.createComposite(Command.ID_ENABLE_CTRLS,complete)); if(PROC) viewAllRightImages();} if(et.id==Event.LIST_SELECT && et.target==this.leftPanel.lsItems) { rightPanel.selectNothing(); new BackupAllLeftTask(leftPanel,cv,null,logPanel,null).leftSelected();} if(et.id==Event.LIST_SELECT && et.target==this.rightPanel.lsItems) { leftPanel.selectNothing(); new ViewAllRightTask(rightPanel,cv,logPanel,bcCtrl,null).rightSelected();} return super.handleEvent(et);} private Spiska createComplete(Command c1,Command c2) { Spiska complete=new Spiska(); complete.append(c1); complete.append(c2); return complete;} private Spiska createComplete(Command c1,Command c2,Command c3) { Spiska complete=new Spiska(); complete.append(c1); complete.append(c2); complete.append(c3); return complete;} private Spiska createComplete(Command c1,Command c2,Command c3,Command c4) { Spiska complete=new Spiska(); complete.append(c1); complete.append(c2); complete.append(c3); complete.append(c4); return complete;} private Spiska createComplete(Command c1,Command c2,Command c3,Command c4,Command c5) { Spiska complete=new Spiska(); complete.append(c1); complete.append(c2); complete.append(c3); complete.append(c4); complete.append(c5); return complete;} private void processFormatSelection() { String selExt=leftPanel.getSelectedExtension(); rightPanel.setExtension(selExt);} private void integrateAllRightImages() { bcCtrl.disableBackupCtrls(); String path=pathPanel.tfPath.getText(); ScanRight scanRightBefore=new ScanRight(rightPanel,path,logPanel,bcCtrl,null); ScanRight scanRight=new ScanRight(rightPanel,path,logPanel,bcCtrl,null); ScanLeft scanLeft=new ScanLeft(leftPanel,path,logPanel,bcCtrl,null); BackupAllLeftTask backupLeft=new BackupAllLeftTask(leftPanel,cv,bcCtrl,logPanel,null); int type=Itor.DEF_INTEGRATION_TYPE; new Thread(new IntegrateAllRightTask(leftPanel,rightPanel,cv,logPanel,bcCtrl,type,path,null)).start();} private void viewAllRightImages() { String path=pathPanel.tfPath.getText(); ScanRight scanRight=new ScanRight(rightPanel,path,logPanel,bcCtrl,null); bcCtrl.disableBackupCtrls(); new Thread(new ViewAllRightTask(rightPanel,cv,logPanel,bcCtrl,null)).start();} private void eraseAllRightImages() { String path=pathPanel.tfPath.getText(); bcCtrl.disableBackupCtrls(); ScanRight scanRightBefore=new ScanRight(rightPanel,path,logPanel,bcCtrl,null); ScanRight scanRight=new ScanRight(rightPanel,path,logPanel,bcCtrl,null); new Thread(new EraseAllRightTask(rightPanel,logPanel,bcCtrl,null)).start();} private void backupAllLeftImages() { String path=pathPanel.tfPath.getText(); bcCtrl.disableBackupCtrls(); rightPanel.clearItems(); ScanLeft scanLeft=new ScanLeft(leftPanel,path,logPanel,bcCtrl,null); ScanRight scanRight=new ScanRight(rightPanel,path,logPanel,bcCtrl,null); new Thread(new BackupAllLeftTask(leftPanel,cv,bcCtrl,logPanel,null)).start();} private void updateInfo(long time) { if(time-lastTime < 997) return; bcCtrl.disableBackupCtrls(); String path=pathPanel.tfPath.getText(); rightPanel.clearItems(); leftPanel.clearItems(); new Thread(new ScanLeft(leftPanel,path,logPanel,bcCtrl,null)).start(); new Thread(new ScanRight(rightPanel,path,logPanel,bcCtrl,null)).start(); lastTime=time;}} class ImageBackupConsumer implements ImageConsumer { private ImageWriter imageWriter; private ImageParty imageParty=new ImageParty(); private Image photo; private String curPath; private String backupExt; private LogPanel logPanel; public ImageBackupConsumer(LogPanel logPanel) { super(); this.logPanel=logPanel; this.imageWriter=new ImageWriter(logPanel); clear();} void clear() { this.imageParty=new ImageParty(); this.photo=null; this.curPath=null; this.backupExt=null;} public void setProperties(Hashtable props) { if(Itor.D) System.out.println("setProperties");} public void setColorModel(ColorModel cm) { if(Itor.D) System.out.println("setColorModel "+cm);} public void setDimensions(int width,int height) { if(Itor.D) System.out.println("setDimensions w="+width+" h="+height);} public void setHints(int flags) { if(Itor.D) System.out.println("setHints "+flags);} public String arrayToString(int[] pixels) { String res=""; if(pixels !=null) for(int i=0; i < pixels.length; i++) if(i==0) res+=pixels[i]; else res+=", "+pixels[i]; return res;} public String arrayToString(byte[] pixels) { String res=""; if(pixels !=null) for(int i=0; i < pixels.length; i++) if(i==0) res+=pixels[i]; else res+=", "+pixels[i]; return res;} public void setPixels(int x,int y,int w,int h,ColorModel cm,byte[] pixels,int off,int scansize) { if(Itor.D) System.out.println("setPixels byte[] x:"+x+" y:"+y+" w:"+w+" h:"+h+" cm:"+cm+" px:"+arrayToString(pixels)+" of:"+off+" sc:"+scansize);} public void setPixels(int x,int y,int w,int h,ColorModel cm,int[] pixels,int off,int scansize) { if(Itor.D) System.out.println("setPixels int[] x:"+x+" y:"+y+" w:"+w+" h:"+h+" cm:"+cm+" px:"+arrayToString(pixels)+" of:"+off+" sc:"+scansize); try { imageParty.copyPart(pixels,scansize);} catch(ImageFileException e) { e.printStackTrace();}} public void imageComplete(int status) { if(status==ImageConsumer.STATICIMAGEDONE) { logPanel.addLog("Complete image display loading"); photo.getSource().removeConsumer(this); String newPath=curPath.substring(0,curPath.lastIndexOf('.'))+backupExt; try { FetchImageParty fetch=new FetchImageParty(imageParty); this.imageParty=new ImageParty(); imageWriter.write(newPath,fetch);} catch(ImageFileException e) { e.printStackTrace();} System.gc();}} public void updateCurrent(Image photo,String picturePath,String backupExt) { this.photo=photo; this.curPath=picturePath; this.backupExt=backupExt;}} class ImageBackupPreviewCanvas extends Canvas implements ImageObserver,Runnable { private ImageBackupConsumer consumer; private Image photo; private int[] prevPix; private boolean init; private int initWidth; private int initHeight; private int initLength; private double[] sumB; private double[] sumR; private double[] sumG; private int sumCount; private Stoish reloadRq=new Stoish(); private Stoish integrationRq=new Stoish(); private Thread worker1=null; public ImageBackupPreviewCanvas(LogPanel logPanel) { super(); setBackground(Color.lightGray); consumer=new ImageBackupConsumer(logPanel); clear();} private void clear() { this.photo=null; consumer.clear();} public void pushIntegrationSaveRequest(String picturesPath) { synchronized(integrationRq) { integrationRq.push(new IntegrationSaveRequest(picturesPath));} if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void pushIntegrationRequest(String path,int type) { synchronized(integrationRq) { integrationRq.push(new IntegrationRequest(path,type));} if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void pushReloadRequest(String path) { pushReloadRequest(path,false,WorkingHolder.BC_EXT1);} public void pushReloadRequest(String path,boolean withBackup,String backupExt) { synchronized(reloadRq) { reloadRq.push(new ReloadRequest(path,withBackup,backupExt));} if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { ReloadRequest rr=null; synchronized(reloadRq) { if(reloadRq.has()) { rr=(ReloadRequest) reloadRq.pop();}} if(rr !=null) { if(rr.isWithBackup()) reloadPhotoImage(rr.getPath(),rr.getBackupExt()); else reloadBackupImage(rr.getPath()); orderRedrawAll();} else { IntegrationRequest ir=null; IntegrationSaveRequest irs=null; synchronized(integrationRq) { if(integrationRq.has()) { Object request=integrationRq.pop(); if(request instanceof IntegrationSaveRequest) irs=(IntegrationSaveRequest) request; else if(request instanceof IntegrationRequest) ir=(IntegrationRequest) request;}} if(irs !=null) { saveIntegrationBackupImage(irs.getPicturesPath()); orderRedrawAll();} else if(ir !=null) { reloadIntegrationBackupImage(ir.getPath(),ir.getType()); orderRedrawAll();}} sleeper.sleep(5);}} protected void saveIntegrationBackupImage(String picturesPath) { int[] middlePix=new int[initLength]; for(int i=0; i < initLength; i++) { int b=(int)(sumB[i] /(double) sumCount); int g=(int)(sumG[i] /(double) sumCount); int r=(int)(sumR[i] /(double) sumCount); middlePix[i]=new Color(b,g,r).getRGB();} ImageFile.saveImageIntegration(picturesPath,initWidth,initHeight,middlePix);} protected void reloadIntegrationBackupImage(String picturePath,int type) { ImageFile file=null; try { file=ImageFile.loadImage(picturePath);} catch(ImageFileException e) { e.printStackTrace();} if(file !=null) { int bits=32; int redMask=16711680; int greenMask=65280; int blueMask=255; DirectColorModel cm=new DirectColorModel(bits,redMask,greenMask,blueMask); int width=file.getWidth(); int height=file.getHeight(); int[] pix=file.getData(); if(!init) { init=true; initWidth=width; initHeight=height; initLength=pix.length; if(type==1) { prevPix=new int[pix.length]; System.arraycopy(pix,0,prevPix,0,pix.length);} else if(type==2) { sumB=new double[pix.length]; sumR=new double[pix.length]; sumG=new double[pix.length]; sumCount=0; for(int i=0; i < pix.length; i++) { sumB[i]=0.f; sumR[i]=0.f; sumG[i]=0.f;}}} int[] middlePix=new int[pix.length]; sumCount++; for(int i=0; i < pix.length; i++) { Color cCur=new Color(pix[i]); if(type==2) { sumB[i]+=(double) cCur.getBlue(); sumR[i]+=(double) cCur.getRed(); sumG[i]+=(double) cCur.getGreen(); int b=(int)(sumB[i] /(double) sumCount); int g=(int)(sumG[i] /(double) sumCount); int r=(int)(sumR[i] /(double) sumCount); middlePix[i]=new Color(b,g,r).getRGB();} else if(type==1) { Color cPrev=new Color(prevPix[i]); int b=(cPrev.getBlue()+cCur.getBlue()) / 2; int g=(cPrev.getGreen()+cCur.getGreen()) / 2; int r=(cPrev.getRed()+cCur.getRed()) / 2; middlePix[i]=new Color(b,g,r).getRGB();}} photo=createImage(new MemoryImageSource(width,height,cm,middlePix,0,width)); if(type==1) prevPix=middlePix;}} protected void reloadBackupImage(String picturePath) { ImageFile file=null; try { file=ImageFile.loadImage(picturePath);} catch(ImageFileException e) { e.printStackTrace();} if(file !=null) { int bits=32; int redMask=16711680; int greenMask=65280; int blueMask=255; DirectColorModel cm=new DirectColorModel(bits,redMask,greenMask,blueMask); int width=file.getWidth(); int height=file.getHeight(); int[] pix=file.getData(); photo=createImage(new MemoryImageSource(width,height,cm,pix,0,width));}} protected void reloadPhotoImage(String picturePath,String backupExt) { clear(); if(Itor.D) System.out.println("Picture loading ..."); try { photo=Toolkit.getDefaultToolkit().getImage(picturePath); consumer.updateCurrent(photo,picturePath,backupExt); photo.getSource().addConsumer(consumer); if(Itor.D) System.out.println("Picture loading progress");} catch(Throwable e) { e.printStackTrace();} if(Itor.D) System.out.println("Picture loading exit");} private void orderRedrawAll() { invalidate(); repaint();} public void paint(Graphics ics) { super.paint(ics); Dimension d1=size(); if(photo !=null) ics.drawImage(photo,0+1-1+1,0+1-1+1,d1.width-1-1+1+1-1-1,d1.height-1-1+1+1-1-1,this);} public boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height) { if(Itor.D) System.out.println("imageUpdate f="+infoflags+" x="+x+" y="+y+" w="+width+" h="+height); if(infoflags==ImageObserver.ALLBITS) { orderRedrawAll(); return false;} return true;}} class PathPanel extends Panel { Label lbPath; TextField tfPath; Button btScan; public PathPanel() { super(); setBackground(Props.bgTopColor); setLayout(new FlowLayout()); add(lbPath=new Label("Images place:")); add(tfPath=new TextField("",50+20+10+5-5)); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days"); add(btScan=new Button("Scan"));} public void enableBackupCtrls(boolean param) { btScan.enable(param);}} class Data6 { Metr curSize; String curPos; Metr curAmount; boolean avgSet; double curMin; double curMax; double curAvg; void clear() { this.curSize=new Metr(0); this.curPos=""; this.curAmount=new Metr(0); avgSet=false; this.curMin=0.f; this.curMax=0.f; this.curAvg=0.f;}} class AddItemRec { String item; String fullPath; public AddItemRec(String item,String fullPath) { super(); this.item=item; this.fullPath=fullPath;}} abstract class SidePanel extends Panel { List lsItems; protected Spiska items=new Spiska(); protected StatPanel statPanel; protected Data6 d6=new Data6(); protected Stachko addItems=new Stachko(); public SidePanel() { super(); this.d6.clear();} abstract void addItemsComplete(); Stachko fetchLocal() { Stachko local=new Stachko(); synchronized(AddItemRec.class) { while(addItems.has()) { local.push(addItems.pop());}} return local;} void lsItemsAdd(Stachko local) { while(local.has()) { AddItemRec itemRec=(AddItemRec) local.pop(); lsItems.addItem(itemRec.item); items.append(itemRec.fullPath);}} public long itemsNum() { return items.size();} abstract void updateOnUiThread(); public void selectNothing() { lsItems.deselect(getSelectedIdx());} public int getSelectedIdx() { return lsItems.getSelectedIndex();} public void clearItems() { d6.clear(); lsItems.clear(); items=new Spiska();} public void addItem(String item,String fullPath) { AddItemRec itemRec=new AddItemRec(item,fullPath); synchronized(AddItemRec.class) { addItems.push(itemRec);}} public String getAmount() { return ""+d6.curAmount.repr(' ');} public void setAmount(Metr m) { d6.curAmount=m;} public String getTotalSize() { return ""+d6.curSize.repr(',');} public void setTotalSize(Metr m) { d6.curSize=m;} public void setCurrentIdx(int idxSel) { d6.curPos=""+(1+idxSel);} public void setAverageRec(AverageRec ar) { if(ar.getRecordsNum() > 0) { d6.avgSet=true; d6.curMin=ar.getMinTime(); d6.curMax=ar.getMaxTime(); d6.curAvg=ar.getAverageTime();}} public void selectItem(int idx) { lsItems.select(idx);} public String getSelected() { return lsItems.getSelectedItem();} public String getPath(int idxSel) { return(String) items.at(idxSel);}} class LeftPanel extends SidePanel { private LeftBackupPanel backupSizePanel; public LeftPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("North",statPanel=new StatPanel("*.jpg")); add("Center",lsItems=new List(22,false)); add("South",backupSizePanel=new LeftBackupPanel());} public String getSelectedExtension() { return backupSizePanel.backupIntegrPanel.chExt.getSelectedItem();} public Choice getChoiceExtension() { return backupSizePanel.backupIntegrPanel.chExt;} public Button getBackupBtn() { return backupSizePanel.backupIntegrPanel.btBackup;} public void enableBackupCtrls(boolean param) { backupSizePanel.backupIntegrPanel.btBackup.enable(param); backupSizePanel.backupIntegrPanel.chExt.enable(param);} public String getBackupExt() { String backupExt=backupSizePanel.backupIntegrPanel.chExt.getSelectedItem(); if(backupExt.endsWith(WorkingHolder.BC_EXTDEF)) backupExt=backupSizePanel.backupIntegrPanel.chExt.getItem(0+1); return backupExt;} void updateOnUiThread() { statPanel.tfAmount.setText(getAmount()); backupSizePanel.sizePanel.sizePanel.tfSize.setText(getTotalSize()); this.statPanel.tfPosition.setText(""+d6.curPos); backupSizePanel.sizePanel.avgPanel.setMinMaxAvg(d6); addItemsComplete();} public void addItemsComplete() { Stachko local=fetchLocal(); lsItemsAdd(local);}} class LeftBackupPanel extends Panel { LeftBackupIntegratePanel backupIntegrPanel; SizeAvgPanel sizePanel; public LeftBackupPanel() { super(); setBackground(Color.lightGray); setLayout(new BorderLayout()); add("North",backupIntegrPanel=new LeftBackupIntegratePanel()); add("Center",sizePanel=new SizeAvgPanel());}} class LeftBackupIntegratePanel extends Panel { Button btBackup; Choice chExt; public LeftBackupIntegratePanel() { super(); setBackground(Color.lightGray); setLayout(new FlowLayout()); add(btBackup=new Button("Backup All")); add(chExt=new Choice()); chExt.addItem(WorkingHolder.BC_EXTDEF); chExt.addItem("*"+WorkingHolder.BC_EXT1); chExt.addItem("*"+WorkingHolder.BC_EXT2); chExt.select(0+1); chExt.enable(!!false);}} class RightPanel extends SidePanel { private RightDeletePanel itemsDelPanel; public RightPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("North",statPanel=new StatPanel("*.im1")); add("Center",lsItems=new List(22,false)); add("South",itemsDelPanel=new RightDeletePanel());} public void setExtension(String selExt) { statPanel.lbDst.setText(selExt);} public Button getViewAllBtn() { return itemsDelPanel.dvPanel.btViewAll;} public Button getDelAllBtn() { return itemsDelPanel.dvPanel.btDelAll;} public Button getIntegrateBtn() { return itemsDelPanel.dvPanel.btIntegrate;} public void enableBackupCtrl(boolean param) { itemsDelPanel.dvPanel.btDelAll.enable(param); itemsDelPanel.dvPanel.btIntegrate.enable(param); itemsDelPanel.dvPanel.btViewAll.enable(param);} public void insertFirst(String item,String fullPath) { lsItems.addItem(item,0); Spiska ace=new Spiska(); ace.append(fullPath); for(int i=0; i < items.size(); i++) ace.append(items.at(i)); items=ace;} public Ester getExtension() { return new Ester(statPanel.lbDst.getText());} void updateOnUiThread() { statPanel.tfAmount.setText(getAmount()); itemsDelPanel.sizeAvgPanel.sizePanel.tfSize.setText(getTotalSize()); this.statPanel.tfPosition.setText(""+d6.curPos); itemsDelPanel.sizeAvgPanel.avgPanel.setMinMaxAvg(d6); addItemsComplete();} public void addItemsComplete() { Stachko local=fetchLocal(); lsItemsAdd(local);}} class RightDeletePanel extends Panel { RightDelViewPanel dvPanel; SizeAvgPanel sizeAvgPanel; public RightDeletePanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("Center",dvPanel=new RightDelViewPanel()); add("South",sizeAvgPanel=new SizeAvgPanel());}} class RightDelViewPanel extends Panel { Button btIntegrate; Button btViewAll; Button btDelAll; public RightDelViewPanel() { super(); setBackground(Color.lightGray); setLayout(new FlowLayout()); add(new AutoButtonFrame(btIntegrate=new Button("Auto"))); add(btViewAll=new Button("View All")); add(btDelAll=new Button("Delete All"));}} class AutoButtonFrame extends Panel { Button autoBtn; public AutoButtonFrame(Button autoBtn) { super(); this.autoBtn=autoBtn; FlowLayout fl; setLayout(fl=new FlowLayout()); fl.setHgap(2+1); fl.setVgap(2); setBackground(Color.yellow); add(autoBtn);}} class StatPanel extends Panel { String param; Label lbDst; Label lbAmount; TextField tfAmount; TextField tfPosition; public StatPanel(String param) { super(); this.param=param; setBackground(Color.gray); setLayout(new FlowLayout()); add(lbDst=new Label(param)); add(tfPosition=new TextField(5-1)); tfPosition.setEditable(false); add(tfAmount=new TextField("0",12-5-1)); add(lbAmount=new Label("image(s)")); tfAmount.setEditable(false);}} class SizeAvgPanel extends Panel { SizePanel sizePanel; AvgPanel avgPanel; public SizeAvgPanel() { super(); setBackground(Color.blue); setLayout(new BorderLayout()); add("Center",sizePanel=new SizePanel()); add("South",avgPanel=new AvgPanel());}} class AvgPanel extends Panel { private TextField tfMin; private TextField tfMax; private TextField tfAvg; public AvgPanel() { super(); setBackground(Color.lightGray); setLayout(new FlowLayout()); add(tfMin=new TextField("",4+1+1+1-3-1)); tfMin.setEditable(false); add(tfAvg=new TextField("",4+1+1+1+2+1+2+2+3-1)); tfAvg.setEditable(false); add(tfMax=new TextField("",4+1+1+1-3-1)); tfMax.setEditable(false);} public void setMinMaxAvg(Data6 d6) { if(d6.avgSet) { this.tfMin.setText(""+d6.curMin); this.tfMax.setText(""+d6.curMax); this.tfAvg.setText(""+d6.curAvg);}}} class SizePanel extends Panel { Label lbSize; TextField tfSize; public SizePanel() { super(); setBackground(Color.gray); setLayout(new FlowLayout()); add(tfSize=new TextField("0",25-1-2)); add(lbSize=new Label("byte(s)")); tfSize.setEditable(false);}} class LogPanel extends Panel implements Runnable { TextArea taLogging; private String res=new String(); private Object syncObj=new Object(); private Thread worker1; private boolean needUpdate; public LogPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("Center",taLogging=new TextArea(5,20)); taLogging.setEditable(false);} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { synchronized(syncObj) { if(needUpdate) { taLogging.setText(res.toString()); needUpdate=false;}} sleeper.sleep(130 * 2);}} public void addLog(String item) { if(item !=null && item.length() > 0) { synchronized(syncObj) { res=new Ester(item).append('\n')+res; needUpdate=true;} if(worker1==null) { worker1=new Thread(this); worker1.start();}}} public void addLogComplete(String item) { addLog(item.replace('_',':'));}} abstract class Scan implements Runnable { Metr amount=new Metr(); Metr size=new Metr(); AverageRec ar=new AverageRec(); abstract void displayAmount(Metr m); abstract void displaySize(Metr m); abstract void displayAvg(); abstract void addItem(String item,String fullPath); protected void updateStat() { Metr m=new Metr(0); m.inc(amount); displayAmount(m); m=new Metr(0); m.inc(size); displaySize(m); displayAvg();} protected void scanItems(String path,String ext) { Ester[] start=new Files().tree(new Ester(path)); Ester[] select=new Filter().endsWithIncensitive(start,new Ester(ext)); for(int i=0; i < select.length; i++) { ar.start(); File file=new File(select[i].toString()); addItem(file.getName(),file.getAbsolutePath()); amount.inc(1); size.inc(file.length()); ar.trust(); updateStat();} updateStat();}} class ScanLeft extends Scan { LeftPanel leftPanel; String path; LogPanel logPanel; Command cmd; BcController bcCtrl; public ScanLeft(LeftPanel leftPanel,String path,LogPanel logPanel,BcController bcCtrl,Command cmd) { super(); this.leftPanel=leftPanel; this.path=path; this.logPanel=logPanel; this.bcCtrl=bcCtrl; this.cmd=cmd;} void displayAmount(Metr m) { leftPanel.setAmount(m);} void displayAvg() { leftPanel.setAverageRec(ar);} void displaySize(Metr m) { leftPanel.setTotalSize(m);} void addItem(String item,String fullPath) { leftPanel.addItem(item,fullPath);} public void run() { Time t=new Time(); t.start(); updateStat(); scanItems(path,".jpg"); leftPanel.addItemsComplete(); t.trust(); logPanel.addLogComplete("Left scan complete "+t.ess()); if(cmd !=null) { cmd.markComplete(); if(Itor.D) System.out.println("left complete");}}} class ScanRight extends Scan { long amount; long size; RightPanel rightPanel; String path; LogPanel logPanel; BcController bcCtrl; Command cmd; public ScanRight(RightPanel rightPanel,String path,LogPanel logPanel,BcController bcCtrl,Command cmd) { super(); this.rightPanel=rightPanel; this.path=path; this.logPanel=logPanel; this.bcCtrl=bcCtrl; this.cmd=cmd;} public void run() { Time t=new Time(); t.start(); updateStat(); String ext=Data.replace(new Ester(rightPanel.getExtension()),new Ester("*"),new Ester("")).toString(); scanItems(path,ext); rightPanel.addItemsComplete(); t.trust(); logPanel.addLogComplete("Right scan complete "+t.vse()); if(cmd !=null) { cmd.markComplete(); if(Itor.D) System.out.println("right complete");}} void displayAmount(Metr m) { rightPanel.setAmount(m);} void displayAvg() { rightPanel.setAverageRec(ar);} void displaySize(Metr m) { rightPanel.setTotalSize(m);} void addItem(String item,String fullPath) { if(item.endsWith("integration.im1")) { rightPanel.insertFirst(item,fullPath); return;} rightPanel.addItem(item,fullPath);}} class IntegrateAllRightTask implements Runnable { private static LeftPanel leftPanel; private static RightPanel rightPanel; private static BcController bcCtrl; private static LogPanel logPanel; private static ImageBackupPreviewCanvas cv; private static boolean next=true; private static int type; private String picturesPath; Command cmd; static AverageRec ar=new AverageRec(); public IntegrateAllRightTask(LeftPanel leftPanel,RightPanel rightPanel,ImageBackupPreviewCanvas cv,LogPanel logPanel,BcController bcCtrl,int type,String picturesPath,Command cmd) { super(); this.leftPanel=leftPanel; this.rightPanel=rightPanel; this.cv=cv; this.logPanel=logPanel; this.bcCtrl=bcCtrl; this.type=type; this.picturesPath=picturesPath; this.cmd=cmd;} public void run() { Time t=new Time(); t.start(); bcCtrl.disableBackupCtrls(); long num=rightPanel.itemsNum(); for(int i=0; i < num; i++) { ar.start(); next=false; rightPanel.selectItem(i); rightItemIntegration(); waitHere(); ar.trust();} rightItemIntegrationComplete(); t.trust(); logPanel.addLogComplete("Integration of all backup items complete "+t.ess()); logPanel.addLogComplete("Average records("+ar.getRecordsNum()+") processing time is "+ar.getAverageTime()+"sec also min time is "+ar.getMinTime()+"sec and max time is "+ar.getMaxTime()+"sec"); if(cmd !=null) { cmd.markComplete(); if(Itor.D) System.out.println("Integration complete");}} void rightItemIntegrationComplete() { cv.pushIntegrationSaveRequest(picturesPath); logPanel.addLog("Integration is in safe place "+(picturesPath+File.separator+"integration.im1"));} private void waitHere() { Sleeper sleeper=new Sleeper(); while(!next) { sleeper.sleep(5); next=true;}} void rightItemIntegration() { int idxSel=rightPanel.getSelectedIdx(); rightPanel.setCurrentIdx(idxSel); rightPanel.setAverageRec(ar); String curSel=rightPanel.getSelected(); String path=rightPanel.getPath(idxSel); logPanel.addLog("Right integration idx["+(idxSel+1)+"] image{"+curSel+"} from "+path); cv.pushIntegrationRequest(path,type);}} class ViewAllRightTask implements Runnable { private static RightPanel rightPanel; private static BcController bcCtrl; private static LogPanel logPanel; private static ImageBackupPreviewCanvas cv; private static boolean next=true; Command cmd; static AverageRec ar=new AverageRec(); public ViewAllRightTask(RightPanel rightPanel,ImageBackupPreviewCanvas cv,LogPanel logPanel,BcController bcCtrl,Command cmd) { super(); this.rightPanel=rightPanel; this.cv=cv; this.logPanel=logPanel; this.bcCtrl=bcCtrl; this.cmd=cmd;} public void run() { ExpectHere eh=new ExpectHere(5); Time t=new Time(); t.start(); bcCtrl.disableBackupCtrls(); long num=rightPanel.itemsNum(); for(int i=0; i < num; i++) { ar.start(); next=false; rightPanel.selectItem(i); rightSelected(); waitHere(); ar.trust();} t.trust(); logPanel.addLogComplete("View all backup items complete "+t.ess()); logPanel.addLogComplete("Average records("+ar.getRecordsNum()+") processing time is "+ar.getAverageTime()+"sec also min time is "+ar.getMinTime()+"sec and max time is "+ar.getMaxTime()+"sec"); if(cmd !=null) { cmd.markComplete(); if(Itor.D) System.out.println("View All right complete");}} private void waitHere() { Sleeper sleeper=new Sleeper(); while(!next) { sleeper.sleep(130); next=true;}} static void rightSelected() { int idxSel=rightPanel.getSelectedIdx(); rightPanel.setCurrentIdx(idxSel); rightPanel.setAverageRec(ar); String curSel=rightPanel.getSelected(); String path=rightPanel.getPath(idxSel); logPanel.addLog("Right view image{"+curSel+"} idx["+(idxSel+1)+"] from "+path); cv.pushReloadRequest(path);}} class EraseAllRightTask implements Runnable { private RightPanel rightPanel; private LogPanel logPanel; private BcController bcCtrl; private ScanRight scanRight; private ScanRight scanRightBefore; private Command cmd; public EraseAllRightTask(RightPanel rightPanel,LogPanel logPanel,BcController bcCtrl,Command cmd) { super(); this.rightPanel=rightPanel; this.logPanel=logPanel; this.bcCtrl=bcCtrl; this.cmd=cmd;} public void run() { AverageRec ar=new AverageRec(); Time t=new Time(); t.start(); bcCtrl.disableBackupCtrls(); int s=0; int f=0; long num=rightPanel.itemsNum(); for(int i=0; i < num; i++) { ar.start(); String path=rightPanel.getPath(i); boolean delRes=false; try { if(path !=null) { File file=new File(path); path=file.getAbsolutePath(); if(file.isFile()) delRes=file.delete();} else { delRes=false; System.out.println("Error during delete"+" - "+path); logPanel.addLog("Error during delete"+" - "+path);}} catch(Throwable th) { delRes=false; System.out.println(""+th.getMessage()+" - "+path); logPanel.addLog(""+th.getMessage()+" - "+path);} if(delRes) s+=1; else f+=1; logPanel.addLog("Delete "+(i+1)+"/"+num+" "+(delRes ? "SUCCES" : "FAIL")+" from "+path); ar.trust(); rightPanel.setAverageRec(ar);} logPanel.addLog("Deleted="+s+" Failed="+f); rightPanel.clearItems(); t.trust(); logPanel.addLogComplete("Delete all backup items complete "+t.ess()); logPanel.addLogComplete("Average records("+ar.getRecordsNum()+") processing time is "+ar.getAverageTime()+"sec also min time is "+ar.getMinTime()+"sec and max time is "+ar.getMaxTime()+"sec"); if(cmd !=null) { cmd.markComplete(); if(Itor.D) System.out.println("View All right complete");}}} class BackupAllLeftTask implements Runnable { private static LeftPanel leftPanel; private static BcController bcCtrl; private static ImageBackupPreviewCanvas cv; private LogPanel logPanel; private static ExpectHere eh=new ExpectHere(5); Command cmd; static AverageRec ar=new AverageRec(); public BackupAllLeftTask(LeftPanel leftPanel,ImageBackupPreviewCanvas cv,BcController bcCtrl,LogPanel logPanel,Command cmd) { super(); this.leftPanel=leftPanel; this.cv=cv; this.bcCtrl=bcCtrl; this.logPanel=logPanel; this.cmd=cmd;} public void run() { Time t=new Time(); t.start(); bcCtrl.disableBackupCtrls(); long num=leftPanel.itemsNum(); for(int i=0; i < num; i++) { ar.start(); eh.clear(); leftPanel.selectItem(i); leftSelected(); eh.stopUntilExpected(); if(1+1 < 1) Runtime.getRuntime().gc(); ar.trust();} num=leftPanel.itemsNum(); t.trust(); logPanel.addLogComplete("Backup all Left images complete "+t.ess()); logPanel.addLogComplete("Average records("+ar.getRecordsNum()+") processing time is "+ar.getAverageTime()+"sec also min time is "+ar.getMinTime()+"sec and max time is "+ar.getMaxTime()+"sec"); if(cmd !=null) { cmd.markComplete(); if(Itor.D) System.out.println("Backup All complete");}} public static void proceedNext() { eh.markAsReached();} static void leftSelected() { int idxSel=leftPanel.getSelectedIdx(); leftPanel.setCurrentIdx(idxSel); leftPanel.setAverageRec(ar); String path=leftPanel.getPath(idxSel); String backupExt=leftPanel.getBackupExt(); cv.pushReloadRequest(path,true,backupExt);}} class WriteJobs { Stachko items=new Stachko(); int size1; public WriteJobs() { super();} public synchronized int size() { return size1;} public synchronized ImageFile pop() { ImageFile imageFile=(ImageFile) items.pop(); size1--; return imageFile;} public synchronized void push(ImageFile imageFile) { items.push(imageFile); size1++;} public synchronized boolean hasItem() { return items.has();}} class ImageWriter implements Runnable { private Thread worker1; private WriteJobs writeImageJobs=new WriteJobs(); private LogPanel logPanel; public ImageWriter(LogPanel logPanel) { super(); worker1=null; this.logPanel=logPanel;} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { ImageFile imageFile=null; if(writeImageJobs.hasItem()) imageFile=(ImageFile) writeImageJobs.pop(); if(imageFile !=null) try { BackupAllLeftTask.proceedNext(); logPanel.addLog("writing has started"); imageFile.saveImage(imageFile.getFullPath()); logPanel.addLog("writing finished "+writeImageJobs.size()+" job(s) is ongoing");} catch(ImageFileException e) { e.printStackTrace();} sleeper.sleep(5);}} public void write(String newPath,FetchImageParty fetch) throws ImageFileException { logPanel.addLog("reg2 file writing "+newPath); ImageFile imageFile=ImageFile.createImage2(fetch,newPath); writeImageJobs.push(imageFile); if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void writeImageFile(String newPath,int scanSize,int[] pix) throws ImageFileException { logPanel.addLog("reg file writing "+newPath); ImageFile imageFile=ImageFile.createImage(scanSize,pix,newPath); writeImageJobs.push(imageFile); if(worker1==null) { worker1=new Thread(this); worker1.start();}}} class ImageParty { private int total; private Spiska parts=new Spiska(); private int scanSize; public ImageParty() { super(); clear();} private void clear() { this.total=0; this.parts=new Spiska(); this.scanSize=0;} public int getPartsNum() { if(parts !=null) return(int) parts.size(); return 0;} public int[] getPart(int i) { if(parts !=null && i >= 0 && i < parts.size()) return(int[]) parts.at(i); return null;} public int[] getAllPix() { int pos=0; int[] pix=new int[total]; for(int i=0; i < parts.size(); i++) { int[] curPart=(int[]) parts.at(i); System.arraycopy(curPart,0,pix,pos,curPart.length); pos+=curPart.length;} clear(); return pix;} public int getScanSize() { return scanSize;} public void copyPart(int[] pixels,int scanSize) throws ImageFileException { total+=pixels.length; if(scanSize < 1) throw new ImageFileException(" Error 2 scanSize="+scanSize); this.scanSize=scanSize; int[] pixPart=new int[pixels.length]; System.arraycopy(pixels,0,pixPart,0,pixels.length); parts.append(pixPart);} public int getTotal() { return total;}} class ImageFileException extends Exception { public ImageFileException() { super();} public ImageFileException(String message) { super(message);}} class ImageFile { protected static final int BUF_LIM=256; private String fullPath; private FetchImageParty fetch; private int width; private int height; private int pix[]; ImageFile(String fullPath) { super(); this.fullPath=fullPath;} public static void saveImageIntegration(String picturesPath,int initWidth,int initHeight,int[] data) { ImageFile im1=new ImageFile(new File(picturesPath).getAbsolutePath()+File.separator+"integration.im1"); im1.width=initWidth; im1.height=initHeight; im1.pix=data; try { im1.saveImage1(im1.fullPath);} catch(ImageFileException e) { e.printStackTrace();}} ImageFile(String fullPath,FetchImageParty fetch) { super(); this.fullPath=fullPath; this.fetch=fetch;} public int[] getData() { return pix;} public String getName() { return new File(fullPath).getName();} public String getFullPath() { return fullPath;} public int getWidth() { return width;} public int getHeight() { return height;} public void saveImage(String fullPath) throws ImageFileException { if(fullPath !=null) { if(fullPath.endsWith(WorkingHolder.BC_EXT1)) saveImage1(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT1),new Ester(WorkingHolder.BC_EXT1)).toString()); else if(fullPath.endsWith(WorkingHolder.BC_EXT2)) saveImage2(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT2),new Ester(WorkingHolder.BC_EXT2)).toString());}} protected void saveImage2(String fullPath) throws ImageFileException { System.out.println("_"+fullPath); try { File file=new File(fullPath); FileOutputStream os=new FileOutputStream(file); Stachko pixColorIndexes=new Stachko(); Karta cIndexMap=new Karta(); Spiska palette=new Spiska(); int size1=0; if(fetch !=null) { write4b(os,fetch.getWidth()); write4b(os,fetch.getTotalLength() / fetch.getWidth()); System.out.println(" WH"); int pos=0; while(fetch.hasNext()) { System.out.println(" chunk "+size1); int[] chunk=fetch.next(); for(int i=0; i < chunk.length; i++) { String colorKey=""+chunk[i]; int colorIdx=-1; if(cIndexMap.containsKey(colorKey)) colorIdx=((Integer) cIndexMap.get(colorKey)).intValue(); else { palette.append(new Integer(chunk[i])); colorIdx=(int) palette.size()-1; cIndexMap.put(colorKey,new Integer(colorIdx));} pixColorIndexes.push(new Integer(colorIdx)); size1++;}}} else if(pix !=null && pix.length > 0) { write4b(os,width); write4b(os,height); System.out.println(" WH2"); for(int i=0; i < pix.length; i++) { String colorKey=""+pix[i]; int colorIdx=-1; if(cIndexMap.containsKey(colorKey)) colorIdx=((Integer) cIndexMap.get(colorKey)).intValue(); else { palette.append(new Integer(pix[i])); colorIdx=(int) palette.size()-1; cIndexMap.put(colorKey,new Integer(colorIdx));} pixColorIndexes.push(new Integer(colorIdx)); size1++;}} System.out.println(" palette "+palette.size()); int[] paletArr=new int[(int) palette.size()]; for(int i=0; i < paletArr.length; i++) paletArr[i]=((Integer) palette.at(i)).intValue(); write4b(os,paletArr.length); writeIntBuf(os,paletArr); System.out.println(" total "+size1); int i=0; while(pixColorIndexes.has()) { String pixOrderKey=""+i++; int colorIdx=((Integer) pixColorIndexes.pop()).intValue(); if(!(colorIdx >= 0 && colorIdx <= 100000)) throw new ImageFileException("Wrong color index."); else System.out.print(" "+colorIdx); write4b(os,colorIdx);} os.flush(); os.close();} catch(IOException ex) { throw new ImageFileException("Can't save. "+ex.getMessage());}} protected void saveImage1(String fullPath) throws ImageFileException { try { File file=new File(fullPath); FileOutputStream os=new FileOutputStream(file); if(fetch !=null) { write4b(os,fetch.getWidth()); write4b(os,fetch.getTotalLength() / fetch.getWidth()); while(fetch.hasNext()) { int[] chunk=fetch.next(); writeIntBuf(os,chunk);}} else { write4b(os,width); write4b(os,height); writeIntBuf(os,pix);} os.flush(); os.close();} catch(IOException ex) { throw new ImageFileException("Can't save. "+ex.getMessage());}} private void writeIntBuf(FileOutputStream os,int[] intBuf) throws IOException { int pos=0; byte[] buf=new byte[4 * BUF_LIM]; for(int i=0; i < intBuf.length; i++) { int r; int v=intBuf[i]; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; if(pos==BUF_LIM * 4) { os.write(buf); pos=0;}} if(pos > 0) os.write(buf,0,pos);} private void write4b(OutputStream os,int v) throws IOException { int r; r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r);} private static int read4b(InputStream is) throws IOException { int s=0; int r1=is.read(); int r2=is.read(); int r3=is.read(); int r4=is.read(); s=((r4 * 255+r3) * 255+r2) * 255+r1; return s;} public static ImageFile loadImage(String fullPath) throws ImageFileException { ImageFile result=null; if(fullPath !=null) { if(fullPath.endsWith(WorkingHolder.BC_EXT1)) result=loadImage1(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT1),new Ester(WorkingHolder.BC_EXT1)).toString()); else if(fullPath.endsWith(WorkingHolder.BC_EXT2)) result=loadImage2(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT2),new Ester(WorkingHolder.BC_EXT2)).toString());} return result;} public static ImageFile loadImage2(String fullPath) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); int paletteSize=read4b(is); int[] palette=new int[paletteSize]; for(int i=0; i < paletteSize; i++) palette[i]=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserAdapter parser=new ParserAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count,palette);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}} public static ImageFile loadImage1(String fullPath) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserAdapter parser=new ParserAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}} public static ImageFile createImage2(FetchImageParty fetch,String path) throws ImageFileException { ImageFile imageFile=new ImageFile(""+path,fetch); return imageFile;} public static ImageFile createImage(int scanSize,int[] data,String path) throws ImageFileException { if(scanSize < 1) throw new ImageFileException("Wrong scanSize value. scanSize="+scanSize); if(data.length-data.length / scanSize * scanSize !=0) throw new ImageFileException("Not enought data (scanSize="+scanSize+", data.length="+data.length+", rest="+(data.length-data.length / scanSize * scanSize)+")"); ImageFile imageFile=new ImageFile(""+path); imageFile.width=scanSize; imageFile.height=data.length / scanSize; imageFile.pix=new int[data.length]; System.arraycopy(data,0,imageFile.pix,0,data.length); return imageFile;}} class ParserAdapter { int s; int r1; int r2; int r3; int r4; int n=0; int idx=0; int[] pix; public ParserAdapter(int[] pix) { this.pix=pix;} public void push(byte[] buf,int count,int[] palette) { for(int j=0; j < count; j++) { push(buf[j]); if(n==0) { System.out.println(" "+idx+" "+pix[idx-1]);}}} public void push(int b) { switch(n) { case 0 : r1=b; break; case 1 : r2=b; break; case 2 : r3=b; break; default : r4=b; break;} n++; if(n==4) { n=0; s=((r4 * 255+r3) * 255+r2) * 255+r1; pix[idx++]=s;}} public void push(byte[] buf,int count) { for(int j=0; j < count; j++) push(buf[j]);}} class IntegrationRequest { private String path; private int type; public IntegrationRequest(String path,int type) { super(); this.path=path; this.type=type;} public int getType() { return type;} public String getPath() { return path;}} class IntegrationSaveRequest extends IntegrationRequest { private String picturesPath; public IntegrationSaveRequest(String picturesPath) { super("",0); this.picturesPath=picturesPath;} public String getPicturesPath() { return picturesPath;}} class ReloadRequest { private String path; private boolean withBackup; private String backupExt; public ReloadRequest(String path,boolean withBackup,String backupExt) { super(); this.path=path; this.withBackup=withBackup; this.backupExt=backupExt;} public String getPath() { return path;} public boolean isWithBackup() { return withBackup;} public String getBackupExt() { return backupExt;}} class FetchImageParty { ImageParty ref; int curPartIdx; public FetchImageParty(ImageParty ref) { super(); this.ref=ref; this.curPartIdx=0;} public boolean hasNext() { return curPartIdx < ref.getPartsNum();} public int[] next() { int[] part=(int[]) ref.getPart(curPartIdx++); return part;} public int getTotalLength() { return ref.getTotal();} public int getWidth() { return ref.getScanSize();}} class WorkingHolder { final static String BC_EXTDEF="Default"; final static String BC_EXT1=".im1"; final static String BC_EXT2=".im2"; static boolean working=true;} class BcController { private LeftPanel leftPanel; private RightPanel rightPanel; private PathPanel pathPanel; public BcController(LeftPanel leftPanel,RightPanel rightPanel,PathPanel pathPanel) { super(); this.leftPanel=leftPanel; this.rightPanel=rightPanel; this.pathPanel=pathPanel; enableBackupCtrls();} public void enableBackupCtrls() { leftPanel.enableBackupCtrls(true); rightPanel.enableBackupCtrl(true); pathPanel.enableBackupCtrls(true);} public void disableBackupCtrls() { leftPanel.enableBackupCtrls(false); rightPanel.enableBackupCtrl(false); pathPanel.enableBackupCtrls(false);}} class Props { final static Color bgTopColor=Color.green;} class Command { public final static int ID_SCAN_LEFT=1; public final static int ID_SCAN_RIGHT=1+1; public final static int ID_BACKUP_ALL_LEFT=1+1+1; public final static int ID_INTEGRATE_ALL_RIGHT=1+1+1+1; public final static int ID_VIEW_ALL_RIGHT=1+1+1+1+1; public final static int ID_DELETE_ALL_RIGHT=1+1+1+1+1+1; public final static int ID_ENABLE_CTRLS=1+1+1+1+1+1+1; private int id; boolean complete; Command lunchAfterCmd; Spiska lunchAfterCmds; long time1; private Command(int id,Spiska lunchAfterCmds) { super(); this.id=id; this.complete=false; this.lunchAfterCmds=lunchAfterCmds; this.time1=new Date().getTime();} private Command(int id,Command lunchAfterCmd) { super(); this.id=id; this.complete=false; this.lunchAfterCmd=lunchAfterCmd; this.time1=new Date().getTime();} public Command getLunchAfterCmd() { return lunchAfterCmd;} public boolean isComplete() { if(lunchAfterCmds !=null && lunchAfterCmds.size() > 0) { for(int i=0; i < lunchAfterCmds.size(); i++) if(((Command) lunchAfterCmds.at(i)).isComplete()==false) return false; return true;} return complete;} public void markComplete() { complete=true;} public int getId() { return id;} public static Command createComposite(int cmdId,Spiska lunchAfterCompleteCmd) { Command cmd=null; switch(cmdId) { case ID_ENABLE_CTRLS : cmd=new Command(cmdId,lunchAfterCompleteCmd); break;} return cmd;} public static Command create(int cmdId,Command lunchAfterCmd) { Command cmd=null; switch(cmdId) { case ID_SCAN_LEFT : cmd=new Command(cmdId,lunchAfterCmd); break; case ID_SCAN_RIGHT : cmd=new Command(cmdId,lunchAfterCmd); break; case ID_BACKUP_ALL_LEFT : cmd=new Command(cmdId,lunchAfterCmd); break; case ID_INTEGRATE_ALL_RIGHT : cmd=new Command(cmdId,lunchAfterCmd); break; case ID_VIEW_ALL_RIGHT : cmd=new Command(cmdId,lunchAfterCmd); break; case ID_DELETE_ALL_RIGHT : cmd=new Command(cmdId,lunchAfterCmd); break;} return cmd;} public String toString() { return "Command [id="+id+", complete="+complete+", lunchAfter="+lunchAfterCmd+"]";} public long getTime() { return time1;}} class CommandQueue { private Spiska items=new Spiska(); int current; public CommandQueue() { super(); this.current=-1;} public boolean allComplete() { boolean result=true; for(int i=0; i < items.size(); i++) { Command item=(Command) items.at(i); if(!item.isComplete()) return false;} return result;} public boolean hasRunAgainCondition(Command curCmd) { int searchIdx=-1; for(int i=0; searchIdx==-1 && i < items.size(); i++) { Command item=(Command) items.at(i); if(item.equals(curCmd)) searchIdx=i;} Command prevSearch=null; for(int i=searchIdx-1; prevSearch==null && i >= 0; i--) { Command item=(Command) items.at(i); if(item.getId()==curCmd.getId()) prevSearch=item;} if(prevSearch==null) return true; return new Date().getTime()-prevSearch.getTime() > 997 && prevSearch.isComplete();} public boolean hasConditionComplete(Command curCmd) { int searchIdx=-1; for(int i=0; searchIdx==-1 && i < items.size(); i++) { Command item=(Command) items.at(i); if(item.equals(curCmd)) searchIdx=i;} if(curCmd.getLunchAfterCmd()==null) return true; for(int i=searchIdx-1; i >= 0; i--) { Command item=(Command) items.at(i); if(curCmd.getLunchAfterCmd().equals(item)) return item.isComplete();} return false;} public void rollbackCurrent() { current--;} public void push(Command cmd) { if(cmd !=null) { if(items.size() > 0) { Command prev=(Command) items.at(items.size()-1); if(prev.getId()==cmd.getId()); else items.append(cmd);} else items.append(cmd);}} public boolean hasSomeWork() { return current < items.size()-1;} public Command nextCurrent() { current++; Command cmd=(Command) items.at(current); return cmd;} public void dump() { new Data().dump(items);} public String toString() { return "CommandQueue [items.size="+items.size()+", current="+current+"]";}}