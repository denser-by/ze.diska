package mydev.pb; import java.awt.BorderLayout; import java.awt.Button; import java.awt.Canvas; import java.awt.Choice; import java.awt.Color; import java.awt.Dimension; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Graphics; import java.awt.Image; import java.awt.Label; import java.awt.List; import java.awt.Panel; import java.awt.TextArea; import java.awt.TextField; import java.awt.Toolkit; import java.awt.image.ColorModel; import java.awt.image.DirectColorModel; import java.awt.image.ImageConsumer; import java.awt.image.ImageObserver; import java.awt.image.MemoryImageSource; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Date; import java.util.Hashtable; import mydev.aaa.Sleeper; import mydev.vutils.Data; import mydev.vutils.Ester; import mydev.vutils.Files; import mydev.vutils.Filter; import mydev.vutils.Karta; import mydev.vutils.Metr; import mydev.vutils.Spiska; import mydev.vutils.Stachko; import mydev.vutils.Stoish; import mydev.vutils.Time; public class Itor extends Frame { final static boolean D=false; protected PathPanel pathPanel; protected LeftPanel leftPanel; protected RightPanel rightPanel; protected ImageBackupPreviewCanvas cv; protected LogPanel logPanel; private Spiska leftItems=new Spiska(); private Spiska rightItems=new Spiska(); public Itor() { super(); setLayout(new BorderLayout()); setBackground(Color.darkGray); add("North",pathPanel=new PathPanel()); add("West",leftPanel=new LeftPanel()); add("East",rightPanel=new RightPanel()); logPanel=new LogPanel(); add("Center",cv=new ImageBackupPreviewCanvas(logPanel)); add("South",logPanel);} public static void main(String[] args) { System.out.println(""+Toolkit.getDefaultToolkit().getScreenSize().toString()); Itor main=new Itor(); main.setTitle("Leaves Days Photo-Backup"); main.show(); main.reMoveRnd(); main.resize(1024,768); if(args.length > 0) main.setInputFolder(args[0]); Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { main.refreshUpdatable(); sleeper.sleep(123);} main.hide(); main.dispose(); System.exit(1-1);} protected void reMoveRnd() { long x1=new Date().getTime(); if(x1 < 0) x1 *=-1; x1=10+3 *(x1 % 100); long y1=new Date().getTime(); if(y1 < 0) y1 *=-1; y1=10+2 *(y1 % 100); move((int) x1,(int) y1);} public void setInputFolder(String pathParam) { pathPanel.tfPath.setText(pathParam);} private void refreshUpdatable() { invalidate(); repaint();} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) WorkingHolder.working=false; if(et.id==Event.ACTION_EVENT && et.target==this.pathPanel.btScan) updateInfo(); if(et.id==Event.ACTION_EVENT && et.target==this.leftPanel.backupSizePanel.backupIntegrPanel.btBackup) backupAllLeftImages(); if(et.id==Event.ACTION_EVENT && et.target==this.rightPanel.itemsDelPanel.dvPanel.btIntegr) integrateAllRightImages(); if(et.id==Event.ACTION_EVENT && et.target==this.rightPanel.itemsDelPanel.dvPanel.btDelAll) eraseAllRightImages(); if(et.id==Event.ACTION_EVENT && et.target==leftPanel.backupSizePanel.backupIntegrPanel.chExt) processFormatSelection(); if(et.id==Event.ACTION_EVENT && et.target==this.rightPanel.itemsDelPanel.dvPanel.btViewAll) viewAllRightImages(); if(et.id==Event.LIST_SELECT && et.target==this.leftPanel.lsItems) { rightPanel.itemsDelPanel.lsItems.deselect(rightPanel.itemsDelPanel.lsItems.getSelectedIndex()); new BackupAllLeftTask(leftPanel,leftItems,cv,null,null,logPanel).leftSelected();} if(et.id==Event.LIST_SELECT && et.target==this.rightPanel.itemsDelPanel.lsItems) { leftPanel.lsItems.deselect(leftPanel.lsItems.getSelectedIndex()); BcController bcCtrl=new BcController(leftPanel,rightPanel,pathPanel); new ViewAllRightTask(rightPanel,rightItems,cv,logPanel,bcCtrl).rightSelected();} return super.handleEvent(et);} private void processFormatSelection() { String selExt=leftPanel.backupSizePanel.backupIntegrPanel.chExt.getSelectedItem(); rightPanel.statPanel.lbDst.setText(selExt);} private void integrateAllRightImages() { logPanel.addLog("let's integrate");} private void viewAllRightImages() { if(rightPanel.itemsDelPanel.lsItems.countItems() > 0) { enableBackupCtrl(false); BcController bcCtrl=new BcController(leftPanel,rightPanel,pathPanel); new Thread(new ViewAllRightTask(rightPanel,rightItems,cv,logPanel,bcCtrl)).start();}} private void eraseAllRightImages() { if(rightPanel.itemsDelPanel.lsItems.countItems() > 0) { enableBackupCtrl(false); BcController bcCtrl=new BcController(leftPanel,rightPanel,pathPanel); String path=pathPanel.tfPath.getText(); ScanRight scanRight=new ScanRight(rightPanel,path,rightItems,logPanel); new Thread(new EraseAllRightTask(rightPanel,rightItems,logPanel,bcCtrl,scanRight)).start(); rightItems=new Spiska();}} private void backupAllLeftImages() { if(leftPanel.lsItems.countItems() > 0) { enableBackupCtrl(false); String path=pathPanel.tfPath.getText(); rightPanel.itemsDelPanel.lsItems.clear(); rightItems=new Spiska(); ScanRight scanRight=new ScanRight(rightPanel,path,rightItems,logPanel); BcController bcCtrl=new BcController(leftPanel,rightPanel,pathPanel); new Thread(new BackupAllLeftTask(leftPanel,leftItems,cv,scanRight,bcCtrl,logPanel)).start();}} private void enableBackupCtrl(boolean param) { leftPanel.enableBackupCtrls(param); rightPanel.enableBackupCtrl(param); pathPanel.enableBackupCtrls(param);} private void updateInfo() { String path=pathPanel.tfPath.getText(); leftPanel.lsItems.clear(); rightPanel.itemsDelPanel.lsItems.clear(); leftItems=new Spiska(); rightItems=new Spiska(); new Thread(new ScanLeft(leftPanel,path,leftItems,logPanel)).start(); new Thread(new ScanRight(rightPanel,path,rightItems,logPanel)).start();}} class ImageBackupConsumer implements ImageConsumer { private ImageWriter imageWriter; private ImageParty imageParty=new ImageParty(); private Image photo; private String curPath; private String backupExt; private LogPanel logPanel; public ImageBackupConsumer(LogPanel logPanel) { super(); this.logPanel=logPanel; this.imageWriter=new ImageWriter(logPanel); clear();} void clear() { this.imageParty=new ImageParty(); this.photo=null; this.curPath=null; this.backupExt=null;} public void setProperties(Hashtable props) { if(Itor.D) System.out.println("setProperties");} public void setColorModel(ColorModel cm) { if(Itor.D) System.out.println("setColorModel "+cm);} public void setDimensions(int width,int height) { if(Itor.D) System.out.println("setDimensions w="+width+" h="+height);} public void setHints(int flags) { if(Itor.D) System.out.println("setHints "+flags);} public String arrayToString(int[] pixels) { String res=""; if(pixels !=null) for(int i=0; i < pixels.length; i++) if(i==0) res+=pixels[i]; else res+=", "+pixels[i]; return res;} public String arrayToString(byte[] pixels) { String res=""; if(pixels !=null) for(int i=0; i < pixels.length; i++) if(i==0) res+=pixels[i]; else res+=", "+pixels[i]; return res;} public void setPixels(int x,int y,int w,int h,ColorModel cm,byte[] pixels,int off,int scansize) { if(Itor.D) System.out.println("setPixels byte[] x:"+x+" y:"+y+" w:"+w+" h:"+h+" cm:"+cm+" px:"+arrayToString(pixels)+" of:"+off+" sc:"+scansize);} public void setPixels(int x,int y,int w,int h,ColorModel cm,int[] pixels,int off,int scansize) { if(Itor.D) System.out.println("setPixels int[] x:"+x+" y:"+y+" w:"+w+" h:"+h+" cm:"+cm+" px:"+arrayToString(pixels)+" of:"+off+" sc:"+scansize); try { imageParty.copyPart(pixels,scansize);} catch(ImageFileException e) { e.printStackTrace();}} public void imageComplete(int status) { if(status==ImageConsumer.STATICIMAGEDONE) { logPanel.addLog("Complete image display loading"); photo.getSource().removeConsumer(this); String newPath=curPath.substring(0,curPath.lastIndexOf('.'))+backupExt; try { FetchImageParty fetch=new FetchImageParty(imageParty); this.imageParty=new ImageParty(); imageWriter.write(newPath,fetch);} catch(ImageFileException e) { e.printStackTrace();} System.gc();}} public void updateCurrent(Image photo,String picturePath,String backupExt) { this.photo=photo; this.curPath=picturePath; this.backupExt=backupExt;}} class ImageBackupPreviewCanvas extends Canvas implements ImageObserver,Runnable { private ImageBackupConsumer consumer; private Image photo; private Stoish reloadRq=new Stoish(); private Thread worker1=null; public ImageBackupPreviewCanvas(LogPanel logPanel) { super(); setBackground(Color.lightGray); consumer=new ImageBackupConsumer(logPanel); clear();} private void clear() { this.photo=null; consumer.clear();} public void pushReloadRequest(String path) { pushReloadRequest(path,false,WorkingHolder.BC_EXT1);} public void pushReloadRequest(String path,boolean withBackup,String backupExt) { synchronized(reloadRq) { reloadRq.push(new ReloadRequest(path,withBackup,backupExt));} if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { ReloadRequest rr=null; synchronized(reloadRq) { if(reloadRq.has()) { rr=(ReloadRequest) reloadRq.pop();}} if(rr !=null) { if(rr.isWithBackup()) reloadPhotoImage(rr.getPath(),rr.getBackupExt()); else reloadBackupImage(rr.getPath()); orderRedrawAll();} sleeper.sleep(30);}} protected void reloadBackupImage(String picturePath) { ImageFile file=null; try { file=ImageFile.loadImage(picturePath);} catch(ImageFileException e) { e.printStackTrace();} if(file !=null) { int bits=32; int redMask=16711680; int greenMask=65280; int blueMask=255; DirectColorModel cm=new DirectColorModel(bits,redMask,greenMask,blueMask); int width=file.getWidth(); int height=file.getHeight(); int[] pix=file.getData(); photo=createImage(new MemoryImageSource(width,height,cm,pix,0,width));}} protected void reloadPhotoImage(String picturePath,String backupExt) { clear(); if(Itor.D) System.out.println("Picture loading ..."); try { photo=Toolkit.getDefaultToolkit().getImage(picturePath); consumer.updateCurrent(photo,picturePath,backupExt); photo.getSource().addConsumer(consumer); if(Itor.D) System.out.println("Picture loading progress");} catch(Throwable e) { e.printStackTrace();} if(Itor.D) System.out.println("Picture loading exit");} private void orderRedrawAll() { invalidate(); repaint();} public void paint(Graphics ics) { super.paint(ics); Dimension d1=size(); if(photo !=null) ics.drawImage(photo,0+1-1+1,0+1-1+1,d1.width-1-1+1+1-1-1,d1.height-1-1+1+1-1-1,this);} public boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height) { if(Itor.D) System.out.println("imageUpdate f="+infoflags+" x="+x+" y="+y+" w="+width+" h="+height); if(infoflags==ImageObserver.ALLBITS) { orderRedrawAll(); return false;} return true;}} class PathPanel extends Panel { Label lbPath; TextField tfPath; Button btScan; public PathPanel() { super(); setBackground(Color.green); setLayout(new FlowLayout()); add(lbPath=new Label("Photo place:")); add(tfPath=new TextField("",50+20+10+5)); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days"); add(btScan=new Button("Scan"));} public void enableBackupCtrls(boolean param) { btScan.enable(param);}} class LeftPanel extends Panel { StatPanel statPanel; List lsItems; LeftBackupPanel backupSizePanel; public LeftPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("North",statPanel=new StatPanel("*.jpg")); add("Center",lsItems=new List(22,false)); add("South",backupSizePanel=new LeftBackupPanel());} public void enableBackupCtrls(boolean param) { backupSizePanel.backupIntegrPanel.btBackup.enable(param); backupSizePanel.backupIntegrPanel.chExt.enable(param);} public String getBackupExt() { String backupExt=backupSizePanel.backupIntegrPanel.chExt.getSelectedItem(); if(backupExt.endsWith(WorkingHolder.BC_EXTDEF)) backupExt=backupSizePanel.backupIntegrPanel.chExt.getItem(0+1); return backupExt;}} class LeftBackupPanel extends Panel { LeftBackupIntegratePanel backupIntegrPanel; SizePanel sizePanel; public LeftBackupPanel() { super(); setBackground(Color.lightGray); setLayout(new BorderLayout()); add("North",backupIntegrPanel=new LeftBackupIntegratePanel()); add("Center",sizePanel=new SizePanel());}} class LeftBackupIntegratePanel extends Panel { TextField tfPos; Button btBackup; Choice chExt; public LeftBackupIntegratePanel() { super(); setBackground(Color.lightGray); setLayout(new FlowLayout()); add(tfPos=new TextField(5-1)); tfPos.setEditable(false); add(btBackup=new Button("Backup")); add(chExt=new Choice()); chExt.addItem(WorkingHolder.BC_EXTDEF); chExt.addItem("*"+WorkingHolder.BC_EXT1); chExt.addItem("*"+WorkingHolder.BC_EXT2); chExt.select(0+1); chExt.enable(!false);}} class RightPanel extends Panel { StatPanel statPanel; RightDeletePanel itemsDelPanel; SizePanel sizePanel; public RightPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("North",statPanel=new StatPanel("*.im1")); add("Center",itemsDelPanel=new RightDeletePanel()); add("South",sizePanel=new SizePanel());} public void enableBackupCtrl(boolean param) { itemsDelPanel.dvPanel.btDelAll.enable(param); itemsDelPanel.dvPanel.btIntegr.enable(param); itemsDelPanel.dvPanel.btViewAll.enable(param);}} class RightDeletePanel extends Panel { List lsItems; RightDelViewPanel dvPanel; public RightDeletePanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("Center",lsItems=new List(22,false)); add("South",dvPanel=new RightDelViewPanel());}} class RightDelViewPanel extends Panel { Button btIntegr; Button btViewAll; Button btDelAll; public RightDelViewPanel() { super(); setBackground(Color.lightGray); setLayout(new FlowLayout()); add(btIntegr=new Button("Integration")); add(btViewAll=new Button("View All")); add(btDelAll=new Button("Delete All"));}} class StatPanel extends Panel { String param; Label lbDst; Label lbAmount; TextField tfAmount; public StatPanel(String param) { super(); this.param=param; setBackground(Color.gray); setLayout(new FlowLayout()); add(lbDst=new Label(param)); add(tfAmount=new TextField("0",12)); add(lbAmount=new Label("image(s)")); tfAmount.setEditable(false);}} class SizePanel extends Panel { Label lbSize; TextField tfSize; public SizePanel() { super(); setBackground(Color.gray); setLayout(new FlowLayout()); add(tfSize=new TextField("0",25-1)); add(lbSize=new Label("byte(s)")); tfSize.setEditable(false);}} class LogPanel extends Panel implements Runnable { TextArea taLogging; private Ester res=new Ester(""); private Object syncObj=new Object(); private Thread worker1; private boolean needUpdate; public LogPanel() { super(); setBackground(Color.green); setLayout(new BorderLayout()); add("Center",taLogging=new TextArea(4,20)); taLogging.setEditable(false);} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { synchronized(syncObj) { if(needUpdate) { taLogging.setText(res.toString()); needUpdate=false;}} sleeper.sleep(130);}} public void addLog(String item) { if(item !=null && item.length() > 0) { synchronized(syncObj) { res=new Ester(item).append('\n').append(res); needUpdate=true;} if(worker1==null) { worker1=new Thread(this); worker1.start();}}} public void addLogComplete(String item) { addLog(item.replace('_',':'));}} abstract class Scan implements Runnable { long amount; long size; abstract void displayAmount(Metr m); abstract void displaySize(Metr m); abstract void addItem(String item,String fullPath); protected void updateStat() { Metr m=new Metr(0); m.inc(amount); displayAmount(m); m=new Metr(0); m.inc(size); displaySize(m);} protected void scanItems(String path,String ext) { Ester[] start=new Files().tree(new Ester(path)); Ester[] select=new Filter().endsWithIncensitive(start,new Ester(ext)); for(int i=0; i < select.length; i++) { File file=new File(select[i].toString()); addItem(file.getName(),file.getAbsolutePath()); amount+=1; size+=file.length(); updateStat();}}} class ScanLeft extends Scan { LeftPanel leftPanel; String path; Spiska leftItems; LogPanel logPanel; public ScanLeft(LeftPanel leftPanel,String path,Spiska leftItems,LogPanel logPanel) { super(); this.leftPanel=leftPanel; this.path=path; this.leftItems=leftItems; this.logPanel=logPanel;} void displayAmount(Metr m) { leftPanel.statPanel.tfAmount.setText(""+m.repr(' '));} void displaySize(Metr m) { leftPanel.backupSizePanel.sizePanel.tfSize.setText(""+m.repr(','));} void addItem(String item,String fullPath) { leftPanel.lsItems.addItem(item); leftItems.append(fullPath);} public void run() { Time t=new Time(); t.start(); updateStat(); scanItems(path,".jpg"); t.trust(); logPanel.addLogComplete("Left scan complete "+t.ess());}} class ScanRight extends Scan { long amount; long size; RightPanel rightPanel; String path; Spiska rightItems; LogPanel logPanel; public ScanRight(RightPanel rightPanel,String path,Spiska rightItems,LogPanel logPanel) { super(); this.rightPanel=rightPanel; this.path=path; this.rightItems=rightItems; this.logPanel=logPanel;} public void run() { Time t=new Time(); t.start(); updateStat(); String ext=Data.replace(new Ester(rightPanel.statPanel.lbDst.getText()),new Ester("*"),new Ester("")).toString(); scanItems(path,ext); t.trust(); logPanel.addLogComplete("Right scan complete "+t.vse());} void displayAmount(Metr m) { rightPanel.statPanel.tfAmount.setText(""+m.repr(' '));} void displaySize(Metr m) { rightPanel.sizePanel.tfSize.setText(""+m.repr(','));} void addItem(String item,String fullPath) { rightPanel.itemsDelPanel.lsItems.addItem(item); rightItems.append(fullPath);}} class ViewAllRightTask implements Runnable { private static RightPanel rightPanel; private static BcController bcCtrl; private static LogPanel logPanel; private static Spiska rightItems; private static ImageBackupPreviewCanvas cv; private static boolean next=true; public ViewAllRightTask(RightPanel rightPanel,Spiska rightItems,ImageBackupPreviewCanvas cv,LogPanel logPanel,BcController bcCtrl) { super(); this.rightPanel=rightPanel; this.rightItems=rightItems; this.cv=cv; this.logPanel=logPanel; this.bcCtrl=bcCtrl;} public void run() { Time t=new Time(); t.start(); int num=rightPanel.itemsDelPanel.lsItems.countItems(); for(int i=0; i < num; i++) { next=false; rightPanel.itemsDelPanel.lsItems.select(i); rightSelected(); waitHere();} bcCtrl.enableBackupCtrls(1+0+1 > 0+1); t.trust(); logPanel.addLogComplete("View all backup items complete "+t.ess());} private void waitHere() { Sleeper sleeper=new Sleeper(); while(!next) { sleeper.sleep(130); next=true;}} static void rightSelected() { int idxSel=rightPanel.itemsDelPanel.lsItems.getSelectedIndex(); String curSel=rightPanel.itemsDelPanel.lsItems.getSelectedItem(); String path=(String) rightItems.at(idxSel); logPanel.addLog("right selected idxSel="+idxSel+" curSel="+curSel+" path="+path); cv.pushReloadRequest(path);}} class EraseAllRightTask implements Runnable { private RightPanel rightPanel; private Spiska rightItems; private LogPanel logPanel; private BcController bcCtrl; private ScanRight scanRight; public EraseAllRightTask(RightPanel rightPanel,Spiska rightItems,LogPanel logPanel,BcController bcCtrl,ScanRight scanRight) { super(); this.rightPanel=rightPanel; this.rightItems=rightItems; this.logPanel=logPanel; this.bcCtrl=bcCtrl; this.scanRight=scanRight;} public void run() { Time t=new Time(); t.start(); int s=0; int f=0; int num=rightPanel.itemsDelPanel.lsItems.countItems(); for(int i=0; i < num; i++) { String path=(String) rightItems.at(i); File file=new File(path); path=file.getAbsolutePath(); boolean delRes=false; if(file.isFile()) delRes=file.delete(); if(delRes) s+=1; else f+=1; logPanel.addLog("Delete "+(i+1)+"/"+num+" "+(delRes ? "SUCCES" : "FAIL")+" "+path);} logPanel.addLog("Deleted="+s+" Failed="+f); rightPanel.itemsDelPanel.lsItems.clear(); bcCtrl.enableBackupCtrls(1+0+1 > 0+1); t.trust(); logPanel.addLogComplete("Delete all backup items complete "+t.ess()); if(scanRight !=null) scanRight.run();}} class BackupAllLeftTask implements Runnable { private static LeftPanel leftPanel; private static BcController bcCtrl; private static Spiska leftItems; private static ImageBackupPreviewCanvas cv; private static boolean next=true; private ScanRight scanRight; private LogPanel logPanel; public BackupAllLeftTask(LeftPanel leftPanel,Spiska leftItems,ImageBackupPreviewCanvas cv,ScanRight scanRight,BcController bcCtrl,LogPanel logPanel) { super(); this.leftPanel=leftPanel; this.leftItems=leftItems; this.cv=cv; this.scanRight=scanRight; this.bcCtrl=bcCtrl; this.logPanel=logPanel;} public void run() { Time t=new Time(); t.start(); int num=leftPanel.lsItems.countItems(); for(int i=0; i < num; i++) { next=false; leftPanel.lsItems.select(i); leftSelected(); waitHere(); Runtime.getRuntime().gc();} bcCtrl.enableBackupCtrls(1+0+1 > 0+1); t.trust(); logPanel.addLogComplete("Backup all Left images complete "+t.ess()); if(scanRight !=null) scanRight.run();} public static void proceedNext() { next=true;} private void waitHere() { Sleeper sleeper=new Sleeper(); while(!next) { sleeper.sleep(130);}} static void leftSelected() { int idxSel=leftPanel.lsItems.getSelectedIndex(); leftPanel.backupSizePanel.backupIntegrPanel.tfPos.setText(""+(1+idxSel)); String curSel=leftPanel.lsItems.getSelectedItem(); String path=(String) leftItems.at(idxSel); String backupExt=leftPanel.getBackupExt(); cv.pushReloadRequest(path,true,backupExt);}} class WriteJobs { Stachko items=new Stachko(); int size1; public WriteJobs() { super();} public synchronized int size() { return size1;} public synchronized ImageFile pop() { ImageFile imageFile=(ImageFile) items.pop(); size1--; return imageFile;} public synchronized void push(ImageFile imageFile) { items.push(imageFile); size1++;} public synchronized boolean hasItem() { return items.has();}} class ImageWriter implements Runnable { private Thread worker1; private WriteJobs writeImageJobs=new WriteJobs(); private LogPanel logPanel; public ImageWriter(LogPanel logPanel) { super(); worker1=null; this.logPanel=logPanel;} public void run() { Sleeper sleeper=new Sleeper(); while(WorkingHolder.working) { ImageFile imageFile=null; if(writeImageJobs.hasItem()) imageFile=(ImageFile) writeImageJobs.pop(); if(imageFile !=null) try { BackupAllLeftTask.proceedNext(); logPanel.addLog("writing has started"); imageFile.saveImage(imageFile.getFullPath()); logPanel.addLog("writing finished "+writeImageJobs.size()+" job(s) is ongoing");} catch(ImageFileException e) { e.printStackTrace();} sleeper.sleep(30);}} public void write(String newPath,FetchImageParty fetch) throws ImageFileException { logPanel.addLog("reg2 file writing "+newPath); ImageFile imageFile=ImageFile.createImage2(fetch,newPath); writeImageJobs.push(imageFile); if(worker1==null) { worker1=new Thread(this); worker1.start();}} public void writeImageFile(String newPath,int scanSize,int[] pix) throws ImageFileException { logPanel.addLog("reg file writing "+newPath); ImageFile imageFile=ImageFile.createImage(scanSize,pix,newPath); writeImageJobs.push(imageFile); if(worker1==null) { worker1=new Thread(this); worker1.start();}}} class ImageParty { private int total; private Spiska parts=new Spiska(); private int scanSize; public ImageParty() { super(); clear();} private void clear() { this.total=0; this.parts=new Spiska(); this.scanSize=0;} public int getPartsNum() { if(parts !=null) return(int) parts.size(); return 0;} public int[] getPart(int i) { if(parts !=null && i >= 0 && i < parts.size()) return(int[]) parts.at(i); return null;} public int[] getAllPix() { int pos=0; int[] pix=new int[total]; for(int i=0; i < parts.size(); i++) { int[] curPart=(int[]) parts.at(i); System.arraycopy(curPart,0,pix,pos,curPart.length); pos+=curPart.length;} clear(); return pix;} public int getScanSize() { return scanSize;} public void copyPart(int[] pixels,int scanSize) throws ImageFileException { total+=pixels.length; if(scanSize < 1) throw new ImageFileException(" Error 2 scanSize="+scanSize); this.scanSize=scanSize; int[] pixPart=new int[pixels.length]; System.arraycopy(pixels,0,pixPart,0,pixels.length); parts.append(pixPart);} public int getTotal() { return total;}} class ImageFileException extends Exception { public ImageFileException() { super();} public ImageFileException(String message) { super(message);}} class ImageFile { protected static final int BUF_LIM=256; private String fullPath; private FetchImageParty fetch; private int width; private int height; private int pix[]; ImageFile(String fullPath) { super(); this.fullPath=fullPath;} ImageFile(String fullPath,FetchImageParty fetch) { super(); this.fullPath=fullPath; this.fetch=fetch;} public int[] getData() { return pix;} public String getName() { return new File(fullPath).getName();} public String getFullPath() { return fullPath;} public int getWidth() { return width;} public int getHeight() { return height;} public void saveImage(String fullPath) throws ImageFileException { if(fullPath !=null) { if(fullPath.endsWith(WorkingHolder.BC_EXT1)) saveImage1(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT1),new Ester(WorkingHolder.BC_EXT1)).toString()); else if(fullPath.endsWith(WorkingHolder.BC_EXT2)) saveImage2(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT2),new Ester(WorkingHolder.BC_EXT2)).toString());}} protected void saveImage2(String fullPath) throws ImageFileException { System.out.println("_"+fullPath); try { File file=new File(fullPath); FileOutputStream os=new FileOutputStream(file); Stachko pixColorIndexes=new Stachko(); Karta cIndexMap=new Karta(); Spiska palette=new Spiska(); int size1=0; if(fetch !=null) { write4b(os,fetch.getWidth()); write4b(os,fetch.getTotalLength() / fetch.getWidth()); System.out.println(" WH"); int pos=0; while(fetch.hasNext()) { System.out.println(" chunk "+size1); int[] chunk=fetch.next(); for(int i=0; i < chunk.length; i++) { String colorKey=""+chunk[i]; int colorIdx=-1; if(cIndexMap.containsKey(colorKey)) colorIdx=((Integer) cIndexMap.get(colorKey)).intValue(); else { palette.append(new Integer(chunk[i])); colorIdx=(int) palette.size()-1; cIndexMap.put(colorKey,new Integer(colorIdx));} pixColorIndexes.push(new Integer(colorIdx)); size1++;}}} else if(pix !=null && pix.length > 0) { write4b(os,width); write4b(os,height); System.out.println(" WH2"); for(int i=0; i < pix.length; i++) { String colorKey=""+pix[i]; int colorIdx=-1; if(cIndexMap.containsKey(colorKey)) colorIdx=((Integer) cIndexMap.get(colorKey)).intValue(); else { palette.append(new Integer(pix[i])); colorIdx=(int) palette.size()-1; cIndexMap.put(colorKey,new Integer(colorIdx));} pixColorIndexes.push(new Integer(colorIdx)); size1++;}} System.out.println(" palette "+palette.size()); int[] paletArr=new int[(int) palette.size()]; for(int i=0; i < paletArr.length; i++) paletArr[i]=((Integer) palette.at(i)).intValue(); write4b(os,paletArr.length); writeIntBuf(os,paletArr); System.out.println(" total "+size1); int i=0; while(pixColorIndexes.has()) { String pixOrderKey=""+i++; int colorIdx=((Integer) pixColorIndexes.pop()).intValue(); if(!(colorIdx >= 0 && colorIdx <= 100000)) throw new ImageFileException("Wrong color index."); else System.out.print(" "+colorIdx); write4b(os,colorIdx);} os.flush(); os.close();} catch(IOException ex) { throw new ImageFileException("Can't save. "+ex.getMessage());}} protected void saveImage1(String fullPath) throws ImageFileException { try { File file=new File(fullPath); FileOutputStream os=new FileOutputStream(file); if(fetch !=null) { write4b(os,fetch.getWidth()); write4b(os,fetch.getTotalLength() / fetch.getWidth()); while(fetch.hasNext()) { int[] chunk=fetch.next(); writeIntBuf(os,chunk);}} else { write4b(os,width); write4b(os,height); writeIntBuf(os,pix);} os.flush(); os.close();} catch(IOException ex) { throw new ImageFileException("Can't save. "+ex.getMessage());}} private void writeIntBuf(FileOutputStream os,int[] intBuf) throws IOException { int pos=0; byte[] buf=new byte[4 * BUF_LIM]; for(int i=0; i < intBuf.length; i++) { int r; int v=intBuf[i]; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; if(pos==BUF_LIM * 4) { os.write(buf); pos=0;}} if(pos > 0) os.write(buf,0,pos);} private void write4b(OutputStream os,int v) throws IOException { int r; r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r);} private static int read4b(InputStream is) throws IOException { int s=0; int r1=is.read(); int r2=is.read(); int r3=is.read(); int r4=is.read(); s=((r4 * 255+r3) * 255+r2) * 255+r1; return s;} public static ImageFile loadImage(String fullPath) throws ImageFileException { ImageFile result=null; if(fullPath !=null) { if(fullPath.endsWith(WorkingHolder.BC_EXT1)) result=loadImage1(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT1),new Ester(WorkingHolder.BC_EXT1)).toString()); else if(fullPath.endsWith(WorkingHolder.BC_EXT2)) result=loadImage2(Data.replace(new Ester(fullPath),new Ester("*"+WorkingHolder.BC_EXT2),new Ester(WorkingHolder.BC_EXT2)).toString());} return result;} public static ImageFile loadImage2(String fullPath) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); int paletteSize=read4b(is); int[] palette=new int[paletteSize]; for(int i=0; i < paletteSize; i++) palette[i]=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserAdapter parser=new ParserAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count,palette);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}} public static ImageFile loadImage1(String fullPath) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserAdapter parser=new ParserAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}} public static ImageFile createImage2(FetchImageParty fetch,String path) throws ImageFileException { ImageFile imageFile=new ImageFile(""+path,fetch); return imageFile;} public static ImageFile createImage(int scanSize,int[] data,String path) throws ImageFileException { if(scanSize < 1) throw new ImageFileException("Wrong scanSize value. scanSize="+scanSize); if(data.length-data.length / scanSize * scanSize !=0) throw new ImageFileException("Not enought data (scanSize="+scanSize+", data.length="+data.length+", rest="+(data.length-data.length / scanSize * scanSize)+")"); ImageFile imageFile=new ImageFile(""+path); imageFile.width=scanSize; imageFile.height=data.length / scanSize; imageFile.pix=new int[data.length]; System.arraycopy(data,0,imageFile.pix,0,data.length); return imageFile;}} class ParserAdapter { int s; int r1; int r2; int r3; int r4; int n=0; int idx=0; int[] pix; public ParserAdapter(int[] pix) { this.pix=pix;} public void push(byte[] buf,int count,int[] palette) { for(int j=0; j < count; j++) { push(buf[j]); if(n==0) { System.out.println(" "+idx+" "+pix[idx-1]);}}} public void push(int b) { switch(n) { case 0 : r1=b; break; case 1 : r2=b; break; case 2 : r3=b; break; default : r4=b; break;} n++; if(n==4) { n=0; s=((r4 * 255+r3) * 255+r2) * 255+r1; pix[idx++]=s;}} public void push(byte[] buf,int count) { for(int j=0; j < count; j++) push(buf[j]);}} class ReloadRequest { private String path; private boolean withBackup; private String backupExt; public ReloadRequest(String path,boolean withBackup,String backupExt) { super(); this.path=path; this.withBackup=withBackup; this.backupExt=backupExt;} public String getPath() { return path;} public boolean isWithBackup() { return withBackup;} public String getBackupExt() { return backupExt;}} class FetchImageParty { ImageParty ref; int curPartIdx; public FetchImageParty(ImageParty ref) { super(); this.ref=ref; this.curPartIdx=0;} public boolean hasNext() { return curPartIdx < ref.getPartsNum();} public int[] next() { int[] part=(int[]) ref.getPart(curPartIdx++); return part;} public int getTotalLength() { return ref.getTotal();} public int getWidth() { return ref.getScanSize();}} class WorkingHolder { final static String BC_EXTDEF="Default"; final static String BC_EXT1=".im1"; final static String BC_EXT2=".im2"; static boolean working=true;} class BcController { private LeftPanel leftPanel; private RightPanel rightPanel; private PathPanel pathPanel; public BcController(LeftPanel leftPanel,RightPanel rightPanel,PathPanel pathPanel) { super(); this.leftPanel=leftPanel; this.rightPanel=rightPanel; this.pathPanel=pathPanel;} public void enableBackupCtrls(boolean param) { leftPanel.enableBackupCtrls(param); rightPanel.enableBackupCtrl(param); pathPanel.enableBackupCtrls(param);}}