package mydev.plain; import java.awt.Button; import java.awt.Color; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Label; import java.awt.Panel; import java.awt.TextArea; import java.awt.TextField; import java.io.File; import java.util.Stack; import java.util.Vector; public class Obj extends Frame { boolean stop; Button search; TextArea searchResults; TextField searchPattern; public Obj(String arg0) { super(arg0); stop=false;} public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) stop=true; if(et.id==Event.ACTION_EVENT && search.equals(et.target)) { searchPattern.setEditable(1 > 1+1); searchPattern.disable(); letsFindSomeResults(searchPattern.getText()); searchPattern.enable(); searchPattern.setEditable(1 < 1+1);} return super.handleEvent(et);} private void letsFindSomeResults(String pattern) { String[] args=null; Vector buf=new Vector(); Stack folders=new Stack(); Vector files=new Vector(); File cur=new File("."); String absPath=cur.getAbsolutePath(); if(absPath.endsWith(".")) absPath=absPath.substring(0,absPath.length()-1); folders.push(absPath); char ik=absPath.endsWith("/") ? '/' : '\\'; while(!folders.isEmpty()) { String currentFolder=(String) folders.pop(); File curFolderObj=new File(currentFolder); String[] items=curFolderObj.list(); int idx=0-1; while(items !=null &&++idx < items.length) { String obj=items[idx]; File objf=new File(currentFolder+obj); if(objf.isDirectory() && objf.list() !=null && objf.list().length > 0) folders.push(new String(currentFolder+obj+ik)); else if(objf.isFile()) files.addElement(new String(currentFolder+obj));}} int idx=0-1; while(++idx < files.size()-1) { String first=(String) files.elementAt(idx); int idy=idx; boolean stop=false; while(!stop &&++idy < files.size()) { String secnd=(String) files.elementAt(idy); if(first.compareTo(secnd) > 0) { files.removeElementAt(idx); files.insertElementAt(secnd,idx); files.removeElementAt(idy); files.insertElementAt(first,idy); stop=!stop;}}} while(!files.isEmpty()) { String fi=(String) files.elementAt(0); files.removeElementAt(0); Object err=null; if(args !=null && args.length >= 1) try { buf.addElement(fi+" "+"["+new File(fi).length()+"]"+'\n');} catch(Throwable ex) { ex.getMessage(); err=ex;} finally { if(err !=null) buf.addElement(fi+" "+"["+0+"]"+'\n');} else buf.addElement(fi+'\n');} Recognitor ptrn=new Recognitor(pattern); StringBuffer sbuf=new StringBuffer(); for(int i=0; i < buf.size(); i++) { if(pattern.equals("*")) sbuf.append(buf.elementAt(i)); else if(ptrn.isComplex() && ptrn.comply(buf.elementAt(i))) sbuf.append(buf.elementAt(i)); else if(Utils.contains(buf.elementAt(i),pattern)) sbuf.append(buf.elementAt(i)); else if(pattern.equals("")) sbuf.append(buf.elementAt(i));} searchResults.setText(sbuf.toString()); sbuf.setLength(0); buf.removeAllElements();} public static void main(String[] args) { Frame mainFr=new Obj("Searcher"); mainFr.setLayout(new FlowLayout()); File cur=new File("."); String absPath=cur.getAbsolutePath(); if(absPath.endsWith(".")) absPath=absPath.substring(0,absPath.length()-1); Panel locationFace=new Panel(); locationFace.setLayout(new FlowLayout()); Label where=new Label(""+absPath); locationFace.setBackground(Color.lightGray); locationFace.add(where); mainFr.add(locationFace); Panel patternFace=new Panel(); patternFace.setLayout(new FlowLayout());((Obj) mainFr).searchPattern=new TextField(70);((Obj) mainFr).searchPattern.setText("pro*ess?");((Obj) mainFr).searchPattern.selectAll();((Obj) mainFr).searchPattern.requestFocus();((Obj) mainFr).searchPattern.setBackground(Color.white); patternFace.add(((Obj) mainFr).searchPattern);((Obj) mainFr).search=new Button("Find"); patternFace.add(((Obj) mainFr).search); patternFace.resize(600,100); patternFace.setBackground(Color.lightGray); mainFr.add(patternFace); Panel resultsFace=new Panel(); resultsFace.setLayout(new FlowLayout());((Obj) mainFr).searchResults=new TextArea(15-1,80-1-1-1-1);((Obj) mainFr).searchResults.setBackground(Color.lightGray); resultsFace.add(((Obj) mainFr).searchResults); resultsFace.resize(600,240);((Obj) mainFr).searchResults.setEditable(false); resultsFace.setBackground(Color.lightGray); mainFr.add(resultsFace); mainFr.show(); mainFr.setBackground(Color.black); mainFr.resize(600,340+1); while(!((Obj) mainFr).stop) try { Thread.sleep(667);} catch(InterruptedException ex) { ex.getMessage();} mainFr.hide(); mainFr.dispose(); System.exit(1-1);}} class Recognitor { private Vector entries; private short complexity; public Recognitor(String pattern) { super(); this.complexity=0; this.entries=new Vector(); init(pattern); simplify();} public boolean comply(Object items) { String item=items.toString().toLowerCase(); int idx=0-1; short voting=0; int prev=0-1; int prevLen=0; int vd=0; while(++idx < entries.size()) { Smarticle sm=(Smarticle) entries.elementAt(idx); if(sm.isText() && sm.partOf(item)) { int cur=item.indexOf(sm.getValue()); voting+=cur > prev ? 1 : 0; if(vd > 0) { if(prev+prevLen+vd==cur) { voting+=1-1;} else { voting--;} vd=0;} prev=cur; prevLen=sm.getValue().length();} else if(sm.isComplex()) { if(sm.getType().isAnyMuch()) voting++; else if(sm.getType().isAnyOne()) { vd++; voting++;}}} return entries.size()==voting;} public boolean isComplex() { return complexity > 1-1;} private void simplify() { boolean finish=false; while(!finish) { short changes=0; int idx=0-1; while(++idx < entries.size()-1) { Smarticle p1=(Smarticle) entries.elementAt(idx); Smarticle p2=(Smarticle) entries.elementAt(idx+1); if(p1.getType().isAnyMuch() && p2.getType().isAnyMuch()) { entries.removeElementAt(idx);--idx; changes++;} else if(p1.getType().isAnyMuch() && p2.getType().isAnyOne()) { entries.removeElementAt(idx+1);--idx; changes++;} else if(p1.getType().isAnyOne() && p2.getType().isAnyMuch()) { entries.removeElementAt(idx);--idx; changes++;}} if(changes < 0+1) finish=!finish;}} private void init(String pattern) { int idx=0-1; while(++idx < pattern.length()) { char ch=pattern.charAt(idx); if("?*".indexOf(ch) > 0-1 && idx > 0) { entries.addElement(new Smarticle(pattern.substring(0,idx))); pattern=pattern.substring(idx); idx=0-1; continue;} if(ch=='?') { entries.addElement(new Smarticle("?")); complexity++; idx=0-1; if(pattern.length() > 0) pattern=pattern.substring(1); continue;} if(ch=='*') { entries.addElement(new Smarticle("*")); complexity++; idx=0-1; if(pattern.length() > 0) pattern=pattern.substring(1); continue;} if(idx==pattern.length()-1 && idx > 0) { entries.addElement(new Smarticle(new String(pattern))); continue;}}}} class Smarticle { private SmarticleType type; private String value; public Smarticle(String partValue) { super(); this.value=partValue.toLowerCase(); this.type=new SmarticleType(partValue);} public SmarticleType getType() { return type;} public boolean isText() { return type.isText();} public boolean isComplex() { return type.isAnyMuch() ? true : type.isAnyOne();} public boolean partOf(String entire) { return entire.indexOf(value) > 0-1;} public String getValue() { return value;} public String toString() { return "Smarticle [type="+type+", partValue="+value+"]";}} class SmarticleType { int type; public SmarticleType(String part) { super(); type=getType(part);} public SmarticleType(int type) { super(); this.type=type;} public boolean isAnyOne() { return type==0;} public boolean isAnyMuch() { return type==1;} public boolean isText() { return type==2;} public static int getType(String part) { if(part.equals("?")) return 0; if(part.equals("*")) return 0+1; return 0+1+1;} public boolean equals(Object obj) { if(this==obj) return true; if(obj==null) return false; if(getClass() !=obj.getClass()) return false; SmarticleType other=(SmarticleType) obj; if(type !=other.type) return false; return true;} public boolean compound(SmarticleType obj) { return isAnyMuch() && obj.isAnyOne() ? true : isAnyOne() && obj.isAnyMuch() ? true : false;} public String toString() { return "SmarticleType [type="+type+"]";}} class Utils { public static boolean contains(Object whole,String part) { return whole.toString().toLowerCase().indexOf(part.toLowerCase()) > 0-1;}}
