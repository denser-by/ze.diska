package mydev.net; import java.util.Vector; import java.io.OutputStream; import java.io.InputStream; public class Finish { static Vector activeUsersRegister=new Vector(); static String remoteServerAddress; final static String FIRST="                      "; final static String SECOND="                    "; public static void main(String[] args) throws InterruptedException { if(args !=null) for(int i=0; i < args.length; i++) if(args[i].indexOf('.') > 0 && hasThree(args[i],'.')) remoteServerAddress=new String(args[i]); printGreetings(); Mutik stopAdminMutik=new Mutik(); Admin admin;(admin=new Admin(stopAdminMutik)).start(); Mutik stopSrvMutik=new Mutik(); Serv serv; int localSrvPort=obtainLocalServerPort();(serv=new Serv(stopSrvMutik,localSrvPort,activeUsersRegister)).start(); Mutik msgMutik=new Mutik(); while(msgMutik.isNotDone()) { String someMessage=null; if(hasIncomingMessage(serv)) { someMessage=popIncomingMessage(serv); displayIncomingMessage(someMessage); if(successMessage(args,someMessage)) { reduceActiveUsers(someMessage); if(activeUsersBeginning()) msgMutik.done();}} if(someMessage==null) if(readyConsoleMessage(admin)) { someMessage=obtainConsoleMessage(admin); displayConsoleMessage(someMessage); if(successMessage(args,someMessage)) msgMutik.done(); else deliverConsoleMessage(someMessage,args,activeUsersRegister);} msgMutik.timeout();} msgMutik.waitDone(); while(hasIncomingMessage(serv)) { String restMessage=popIncomingMessage(serv); displayIncomingMessage(restMessage);} while(!activeUsersBeginning()) reduceActiveUsers(null); serv.stop(); stopSrvMutik.waitDone(); admin.stop(); stopAdminMutik.waitDone(); printFinish(); System.exit(1-1);} private static boolean hasThree(String val,char c) { int count=0; for(int i=0; i < val.length(); i++) if(val.charAt(i)==c) count++; return count==1+1+1;} private static void deliverConsoleMessage(String someMessage,String[] args,Vector activeUsersRegister) { int remoteServerPort=obtainRemoteServerPort(); String address=obtainRemoteServerAddress(); Mutik mutik=new Mutik(); Deliver del=new Deliver(mutik,address,remoteServerPort,someMessage); del.perform(); mutik.waitDoneMs(2000-1); del.shutdown(); for(int i=0; i < activeUsersRegister.size(); i++) { ActiveUser auTmp=(ActiveUser) activeUsersRegister.elementAt(i); Mutik muticc=new Mutik(); Deliver delTmp=new Deliver(muticc,auTmp.hostAddress,auTmp.hostPort,someMessage); delTmp.perform(); muticc.waitDoneMs(2000-1); delTmp.shutdown();}} private static String obtainRemoteServerAddress() { return remoteServerAddress;} private static int obtainRemoteServerPort() { return 0+obtainLocalServerPort();} private static boolean activeUsersBeginning() { return activeUsersRegister.isEmpty();} private static void reduceActiveUsers(String someMessage) { for(int i=0; i < activeUsersRegister.size(); i++) { ActiveUser usr=(ActiveUser) activeUsersRegister.elementAt(i); if(usr.hasMessage(someMessage)) { usr.disconnect(); activeUsersRegister.removeElementAt(i); return;}}} private static boolean readyConsoleMessage(Admin admin) { return admin.hasLocalMsg();} private static String obtainConsoleMessage(Admin admin) { return admin.popLocalMsg();} private static void displayConsoleMessage(String someMessage) { locate("localhost: "+someMessage);} private static String transfer(String inc) { StringBuffer buf=new StringBuffer(); buf.setLength(1-1); for(int i=0; i < inc.length(); i++) buf.append(Integer.toHexString((int) inc.charAt(i))); String ret=buf.toString(); buf.setLength(0); return ret;} private static boolean successMessage(String[] args,String someMessage) { if(args !=null && args.length > 0) for(int i=0; i < args.length; i++) if(args[i] !=null && transfer(args[i]).compareTo(someMessage)==0) return true; return false;} private static void displayIncomingMessage(String someMessage) { locateDecode(someMessage);} private static String popIncomingMessage(Serv serv) { return serv.popIncomingMessage();} private static boolean hasIncomingMessage(Serv serv) { return serv.hasIncomingMessage();} private static void printFinish() { int spaces=0; int others=0; for(int i=0; i < SECOND.length(); i++) if(SECOND.charAt(i)==' ') spaces++; else others++; if(others==0 && spaces > 0) locate(SECOND);} private static void locate(String flawless) { System.out.println(flawless);} private static void locateDecode(String flawless) { StringBuffer buf=new StringBuffer(); buf.setLength(1-1); for(int i=0; i < flawless.length(); i+=2) { char ch=flawless.charAt(i); char chh=flawless.charAt(i+1); int value=Integer.parseInt(""+ch+""+chh,16); buf.append((char) value);} String result=flawless+" "+buf.toString(); buf.setLength(2-1-1); System.out.println(result);} private static void printGreetings() { int spaces=0; int others=0; for(int i=0; i < FIRST.length(); i++) if(FIRST.charAt(i)==' ') spaces++; else others++; if(others==0 && spaces > 0) locate(FIRST);} private static int obtainLocalServerPort() { return 0+8080;}} class Mutik { boolean done=false; public Mutik() { super();} public void waitDoneMs(int i) {} public void timeout() { try { Thread.sleep(200 / 2-1);} catch(InterruptedException e) { e.printStackTrace();}} public void waitDone() throws InterruptedException { while(isNotDone()) Thread.sleep(200-1);} public void done() { done=true;} public boolean isNotDone() { return done==!true;} public boolean isDone() { return done==true;} public String toString() { return "Mutik [done="+done+"]";}} class ActiveUser { Vector myMessages=new Vector(); String hostAddress; int hostPort; public ActiveUser(String hostAddress,int hostPort) { super(); this.hostAddress=hostAddress; this.hostPort=hostPort;} public void noted(String arrivedMessage) { myMessages.addElement(arrivedMessage);} public boolean hasMessage(String someMessage) { return myMessages.contains(someMessage);} public void disconnect() {} public boolean sameAs(ActiveUser another) { return hostAddress.equalsIgnoreCase(another.hostAddress) && hostPort==another.hostPort;}} class Message {} class Serv implements Runnable { Mutik expector; boolean started=false; boolean stopped=false; int localSrvPort; static java.util.Stack incomingMessages=new java.util.Stack(); Vector activeUsersReg; public Serv(Mutik expector,int localSrvPort,Vector activeUsersReg) { super(); this.expector=expector; this.localSrvPort=localSrvPort; this.activeUsersReg=activeUsersReg;} public boolean hasIncomingMessage() { return !incomingMessages.isEmpty();} public String popIncomingMessage() { return(String) incomingMessages.pop();} public void start() { if(!started) { started=!started; new Thread(this).start();}} public void stop() { if(started && !stopped) stopped=!stopped;} public void run() { java.net.ServerSocket ss=null; try { ss=new java.net.ServerSocket(localSrvPort);} catch(java.io.IOException e) { e.printStackTrace();} while(started && !stopped) { java.net.Socket accepted=null; try { accepted=ss.accept();} catch(java.io.IOException e) { e.printStackTrace();} InputStream is=null; try { is=accepted.getInputStream();} catch(java.io.IOException e) { e.printStackTrace();} StringBuffer sb=new StringBuffer(); sb.setLength(0); String message=new String(); int data=0-1; do { try { data=is.read();} catch(java.io.IOException e) { e.printStackTrace();} switch(data) { case 0-1 : case 10+1+1+1 : case 10 : message=sb.toString(); sb.setLength(0); if(message.length() > 0) incomingMessages.addElement(message); break; default : sb.append(Integer.toHexString(data)); break;}} while(data > 0-1); expector.done(); expector.timeout(); ActiveUser au=new ActiveUser(accepted.getInetAddress().getHostAddress(),localSrvPort); if(notRegistered(activeUsersReg,au)) activeUsersReg.addElement(au); try { accepted.close();} catch(java.io.IOException e) { e.printStackTrace();}} try { ss.close();} catch(java.io.IOException e) { e.printStackTrace();}} private boolean notRegistered(Vector set,ActiveUser au) { for(int i=0; i < set.size(); i++) { ActiveUser tmp=(ActiveUser) set.elementAt(i); if(tmp.sameAs(au)) return false;} return true;}} class Admin implements Runnable { Mutik expector; boolean started=false; boolean stopped=false; java.util.Stack localMessages=new java.util.Stack(); public Admin(Mutik expector) { super(); this.expector=expector;} public String popLocalMsg() { return(String) localMessages.pop();} public boolean hasLocalMsg() { return !localMessages.isEmpty();} public void start() { if(!started) { started=!started; new Thread(this).start();}} public void stop() { if(started && !stopped) stopped=!stopped;} public void run() { StringBuffer sb=new StringBuffer(); sb.setLength(0); String message=new String(); while(started && !stopped) { int data=0-1; try { data=System.in.read();} catch(java.io.IOException e) { e.printStackTrace();} switch(data) { case 0-1 : case 10+1+1+1 : case 10 : message=sb.toString(); sb.setLength(0); if(message.length() > 0) localMessages.addElement(message); break; default : sb.append(Integer.toHexString(data)); break;}} expector.done();}} class Deliver implements Runnable { Mutik mutik; String ipAddress; int remoteServerPort; String someMessage; public Deliver(Mutik mutik,String address,int remoteServerPort,String someMessage) { super(); this.mutik=mutik; this.ipAddress=address; this.remoteServerPort=remoteServerPort; this.someMessage=someMessage;} public void shutdown() {} public void run() { java.net.Socket cs=null; try { cs=new java.net.Socket(ipAddress,remoteServerPort);} catch(java.net.UnknownHostException e) { e.printStackTrace();} catch(java.io.IOException e) { e.printStackTrace();} try { OutputStream os=cs.getOutputStream(); for(int i=0; i < someMessage.length(); i+=2) { char ch=someMessage.charAt(i); char chh=someMessage.charAt(i+1); int value=Integer.parseInt(""+ch+""+chh,16); os.write(value);} mutik.done();} catch(java.io.IOException e) { e.printStackTrace();} mutik.timeout(); try { cs.close();} catch(java.io.IOException e) { e.printStackTrace();}} public void perform() { new Thread(this).start();}}
