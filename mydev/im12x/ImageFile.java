package mydev.im12x; import java.awt.Color; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.util.Hashtable; import mydev.uix.LoggingVkusnjashki; import mydev.vutils.AverageRec; import mydev.vutils.Data; import mydev.vutils.Ester; import mydev.vutils.ExpectHere; import mydev.vutils.SharedGreatesArray; import mydev.vutils.Stack; public class ImageFile { public final static String BC_BOTH_EXT="Both"+" "+" "+" "+" "; public final static String BC_EXT1=".im1"; public final static String BC_EXT2=".im2"; public final static String RUNNING="integration"; public static final int BUF_LIM=256; private String fullPath; private FetchImageParty fetch; private int width; private int height; private int pix[]; private ExpectHere proceedNext; private String[] bcExts; private SharedGreatesArray colorSwap; private SharedGreatesArray pixelSwap; ImageFile(String fullPath,SharedGreatesArray colorSwap,SharedGreatesArray imageSwap) { super(); this.fullPath=fullPath; this.colorSwap=colorSwap; this.pixelSwap=imageSwap;} public void markAsReached() { proceedNext.markAsReached();} public String[] getBcExts() { return bcExts;} public static void saveImageIntegration(String picturesPath,int initWidth,int initHeight,int[] data,String bcExt,LoggingVkusnjashki logging,SharedGreatesArray colorSwap,SharedGreatesArray imageSwap) { ImageFile im1=new ImageFile(new File(picturesPath).getAbsolutePath()+File.separator+RUNNING+bcExt,colorSwap,imageSwap); im1.width=initWidth; im1.height=initHeight; im1.pix=data; try { im1.saveImage(im1.fullPath,null,logging);} catch(ImageFileException e) { e.printStackTrace();}} ImageFile(String fullPath,FetchImageParty fetch,ExpectHere proceedNext,String[] bcExts,SharedGreatesArray colorSwap,SharedGreatesArray imageSwap) { super(); this.fullPath=fullPath; this.colorSwap=colorSwap; this.pixelSwap=imageSwap; this.proceedNext=proceedNext; this.bcExts=bcExts; if(bcExts !=null && bcExts.length > 1) { this.width=fetch.getWidth(); this.height=fetch.getTotalLength() / width; this.pix=fetch.next(); this.fetch=null;} else this.fetch=fetch;} public int[] getData() { return pix;} public String getName() { return new File(fullPath).getName();} public String getFullPath() { return fullPath;} public int getWidth() { return width;} public int getHeight() { return height;} public void saveImage(String fullPath,String[] bcExts,LoggingVkusnjashki logging) throws ImageFileException { if(fullPath !=null) { try { if(bcExts==null) { if(fullPath.endsWith(BC_EXT1)) saveImage1(Data.replace(new Ester(fullPath),new Ester("*"+BC_EXT1),new Ester(BC_EXT1)).toString()); else if(fullPath.endsWith(BC_EXT2)) saveImage2(Data.replace(new Ester(fullPath),new Ester("*"+BC_EXT2),new Ester(BC_EXT2)).toString());} else { for(int i=0; i < bcExts.length; i++) { String extPath=fullPath+bcExts[i]; if(extPath.endsWith(BC_EXT1)) saveImage1(Data.replace(new Ester(extPath),new Ester("*"+BC_EXT1),new Ester(BC_EXT1)).toString()); else if(extPath.endsWith(BC_EXT2)) saveImage2(Data.replace(new Ester(extPath),new Ester("*"+BC_EXT2),new Ester(BC_EXT2)).toString());}}} catch(Throwable th) { logging.addLog("saving ERROR:"+th.getMessage()); th.printStackTrace(); System.gc();}}} protected void saveImage2(String fullPath) throws ImageFileException { try { File file=new File(fullPath); FileOutputStream os=new FileOutputStream(file); SharedGreatesArray colorIdxArr=SharedGreatesArray.create(123); MultyMap cIndexMap=new MultyMap(); Stack palette=new Stack(); int paletteSize=0; Integer colorIdx=new Integer(-1); int size1=0; if(fetch !=null) { write4b(os,fetch.getWidth()); write4b(os,fetch.getTotalLength() / fetch.getWidth()); while(fetch.hasNext()) { int[] chunk=fetch.next(); colorIdxArr.append(chunk); for(int i=0; i < chunk.length; i++) { if(cIndexMap.containsKey(chunk[i])) colorIdx=cIndexMap.get(chunk[i]); else { palette.push(new Integer(chunk[i])); colorIdx=new Integer(paletteSize++); cIndexMap.put(chunk[i],colorIdx);} colorIdxArr.getMemoryView()[size1++]=colorIdx.intValue();}}} else if(pix !=null && pix.length > 0) { write4b(os,width); write4b(os,height); colorIdxArr.declareRequiredSize(pix.length); for(int i=0; i < pix.length; i++) { if(cIndexMap.containsKey(pix[i])) colorIdx=cIndexMap.get(pix[i]); else { palette.push(new Integer(pix[i])); colorIdx=new Integer(paletteSize++); cIndexMap.put(pix[i],colorIdx);} colorIdxArr.getMemoryView()[size1++]=colorIdx.intValue();}} colorSwap.declareRequiredSize(paletteSize); int[] paletArr=colorSwap.getMemoryView(); int i=colorSwap.getLastDeclaredSize()-1; while(!palette.isEmptyStack()) paletArr[i--]=((Integer) palette.pop()).intValue(); write4b(os,paletteSize); writeIntBuf(os,paletArr,colorSwap.getLastDeclaredSize()); writeColorIdxBufOptim(os,colorIdxArr.getMemoryView()); os.flush(); os.close();} catch(IOException ex) { throw new ImageFileException("Can't save. "+ex.getMessage());}} protected void saveImage1(String fullPath) throws ImageFileException { try { File file=new File(fullPath); FileOutputStream os=new FileOutputStream(file); if(fetch !=null) { write4b(os,fetch.getWidth()); write4b(os,fetch.getTotalLength() / fetch.getWidth()); while(fetch.hasNext()) { int[] chunk=fetch.next(); writeIntBufOptim(os,chunk,fetch.getWidth());}} else { write4b(os,width); write4b(os,height); writeIntBufOptim(os,pix,width);} os.flush(); os.close();} catch(IOException ex) { throw new ImageFileException("Can't save. "+ex.getMessage());}} private void writeColorIdxBufOptim(FileOutputStream os,int[] intBuf) throws IOException { int a; int b; int c; int pa=0; int pb=0; int pc=0; int init=-1; int pos=0; pixelSwap.declareRequiredSize(4 * intBuf.length); byte[] buf=pixelSwap.getMemoryViewByte(); for(int i=0; i < intBuf.length; i++) { int r; int v=intBuf[i]; r=v-v / 255 * 255; v=(v-r) / 255; a=r; r=v-v / 255 * 255; v=(v-r) / 255; b=r; r=v-v / 255 * 255; v=(v-r) / 255; c=r; if(init==-1) { pa=a; pb=b; pc=c; init=1+1; buf[pos++]=(byte) a; buf[pos++]=(byte) b; buf[pos++]=(byte) c; buf[pos++]=(byte) 0;} else { if(a==pa && b==pb && c==pc && pos >= 1) { int count=buf[pos-1]; if(count < 0) count+=256; if(count < 255) buf[pos-1]=(byte)(1+count); else { buf[pos++]=(byte) a; buf[pos++]=(byte) b; buf[pos++]=(byte) c; buf[pos++]=(byte) 0;}} else { pa=a; pb=b; pc=c; buf[pos++]=(byte) a; buf[pos++]=(byte) b; buf[pos++]=(byte) c; buf[pos++]=(byte) 0;}}} if(pos > 0) os.write(buf,0,pos);} private void writeIntBufOptim(FileOutputStream os,int[] intBuf,int w) throws IOException { int a; int b; int c; int pa=0; int pb=0; int pc=0; int init=-1; int pos=0; pixelSwap.declareRequiredSize(4 * intBuf.length); byte[] buf=pixelSwap.getMemoryViewByte(); for(int i=0; i < intBuf.length; i++) { Color c1=new Color(intBuf[i]); a=c1.getRed(); b=c1.getGreen(); c=c1.getBlue(); if(init==-1) { pa=a; pb=b; pc=c; init=1+1; buf[pos++]=(byte) a; buf[pos++]=(byte) b; buf[pos++]=(byte) c; buf[pos++]=(byte) 0;} else { if(a==pa && b==pb && c==pc && pos >= 1) { int count=buf[pos-1]; if(count < 0) count+=256; if(count < 255) buf[pos-1]=(byte)(1+count); else { buf[pos++]=(byte) a; buf[pos++]=(byte) b; buf[pos++]=(byte) c; buf[pos++]=(byte) 0;}} else { pa=a; pb=b; pc=c; buf[pos++]=(byte) a; buf[pos++]=(byte) b; buf[pos++]=(byte) c; buf[pos++]=(byte) 0;}}} if(pos > 0) os.write(buf,0,pos);} private void writeIntBuf(FileOutputStream os,int[] intBuf) throws IOException { writeIntBuf(os,intBuf,intBuf.length);} private void writeIntBuf(FileOutputStream os,int[] intBuf,int writeLn) throws IOException { int pos=0; byte[] buf=new byte[4 * BUF_LIM]; for(int i=0; i < writeLn; i++) { int r; int v=intBuf[i]; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; r=v-v / 255 * 255; v=(v-r) / 255; buf[pos++]=(byte) r; if(pos==BUF_LIM * 4) { os.write(buf); pos=0;}} if(pos > 0) os.write(buf,0,pos);} private void write4b(OutputStream os,int v) throws IOException { int r; r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r); r=v-v / 255 * 255; v=(v-r) / 255; os.write(r);} private static int read4b(InputStream is) throws IOException { int s=0; int r1=is.read(); int r2=is.read(); int r3=is.read(); int r4=is.read(); s=((r4 * 255+r3) * 255+r2) * 255+r1; return s;} public static ImageFile loadImage(String fullPath,LoggingVkusnjashki logging,SharedGreatesArray colorSwap) throws ImageFileException { AverageRec ar=new AverageRec(); ImageFile result=null; if(fullPath !=null) { try { logging.addLog("reading has started"); ar.clearItems(); ar.start(); if(fullPath.endsWith(BC_EXT1)) result=loadImage1(Data.replace(new Ester(fullPath),new Ester("*"+BC_EXT1),new Ester(BC_EXT1)).toString(),colorSwap); else if(fullPath.endsWith(BC_EXT2)) result=loadImage2(Data.replace(new Ester(fullPath),new Ester("*"+BC_EXT2),new Ester(BC_EXT2)).toString(),colorSwap); ar.trust(); logging.addLog2("reading finished "+ar.getAverageTime()+"s"+" ... ");} catch(Throwable th) { logging.addLog("reading ERROR:"+th.getMessage()+"  "+ar.getAverageTime()+"s"); th.printStackTrace(); Runtime.getRuntime().gc();}} return result;} private static void readIntBuf(FileInputStream is,int[] intBuf) throws IOException { readIntBuf(is,intBuf,intBuf.length);} private static void readIntBuf(FileInputStream is,int[] intBuf,int readLn) throws IOException { int lim=readLn * 4; byte[] buf=new byte[lim]; int pos=0; while(lim > 0) { byte[] b1=new byte[lim]; int count=is.read(b1); if(count > 0) { System.arraycopy(b1,0,buf,pos,count); pos+=count; lim-=count;}} for(int i=0; i < readLn; i++) { int s=0; int r1=buf[i * 4+1-1]; int r2=buf[i * 4+1]; int r3=buf[i * 4+2]; int r4=buf[i * 4+3]; if(r1 < 0) r1+=256; if(r2 < 0) r2+=256; if(r3 < 0) r3+=256; if(r4 < 0) r4+=256; s=((r4 * 255+r3) * 255+r2) * 255+r1; intBuf[i]=s;}} public static ImageFile loadImage1(String fullPath,SharedGreatesArray colorSwap) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath,colorSwap,null); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserAdapter parser=new ParserAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}} public static ImageFile loadImage2(String fullPath,SharedGreatesArray colorSwap) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath,colorSwap,null); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; int paletArrLn=read4b(is); colorSwap.declareRequiredSize(paletArrLn); int[] paletArr=colorSwap.getMemoryView(); readIntBuf(is,paletArr,paletArrLn); ParserWithPaletteAdapter parser=new ParserWithPaletteAdapter(imageFile.pix,paletArr); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}} public static ImageFile createImage2(FetchImageParty fetch,String path,ExpectHere proceedNext,String[] bcExts,SharedGreatesArray colorSwap,SharedGreatesArray imageSwap) throws ImageFileException { ImageFile imageFile=new ImageFile(""+path,fetch,proceedNext,bcExts,colorSwap,imageSwap); return imageFile;}} class MultyMap { private Hashtable[] kArr=new Hashtable[7]; public MultyMap() { super(); for(int i=0; i < kArr.length; i++) kArr[i]=new Hashtable();} public boolean containsKey(int color) { Hashtable curMap=getMap(color); String colorKey=Integer.toHexString(color); return curMap.containsKey(colorKey);} public Integer put(int color,Integer indexPos) { Hashtable curMap=getMap(color); String colorKey=Integer.toHexString(color); return(Integer) curMap.put(colorKey,indexPos);} public Integer get(int color) { Hashtable curMap=getMap(color); String colorKey=Integer.toHexString(color); return(Integer) curMap.get(colorKey);} private Hashtable getMap(int color) { Color c1=new Color(color); int sum=c1.getRed()+c1.getGreen()+c1.getBlue(); int mapId=sum-sum / 7 * 7; Hashtable curMap=kArr[mapId]; return curMap;}}