package mydev.about; import mydev.vutils.Queue; public class Surface extends FillFullable implements Decompose { protected Queue points3D=new Queue(); protected int colorPicture; public Surface() { this(ColorsArray.blackColorInt);} public Surface(int color) { this(color,false,ColorsArray.lightGrayPoint.ic());} public Surface(int color,int colorPicture) { this(color,false,colorPicture);} public Surface(int colorConture,boolean solid,int colorPicture) { super(colorConture,solid); this.colorPicture=colorPicture;} public Surface addPoint(Point2D pt) { points3D.enqueueQueueRecord(pt); return this;} public void represent(Matrix2D matrix) { matrix.addPath3D(this);} public void toPen(Canvas ics,Paint pn) { if(full) toPenSolid(ics,pn); if(color !=colorPicture) toPenConture(ics,pn); else if(!full) toPenConture(ics,pn);} public void toPenSolid(Canvas ics,Paint pn) { int xx[]=new int[(int) points3D.sizeOfQueue()]; int yy[]=new int[xx.length]; Object[] queueRecordsArray=points3D.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { Point2D b=(Point2D) queueRecordsArray[i]; xx[i]=b.getX(); yy[i]=b.getY();} pn.setColor(colorPicture); ics.fillConture(xx,yy,pn);} public void toPenConture(Canvas ics,Paint pn) { Point2D a=null; Point2D b; Point2D first=null; Object[] queueRecordsArray=points3D.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { if(first==null) { first=(Point2D) queueRecordsArray[i]; a=first;} else { b=(Point2D) queueRecordsArray[i]; ics.drawLine(a.getX(),a.getY(),b.getX(),b.getY(),pn); a=b;}} b=first; if(a !=null && b !=null) ics.drawLine(a.getX(),a.getY(),b.getX(),b.getY(),pn);} public String toString() { return "Surface [points3D="+points3D+"]";} public Line3D line(int lineIdx) { Point3D a=(Point3D) points3D.getQueueRecord(lineIdx); Point3D b=(Point3D) points3D.getQueueRecord(lineIdx==points3D.sizeOfQueue()-1 ? 0 : lineIdx+1); Line3D result=new Line3D(a,b); return result;} public Line3D[] ribs() { Object[] queueRecordsArray=points3D.getQueueRecordsArray(); Line3D[] result=new Line3D[queueRecordsArray.length]; for(int i=0; i < result.length; i++) { Point3D a=(Point3D) queueRecordsArray[i]; Point3D b=(Point3D) queueRecordsArray[i==points3D.sizeOfQueue()-1 ? 0 : i+1]; result[i]=new Line3D(a,b);} return result;} public Line2D[] ribsProjections() { return null;} public Point3D[] vertices() { return null;} public Point2D[] verticesProjections() { Point2D[] result=new Point2D[(int) points3D.sizeOfQueue()]; for(int i=0; i < result.length; i++) result[i]=(Point2D) points3D.getQueueRecord(i); return result;} public Triangle3D[] planes() { return null;} public Triangle2D[] planesProjections() { return null;} public double perim() { double result=0f; Line2D[] ribsProjections=ribsProjections(); for(int i=0; i < ribsProjections.length; i++) result+=ribsProjections[i].length(); return result;} public Triangle2D[] trianglesIterator(Point2D mainVertex) { Line2D[] ribsProjections=ribsProjections(); Triangle2D[] result=new Triangle2D[ribsProjections.length]; for(int i=0; i < ribsProjections.length; i++) result[i]=new Triangle2D(mainVertex,ribsProjections[i]); return result;} public Triangle2D[] midpointTriangles() { Point2D mainVertex=midpoint(); Triangle2D[] triangles=trianglesIterator(mainVertex); return triangles;} public Point2D midpoint() { double sumX=0f; double sumY=0f; long size=0L; Point2D[] verticesProjections=verticesProjections(); for(int i=0; i < verticesProjections.length; i++) { Point2D curPoint=verticesProjections[i]; sumX+=curPoint.getX(); sumY+=curPoint.getY(); size++;} Point2D avgPoint=new Point2D(sumX / size,sumY / size); return avgPoint;} public double area() { double result=0f; Triangle2D[] midpointTriangles=midpointTriangles(); for(int i=0; i < midpointTriangles.length; i++) result+=midpointTriangles[i].area(); return result;}}