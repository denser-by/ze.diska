package mydev.about; public class Point3D extends Point2D implements Reposition { protected int z; public Point3D() { super();} public Point3D(int x,int y,int z) { super(x,y); this.z=z;} public Point3D(int x,int y,int z,int color) { super(x,y,color); this.z=z;} public Point3D(float x,float y,float z) { super(x,y); this.z=(int)(z+0.5f);} public Point3D(float x,float y,float z,int color) { super(x,y,color); this.z=(int)(z+0.5f);} public Point3D(double x,double y,double z) { this((float) x,(float) y,(float) z);} public Point3D(double x,double y,double z,int color) { this((float) x,(float) y,(float) z,color);} public Point3D(short x,short y,short z) { super(x,y); this.z=z;} public Point3D(short x,short y,short z,int color) { super(x,y,color); this.z=z;} public Point3D(Point3D p) { this(p,p.color);} public Point3D(Point3D p,int color) { super(p,color); this.z=p.z;} public void represent(Matrix2D matrix) { matrix.addPoint(this);} public void toPen(Canvas ics,Paint pn) { ics.drawPoint(x,y,z,pn);} public void shift(Vector3 shVect) { super.shift(shVect); if(shVect.hasZ()) this.z+=shVect.dz;} public void moveTo(Point3D newLoc) { super.moveTo(newLoc); this.z=newLoc.z;} public void moveTo(int newX,int newY,int newZ) { super.moveTo(newX,newY); this.z=newZ;} public void moveTo(float newX,float newY,float newZ) { super.moveTo(newX,newY); this.z=(int)(newZ+0.5f);} public void moveTo(double newX,double newY,double newZ) { moveTo((float) newX,(float) newY,(float) newZ);} public void moveTo(short newX,short newY,short newZ) { super.moveTo(newX,newY); this.z=newZ;} public int getZ() { return z;} public void setZ(int z) { this.z=z;} public int dz(Point3D p) { return z > p.z ? z-p.z : p.z-z;} public Point3D middleDistancePoint(Point3D p) { Point3D result=new Line3D(this,p).midpoint(); return result;} public double distance(Point3D p) { return Math.sqrt((long) dx(p) *(long) dx(p)+(long) dy(p) *(long) dy(p)+(long) dz(p) *(long) dz(p));} public double distance(Line3D side) { double dist1=distance(side.getP1()); double dist2=distance(side.getP2()); double height=new Triangle3D(this,side).height(this); if(height <= dist1 && height <= dist2) return height; return dist1 <= dist2 ? dist1 : dist2;} public double distance(Plane3D plane) { Line3D perpLine=distanceLine(plane); if(perpLine !=null) return perpLine.length(); return 0.f;} public Line3D distanceLine(Plane3D plane) { Triangle3D triPlane=plane.getTriangle(); if(triPlane.area() > 0.f) { double distA=distance(triPlane.A()); double distB=distance(triPlane.B()); double distC=distance(triPlane.C()); double R=(distA+distB+distC) / 3.f+1.f; Sphere sphere=new Sphere(this,R); Circle3D circle=sphere.getIntersection(plane); Line3D result=new Line3D(this,circle.getCenter()); return result;} return null;} public Line3D line(Point3D p) { return new Line3D(this,p,Color.middleColor(this,p.color));} public Triangle3D triangle(Line3D line) { return new Triangle3D(this,line,Color.middleColor(this,line));} public Triangle3D triangle(Point3D p,Point3D p2) { return new Triangle3D(this,p,p2,Color.middleColor(this,p,p2));} public Circle3D circle(Point3D p,Plane3D plane) { return new Circle3D(this,this.distance(p),plane,Color.middleColor(this,p));} public Circle3D circle(int r,Plane3D plane) { return new Circle3D(this,r,plane,color);} public Sphere sphere(Point3D p) { return new Sphere(this,this.distance(p),Color.middleColor(this,p));} public boolean belongs(Line3D line) { boolean result=line.getP1().distance(this)+line.getP2().distance(this)==line.length(); return result;} public boolean belongs(Circle3D circle) { boolean result=circle.center.distance(this) <= circle.r; return result;} public boolean belongs(Parallelepiped rectangle) { if(x >= rectangle.uc.x && x <= rectangle.uc.x+rectangle.width) if(y >= rectangle.uc.y && y <= rectangle.uc.y+rectangle.height) if(z >= rectangle.uc.z && z <= rectangle.uc.z+rectangle.depth) return true; return false;} public boolean belongs(Cube rectangle) { if(x >= rectangle.center.x-rectangle.r && x <= rectangle.center.x+rectangle.r) if(y >= rectangle.center.y-rectangle.r && y <= rectangle.center.y+rectangle.r) if(z >= rectangle.center.z-rectangle.r && z <= rectangle.center.z+rectangle.r) return true; return false;} public boolean belongs(Pyramid pyr) { return false;} public boolean belongs(Triangle3D triangle) { Line3D AB=triangle.AB(); Line3D BC=triangle.BC(); Line3D AC=triangle.AC(); double areaSum=triangle.area(); Triangle3D firstPart=new Triangle3D(this,AB); Triangle3D secondPart=new Triangle3D(this,BC); Triangle3D thirdPart=new Triangle3D(this,AC); if(firstPart.area()+secondPart.area()+thirdPart.area() <= areaSum) return true; return false;} public boolean belongs(Plane3D plane) { if(belongs((Triangle3D) plane)) return true; double S0=plane.area(); double S1=new Triangle3D(this,plane.AB()).area(); double S2=new Triangle3D(this,plane.BC()).area(); double S3=new Triangle3D(this,plane.AC()).area(); if(S1+S2==S3+S0) return true; if(S1+S2==S3-S0) return true; if(S1+S3==S2+S0) return true; if(S1+S3==S2-S0) return true; if(S2+S3==S1+S0) return true; if(S2+S3==S1-S0) return true; return false;} public boolean equals(Object o) { if(o !=null && o instanceof Point3D) return x==((Point3D) o).x && y==((Point3D) o).y && z==((Point3D) o).z; return false;} public String toString() { return "Point("+x+","+y+","+z+")";} public Point2D getProjection(FourCornersConture3D plane,FourCornersConture2D screenProj) { plane.getP1(); plane.getP2(); plane.getP3(); plane.getP4(); Point2D result=new Point2D(); return result;} public void update(Point3D point) { this.moveTo(point);}}