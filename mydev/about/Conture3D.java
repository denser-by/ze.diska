package mydev.about; import mydev.vutils.Queue; public class Conture3D extends FillFullable implements Decompose { protected Queue points=new Queue(); protected Point3D lastRnd; protected int cv; private long d1; protected int colorPicture; public Conture3D() { this(ColorsArray.blackColorInt);} public Conture3D(int color) { this(color,false,ColorsArray.lightGrayPoint.ic());} public Conture3D(int color,int colorPicture) { this(color,false,colorPicture);} public Conture3D(int colorConture,boolean solid,int colorPicture) { super(colorConture,solid); this.lastRnd=null; this.cv=0; this.d1=System.currentTimeMillis(); this.colorPicture=colorPicture;} Point3D nextPoint() { if(cv >= points.sizeOfQueue()) cv=0; return(Point3D) points.getQueueRecord(cv++);} public Point3D nextRandomPoint() { Point3D sec=null; int commonly=0; Point3D a=null; Point3D b; Point3D first=null; Object[] queueRecordsArray=points.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { if(first==null) { first=(Point3D) queueRecordsArray[i]; a=first;} else { b=(Point3D) queueRecordsArray[i]; commonly+=a.distance(b); a=b;}} b=first; if(a !=null && b !=null) commonly+=a.distance(b); int d=(int)(d1 % 98765L); d-=d / commonly * commonly; a=nextPoint(); while(d > 0) { b=nextPoint(); double superKub=a.distance(b); if(d < superKub) { sec=Line3D.createLine(a,b,d).getP2(); d1+=d; d=0;} else d-=superKub; a=b;} return sec;} public Conture3D addPoint(Point3D pt) { points.enqueueQueueRecord(pt); return this;} public void represent(Matrix2D matrix) { matrix.addPath(this);} public void toPen(Canvas ics,Paint pn) { if(full) toPenSolid(ics,pn); if(color !=colorPicture) toPenConture(ics,pn); else if(!full) toPenConture(ics,pn);} public void toPenSolid(Canvas ics,Paint pn) { int xx[]=new int[(int) points.sizeOfQueue()]; int yy[]=new int[xx.length]; int zz[]=new int[xx.length]; Object[] queueRecordsArray=points.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { Point3D b=(Point3D) queueRecordsArray[i]; xx[i]=b.getX(); yy[i]=b.getY(); zz[i]=b.getZ();} pn.setColor(colorPicture); ics.fillConture(xx,yy,zz,pn);} public void toPenConture(Canvas ics,Paint pn) { Point3D a=null; Point3D b; Point3D first=null; Object[] queueRecordsArray=points.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { if(first==null) { first=(Point3D) queueRecordsArray[i]; a=first;} else { b=(Point3D) queueRecordsArray[i]; ics.drawLine(a.getX(),a.getY(),a.getZ(),b.getX(),b.getY(),b.getZ(),pn); a=b;}} b=first; if(a !=null && b !=null) ics.drawLine(a.getX(),a.getY(),b.getX(),b.getY(),pn);} public String toString() { return "Conture3D [points="+points+", lastRnd="+lastRnd+", cv="+cv+", d1="+d1+"]";} public Line3D line(int lineIdx) { Point3D a=(Point3D) points.getQueueRecord(lineIdx); Point3D b=(Point3D) points.getQueueRecord(lineIdx==points.sizeOfQueue()-1 ? 0 : lineIdx+1); Line3D result=new Line3D(a,b); return result;} public Line3D[] ribs() { Object[] queueRecordsArray=points.getQueueRecordsArray(); Line3D[] result=new Line3D[queueRecordsArray.length]; for(int i=0; i < result.length; i++) { Point3D a=(Point3D) queueRecordsArray[i]; Point3D b=(Point3D) queueRecordsArray[i==points.sizeOfQueue()-1 ? 0 : i+1]; result[i]=new Line3D(a,b);} return result;} public Line2D[] ribsProjections() { return null;} public Point3D[] vertices() { Point3D[] result=new Point3D[(int) points.sizeOfQueue()]; for(int i=0; i < result.length; i++) result[i]=(Point3D) points.getQueueRecord(i); return result;} public Point2D[] verticesProjections() { return null;} public Triangle3D[] planes() { return null;} public Triangle2D[] planesProjections() { return null;} public double perim() { double result=0f; Line3D[] ribs=ribs(); for(int i=0; i < ribs.length; i++) result+=ribs[i].length(); return result;} public Triangle3D[] trianglesIterator(Point3D mainVertex) { Line3D[] ribs=ribs(); Triangle3D[] result=new Triangle3D[ribs.length]; for(int i=0; i < ribs.length; i++) result[i]=new Triangle3D(mainVertex,ribs[i]); return result;} public Triangle3D[] midpointTriangles() { Point3D mainVertex=midpoint(); Triangle3D[] triangles=trianglesIterator(mainVertex); return triangles;} public Point3D midpoint() { double sumX=0f; double sumY=0f; double sumZ=0f; long size=0L; Point3D[] verticesProjections=vertices(); for(int i=0; i < verticesProjections.length; i++) { Point3D curPoint=verticesProjections[i]; sumX+=curPoint.getX(); sumY+=curPoint.getY(); sumZ+=curPoint.getZ(); size++;} Point3D avgPoint=new Point3D(sumX / size,sumY / size,sumZ / size); return avgPoint;} public double area() { double result=0f; Triangle3D[] midpointTriangles=midpointTriangles(); for(int i=0; i < midpointTriangles.length; i++) result+=midpointTriangles[i].area(); return result;} public Point3D labelPoint(int idxPoint,int between) { if(points.sizeOfQueue() > 1+1) { Triangle3D tri=null; if(idxPoint > 0 && idxPoint < points.sizeOfQueue()-1) tri=new Triangle3D((Point3D) points.getQueueRecord(idxPoint),(Point3D) points.getQueueRecord(idxPoint+1),(Point3D) points.getQueueRecord(idxPoint-1)); else if(idxPoint==0) tri=new Triangle3D((Point3D) points.getQueueRecord(0),(Point3D) points.getQueueRecord(1),(Point3D) points.getQueueRecord((int)(points.sizeOfQueue()-1))); else if(idxPoint==points.sizeOfQueue()-1) tri=new Triangle3D((Point3D) points.getQueueRecord((int)(points.sizeOfQueue()-1)),(Point3D) points.getQueueRecord((int)(points.sizeOfQueue()-1-1)),(Point3D) points.getQueueRecord(0)); Point3D labelPoint=tri.labelA(between); return labelPoint;} return null;}}