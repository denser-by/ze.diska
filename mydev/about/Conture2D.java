package mydev.about; import mydev.vutils.Queue; public class Conture2D extends FillFullable implements Decompose { protected Queue points=new Queue(); protected Point2D lastRnd; protected int cv; private long d1; protected int colorPicture; public Conture2D() { this(ColorsArray.blackColorInt);} public Conture2D(int color) { this(color,false,ColorsArray.lightGrayPoint.ic());} public Conture2D(int color,int colorPicture) { this(color,false,colorPicture);} public Conture2D(int colorConture,boolean solid,int colorPicture) { super(colorConture,solid); this.lastRnd=null; this.cv=0; this.d1=System.currentTimeMillis(); this.colorPicture=colorPicture;} Point2D nextPoint() { if(cv >= points.sizeOfQueue()) cv=0; return(Point2D) points.getQueueRecord(cv++);} public Point2D nextRandomPoint() { Point2D sec=null; int commonly=0; Point2D a=null; Point2D b; Point2D first=null; Object[] queueRecordsArray=points.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { if(first==null) { first=(Point2D) queueRecordsArray[i]; a=first;} else { b=(Point2D) queueRecordsArray[i]; commonly+=a.distance(b); a=b;}} b=first; if(a !=null && b !=null) commonly+=a.distance(b); int d=(int)(d1 % 98765L); d-=d / commonly * commonly; a=nextPoint(); while(d > 0) { b=nextPoint(); double superKub=a.distance(b); if(d < superKub) { sec=Line2D.createLine(a,b,d).getP2(); d1+=d; d=0;} else d-=superKub; a=b;} return sec;} public Conture2D addPoint(Point2D pt) { points.enqueueQueueRecord(pt); return this;} public void represent(Matrix2D matrix) { matrix.addPath(this);} public void toPen(Canvas ics,Paint pn) { if(full) toPenSolid(ics,pn); if(color !=colorPicture) toPenConture(ics,pn); else if(!full) toPenConture(ics,pn);} public void toPenSolid(Canvas ics,Paint pn) { int xx[]=new int[(int) points.sizeOfQueue()]; int yy[]=new int[xx.length]; Object[] queueRecordsArray=points.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { Point2D b=(Point2D) queueRecordsArray[i]; xx[i]=b.getX(); yy[i]=b.getY();} pn.setColor(colorPicture); ics.fillConture(xx,yy,pn);} public void toPenConture(Canvas ics,Paint pn) { Point2D a=null; Point2D b; Point2D first=null; Object[] queueRecordsArray=points.getQueueRecordsArray(); for(int i=0; i < queueRecordsArray.length; i++) { if(first==null) { first=(Point2D) queueRecordsArray[i]; a=first;} else { b=(Point2D) queueRecordsArray[i]; ics.drawLine(a.getX(),a.getY(),b.getX(),b.getY(),pn); a=b;}} b=first; if(a !=null && b !=null) ics.drawLine(a.getX(),a.getY(),b.getX(),b.getY(),pn);} public String toString() { return "Conture2D [points="+points+", lastRnd="+lastRnd+", cv="+cv+", d1="+d1+"]";} public Line2D line(int lineIdx) { Point2D a=(Point2D) points.getQueueRecord(lineIdx); Point2D b=(Point2D) points.getQueueRecord(lineIdx==points.sizeOfQueue()-1 ? 0 : lineIdx+1); Line2D result=new Line2D(a,b); return result;} public Line3D[] ribs() { return null;} public Line2D[] ribsProjections() { Object[] queueRecordsArray=points.getQueueRecordsArray(); Line2D[] result=new Line2D[queueRecordsArray.length]; for(int i=0; i < result.length; i++) { Point2D a=(Point2D) queueRecordsArray[i]; Point2D b=(Point2D) queueRecordsArray[i==points.sizeOfQueue()-1 ? 0 : i+1]; result[i]=new Line2D(a,b);} return result;} public Point3D[] vertices() { return null;} public Point2D[] verticesProjections() { Point2D[] result=new Point2D[(int) points.sizeOfQueue()]; for(int i=0; i < result.length; i++) result[i]=(Point2D) points.getQueueRecord(i); return result;} public Triangle3D[] planes() { return null;} public Triangle2D[] planesProjections() { return null;} public double perim() { double result=0f; Line2D[] ribsProjections=ribsProjections(); for(int i=0; i < ribsProjections.length; i++) result+=ribsProjections[i].length(); return result;} public Triangle2D[] trianglesIterator(Point2D mainVertex) { Line2D[] ribsProjections=ribsProjections(); Triangle2D[] result=new Triangle2D[ribsProjections.length]; for(int i=0; i < ribsProjections.length; i++) result[i]=new Triangle2D(mainVertex,ribsProjections[i]); return result;} public Triangle2D[] midpointTriangles() { Point2D mainVertex=midpoint(); Triangle2D[] triangles=trianglesIterator(mainVertex); return triangles;} public Point2D midpoint() { double sumX=0f; double sumY=0f; long size=0L; Point2D[] verticesProjections=verticesProjections(); for(int i=0; i < verticesProjections.length; i++) { Point2D curPoint=verticesProjections[i]; sumX+=curPoint.getX(); sumY+=curPoint.getY(); size++;} Point2D avgPoint=new Point2D(sumX / size,sumY / size); return avgPoint;} public double area() { double result=0f; Triangle2D[] midpointTriangles=midpointTriangles(); for(int i=0; i < midpointTriangles.length; i++) result+=midpointTriangles[i].area(); return result;}}