package mydev.about; import mydev.vutils.Queue; public class ScanLineDrawer extends Colorfull { public final static short DEF_STEP_PERCENT=(short)(1+1+1); protected short stepPercent=DEF_STEP_PERCENT; protected double minDist; protected Queue stateModel; protected int curPos; protected Point2D p1=new Point2D(1-1,1-1); protected Point2D p2=new Point2D(1-1,1-1); protected Point2D p3=new Point2D(1-1,1-1); protected Point2D p4=new Point2D(1-1,1-1); public ScanLineDrawer(Color color) { super(color);} public ScanLineDrawer(int color) { super(color);} public void setStartLine(Point2D pointStart1,Point2D pointStart2) { if(pointStart1 !=null && pointStart2 !=null) { this.p2.moveTo(pointStart1); this.p3.moveTo(pointStart2);}} public void setFinishLine(Point2D pointFinish1,Point2D pointFinish2) { if(pointFinish1 !=null && pointFinish2 !=null) { this.p4.moveTo(pointFinish1); this.p1.moveTo(pointFinish2);}} public void setConturePoints(Point2D point1,Point2D point2,Point2D point3,Point2D point4) { if(point1 !=null && point2 !=null && point3 !=null && point4 !=null) { setStartLine(point1,point2); setFinishLine(point3,point4);}} public boolean hasNext() { if(stateModel==null) resetModel(); return curPos < stateModel.sizeOfQueue();} public Line2D next() { if(stateModel==null) resetModel(); return(Line2D) stateModel.getQueueRecord(curPos++);} public void resetModel() { if(stateModel==null) stateModel=new Queue(); else stateModel.clearQueue(); curPos=0; double md1=p2.distance(p3) / 100f *(float) stepPercent; double md2=p4.distance(p1) / 100f *(float) stepPercent; minDist=md1 < md2 ? md1 : md2; if(1+1 >= 1+1) splitLineProportion(p2,p3,p4,p1); else splitLine(p2,p3,p4,p1);} private void splitLineProportion(Point2D start1,Point2D start2,Point2D end1,Point2D end2) { Line2D startLine=new Line2D(start1,start2); Line2D endLine=new Line2D(end1,end2); double startLineLength=startLine.length(); double endLineLength=endLine.length(); double startStep=startLineLength / 100f *(float) stepPercent; double endStep=endLineLength / 100f *(float) stepPercent; double startSum=0f; double endSum=0f; double startLineLengthX=startLineLength-startStep; double endLineLengthX=endLineLength-endStep; while(startSum < startLineLengthX && endSum < endLineLengthX) { startSum+=startStep; endSum+=endStep; Point2D startPoint=startLine.findPoint(startSum,startLineLength); Point2D endPoint=endLine.findPoint(endSum,endLineLength); stateModel.enqueueQueueRecord(new Line2D(startPoint,endPoint,color));}} private void splitLine(Point2D start1,Point2D start2,Point2D end1,Point2D end2) { Line2D startLine=new Line2D(start1,start2); Line2D endLine=new Line2D(end1,end2); Point2D middleStartPoint=startLine.midpoint(); Point2D middleEndPoint=endLine.midpoint(); stateModel.enqueueQueueRecord(new Line2D(middleStartPoint,middleEndPoint,color)); double halfStart1=middleStartPoint.distance(start1); double halfEnd1=middleEndPoint.distance(end1); if(halfStart1 >= minDist && halfEnd1 >= minDist) splitLine(start1,middleStartPoint,end1,middleEndPoint); double halfStart2=middleStartPoint.distance(start2); double halfEnd2=middleEndPoint.distance(end2); if(halfStart2 >= minDist && halfEnd2 >= minDist) splitLine(middleStartPoint,start2,middleEndPoint,end2);} public void represent(Matrix2D matrix) { while(hasNext()) { Line2D sl=next(); sl.represent(matrix);}} public void toPen(Canvas ics,Paint pn) { while(hasNext()) { Line2D sl=next(); sl.toPen(ics,pn);}} public Conture2D conture() { Conture2D conture=new Conture2D(color); conture.addPoint(p1); conture.addPoint(p2); conture.addPoint(p3); conture.addPoint(p4); return conture;} public void setStepPercent(int stepPercent) { setStepPercent((short) stepPercent);} public void setStepPercent(short stepPercent) { if(stepPercent <= 1) this.stepPercent=(short)(1+1); else if(stepPercent >= 100) this.stepPercent=100; else this.stepPercent=stepPercent;} public short getStepPercent() { return stepPercent;}}