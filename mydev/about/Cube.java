package mydev.about; public class Cube extends Sphere { protected float angleX; protected float angleY; private CubeDrawSupport cds; private CubeChanges cc; public Cube(Point3D center,int r) { this(center,r,0f,0f,center.color,false);} public Cube(Point3D center,int r,int color,boolean solid) { this(center,r,0f,0f,color,solid);} public Cube(Point3D center,float r,int color,boolean solid) { this(center,(int)(r+0.5f),0f,0f,color,solid);} public Cube(Point3D center,double r,int color,boolean solid) { this(center,(float) r,0f,0f,color,solid);} public Cube(Point3D center,int r,float angleX,float angleY) { this(center,r,angleX,angleY,center.color,false);} public Cube(Point3D center,int r,float angleX,float angleY,int color) { this(center,r,angleX,angleY,color,false);} public Cube(Point3D center,int r,float angleX,float angleY,int color,boolean solid) { super(center,r,color,solid); this.angleX=angleX; this.angleY=angleY; init(color);} public Cube(Point3D center,int r,double angleX,double angleY) { this(center,r,(float) angleX,(float) angleY,center.color,false);} public Cube(Point3D center,int r,double angleX,double angleY,int color) { this(center,r,(float) angleX,(float) angleY,color,false);} public Cube(Point3D center,int r,double angleX,double angleY,int color,boolean solid) { super(center,r,color,solid); this.angleX=(float) angleX; this.angleY=(float) angleY; init(color);} public Cube(Point3D center,float r,float angleX,float angleY) { this(center,(int)(r+0.5f),angleX,angleY);} public Cube(Point3D center,float r,float angleX,float angleY,int color) { this(center,(int)(r+0.5f),angleX,angleY,color);} public Cube(Point3D center,float r,float angleX,float angleY,int color,boolean solid) { this(center,(int)(r+0.5f),angleX,angleY,color,solid);} public Cube(Point3D center,double r,double angleX,double angleY) { this(center,(float) r,(float) angleX,(float) angleY);} public Cube(Point3D center,double r,double angleX,double angleY,int color) { this(center,(float) r,(float) angleX,(float) angleY,color);} public Cube(Point3D center,double r,double angleX,double angleY,int color,boolean solid) { this(center,(float) r,(float) angleX,(float) angleY,color,solid);} public Cube(Point3D center,short r,float angleX,float angleY) { this(center,(int) r,angleX,angleY);} public Cube(Point3D center,short r,float angleX,float angleY,int color) { this(center,(int) r,angleX,angleY,color);} public Cube(Point3D center,short r,float angleX,float angleY,int color,boolean solid) { this(center,(int) r,angleX,angleY,color,solid);} public Cube(Point3D center,short r,double angleX,double angleY) { this(center,(int) r,angleX,angleY);} public Cube(Point3D center,short r,double angleX,double angleY,int color) { this(center,(int) r,angleX,angleY,color);} public Cube(Point3D center,short r,double angleX,double angleY,int color,boolean solid) { this(center,(int) r,angleX,angleY,color,solid);} public Cube(Cube c) { this(c.center,c.r,c.angleX,c.angleY,c.color,c.full);} private void init(int color) { if(cds==null) { cds=new CubeDrawSupport(color); cc=new CubeChanges(center,r,angleX,angleY);}} public void represent(Matrix2D matrix) { matrix.addCube(this);} public void toPenSolid(Canvas ics,Paint pn) { ics.fillCube(center.getX(),center.getY(),center.getZ(),r,angleX,angleY,pn);} public void toPenConture(Canvas ics,Paint pn) { if(cc.hasChanges(this)==cc.hasChanges(this)) { cubeBeyondMeasures((short) center.getX(),(short) center.getY(),(short) center.getZ(),(short) r,angleX,angleY,pn); cc.assasign(center,color,angleX,angleY);} cds.getLeftCorners().toPen(ics,pn.select(cds.getLeftCorners())); cds.getRightCorners().toPen(ics,pn.select(cds.getRightCorners())); cds.ribLeftRight1.toPen(ics,pn.select(cds.ribLeftRight1)); cds.ribLeftRight2.toPen(ics,pn.select(cds.ribLeftRight2)); cds.ribLeftRight3.toPen(ics,pn.select(cds.ribLeftRight3)); cds.ribLeftRight4.toPen(ics,pn.select(cds.ribLeftRight4));} public void turnAroundX(float dtAngleX) {} public void turnAroundY(float dtAngleY) {} public void turnAroundZ(float dtAngleZ) {} public void turnStartX(float angleX) {} public void turnStartY(float angleY) {} public void turnStartZ(float angleZ) {} public float getAngleZ() { return 0;} public float getAngleX() { return angleX;} public float getAngleY() { return angleY;} private void update(float angleX,float angleY) { this.angleX=angleX; this.angleY=angleY;} public void update(Point3D center,int r,float angleX,float angleY) { super.update(center,r); update(angleX,angleY);} public void update(Point3D center,float r,float angleX,float angleY) { super.update(center,r); update(angleX,angleY);} public void update(Point3D center,short r,float angleX,float angleY) { super.update(center,r); update(angleX,angleY);} public Sphere intSphere() { return this;} public Sphere extSphere() { return new Sphere(center,(float) Math.sqrt(r * r+r * r+r * r),color,full);} public boolean equals(Object o) { if(o !=null && o instanceof Cube) if(super.equals((Sphere) o) && angleX==((Cube) o).angleX && angleY==((Cube) o).angleY) return true; return false;} public String toString() { return "Cube("+center+", "+r+", "+angleX+", "+angleY+")";} public int x() { return center.getX();} public int y() { return center.getY();} public int z() { return center.getZ();} public Point3D A() { return getP1();} public Point3D B() { return getP2();} public Point3D C() { return getP3();} public Point3D D() { return getP4();} public Point3D M() { return getP5();} public Point3D P() { return getP6();} public Point3D O() { return getP7();} public Point3D Q() { return getP8();} public Point3D getP1() { return Vector3.shiftXYZ(-r,-r,-r).getShiftedCopy(center);} public Point3D getP2() { return Vector3.shiftXYZ(-r,r,-r).getShiftedCopy(center);} public Point3D getP3() { return Vector3.shiftXYZ(r,r,-r).getShiftedCopy(center);} public Point3D getP4() { return Vector3.shiftXYZ(r,-r,-r).getShiftedCopy(center);} public Point3D getP5() { return Vector3.shiftXYZ(-r,-r,r).getShiftedCopy(center);} public Point3D getP6() { return Vector3.shiftXYZ(-r,r,r).getShiftedCopy(center);} public Point3D getP7() { return Vector3.shiftXYZ(r,r,r).getShiftedCopy(center);} public Point3D getP8() { return Vector3.shiftXYZ(r,-r,r).getShiftedCopy(center);} public Line3D AB() { return new Line3D(A(),B());} public Line3D BC() { return new Line3D(B(),C());} public Line3D CD() { return new Line3D(C(),D());} public Line3D DA() { return new Line3D(D(),A());} public Line3D MP() { return new Line3D(M(),P());} public Line3D PO() { return new Line3D(P(),O());} public Line3D OQ() { return new Line3D(O(),Q());} public Line3D QM() { return new Line3D(Q(),M());} public Line3D AM() { return new Line3D(A(),M());} public Line3D BP() { return new Line3D(B(),P());} public Line3D CO() { return new Line3D(C(),O());} public Line3D DQ() { return new Line3D(D(),Q());} public Line3D[] ribs() { Line3D[] ribs=new Line3D[12]; ribs[0]=AB(); ribs[1]=BC(); ribs[2]=CD(); ribs[3]=DA(); ribs[4]=MP(); ribs[5]=PO(); ribs[6]=OQ(); ribs[7]=QM(); ribs[8]=AM(); ribs[9]=BP(); ribs[10]=CO(); ribs[11]=DQ(); return ribs;} public Line2D[] ribsProjections() { Line2D[] ribs=new Line2D[12]; if(cds==null) init(color); ribs[0]=cds.ribLeftRight1; ribs[1]=cds.ribLeftRight2; ribs[2]=cds.ribLeftRight3; ribs[3]=cds.ribLeftRight4; ribs[4]=new Line2D(cds.getLeftCorners().p1,cds.getLeftCorners().p2,color); ribs[5]=new Line2D(cds.getLeftCorners().p2,cds.getLeftCorners().p3,color); ribs[6]=new Line2D(cds.getLeftCorners().p3,cds.getLeftCorners().p4,color); ribs[7]=new Line2D(cds.getLeftCorners().p4,cds.getLeftCorners().p1,color); ribs[8]=new Line2D(cds.getRightCorners().p1,cds.getRightCorners().p2,color); ribs[9]=new Line2D(cds.getRightCorners().p2,cds.getRightCorners().p3,color); ribs[10]=new Line2D(cds.getRightCorners().p3,cds.getRightCorners().p4,color); ribs[11]=new Line2D(cds.getRightCorners().p4,cds.getRightCorners().p1,color); return ribs;} public Point3D[] vertices() { Point3D[] verts=new Point3D[8]; verts[0]=A(); verts[1]=B(); verts[2]=C(); verts[3]=D(); verts[4]=M(); verts[5]=P(); verts[6]=O(); verts[7]=Q(); return verts;} public Point2D[] verticesProjections() { Point2D[] verts=new Point2D[8]; if(cds==null) init(color); verts[0]=cds.getLeftCorners().p1; verts[1]=cds.getLeftCorners().p2; verts[2]=cds.getLeftCorners().p3; verts[3]=cds.getLeftCorners().p4; verts[4]=cds.getRightCorners().p1; verts[5]=cds.getRightCorners().p2; verts[6]=cds.getRightCorners().p3; verts[7]=cds.getRightCorners().p4; return verts;} public Rectangle3D[] planes() { Rectangle3D[] result=new Rectangle3D[6]; result[0]=getPlaneLeft(); result[1]=getPlaneRight(); result[2]=getPlaneTop(); result[3]=getPlaneBottom(); result[4]=getPlaneBack(); result[5]=getPlaneFront(); return result;} public Conture2D[] planesProjections() { return null;} public Rectangle3D getPlaneLeft() { return new Rectangle3D(getP1(),getP4(),getP8(),getP5());} public Rectangle3D getPlaneRight() { return new Rectangle3D(getP2(),getP3(),getP7(),getP6());} public Rectangle3D getPlaneTop() { return new Rectangle3D(getP1(),getP2(),getP6(),getP5());} public Rectangle3D getPlaneBottom() { return new Rectangle3D(getP4(),getP3(),getP7(),getP8());} public Rectangle3D getPlaneBack() { return new Rectangle3D(getP5(),getP6(),getP7(),getP8());} public Rectangle3D getPlaneFront() { return new Rectangle3D(getP1(),getP2(),getP3(),getP4());} private void cubeBeyondMeasures(short uax,short uay,short uaz,short r,float angleX,float angleY,Paint pn) { int STEP=(7-1+1) /(1+1); Rectangle2D area=new Rectangle2D(pn.getWidth(),pn.getHeight()); float halfAreaW=area.w() / 2f; float halfAreaH=area.h() / 2f; float W12=(float)(area.w() / 100 *(STEP *(1+1))); float H12=(float)(area.h() / 100 *(STEP *(1+1))); float frontLeftX=0f; float frontTopY=0f; float frontRightX=0f; float frontBottomY=0f; float backLeftX=0f; float backTopY=0f; float backRightX=0f; float backBottomY=0f; float lx; float ly; float lx2; float ly2; float dl; int i=-uaz; lx=(float) i / 300 *(halfAreaW-W12); ly=area.h()-(float) i / 300 *(halfAreaH-H12); lx2=area.w()-(float) i / 300 *(halfAreaW-W12); ly2=(float) i / 300 *(halfAreaH-H12); lx=halfAreaW; lx2=uax; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); frontLeftX=lx-lx2; lx=halfAreaW; lx2=uax-r; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); frontRightX=lx-lx2; ly=halfAreaH; ly2=uay-r; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); frontTopY=ly+ly2; ly=halfAreaH; ly2=uay; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); frontBottomY=ly+ly2; do { dl=(float) r * H12 / halfAreaH+(r-(float) r * H12 / halfAreaH) *(float)(300-i) / 300;} while(i <= 300 && i++<= dl-uaz); lx=(float) i / 300 *(halfAreaW-W12); ly=area.h()-(float) i / 300 *(halfAreaH-H12); lx2=area.w()-(float) i / 300 *(halfAreaW-W12); ly2=(float) i / 300 *(halfAreaH-H12); lx=halfAreaW; lx2=uax; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); backLeftX=lx-lx2; lx=halfAreaW; lx2=uax-r; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); backRightX=lx-lx2; ly=halfAreaH; ly2=uay-r; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); backTopY=ly+ly2; ly=halfAreaH; ly2=uay; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); backBottomY=ly+ly2; cds.getLeftCorners().p1.moveTo(frontLeftX,frontTopY); cds.getLeftCorners().p2.moveTo(backLeftX,backTopY); cds.getLeftCorners().p3.moveTo(backLeftX,backBottomY); cds.getLeftCorners().p4.moveTo(frontLeftX,frontBottomY); cds.getRightCorners().p1.moveTo(frontRightX,frontTopY); cds.getRightCorners().p2.moveTo(backRightX,backTopY); cds.getRightCorners().p3.moveTo(backRightX,backBottomY); cds.getRightCorners().p4.moveTo(frontRightX,frontBottomY); cds.ribLeftRight1.updateVector(cds.getRightCorners().p1); cds.ribLeftRight2.updateVector(cds.getRightCorners().p2); cds.ribLeftRight3.updateVector(cds.getRightCorners().p3); cds.ribLeftRight4.updateVector(cds.getRightCorners().p4);} public boolean isInside(Point3D point) { return false;} public boolean intersects(Line3D line) { Point3D p1=line.getP1(); Point3D p2=line.getP2(); if(isInside(p1) && !isInside(p2)) return true; else if(!isInside(p1) && isInside(p2)) return true; return false;} public Point2D getViewCenter() { Point2D leftProjCenter=cds.getLeftCorners().midpoint(); Point2D rightProjCenter=cds.getRightCorners().midpoint(); Point2D viewCenter=new Line2D(leftProjCenter,rightProjCenter).midpoint(); return viewCenter;}} class CubeChanges { protected Point3D center; protected int r; protected float angleX; protected float angleY; public CubeChanges(Point3D center,int r,float angleX,float angleY) { super(); assasign(center,r,angleX,angleY);} public boolean hasChanges(Cube ci) { if(ci.center.equals(center)==false) return true; if(ci.r !=r) return true; if(ci.angleX !=angleX) return true; if(ci.angleY !=angleY) return true; return false;} public void assasign(Point3D center,int r,float angleX,float angleY) { this.center=center; this.r=r; this.angleX=angleX; this.angleY=angleY;}} class CubeDrawSupport { protected FourCornersConture2D leftCorners; protected FourCornersConture2D rightCorners; protected Line2D ribLeftRight1; protected Line2D ribLeftRight2; protected Line2D ribLeftRight3; protected Line2D ribLeftRight4; public CubeDrawSupport(int color) { super(); this.leftCorners=new FourCornersConture2D(color); this.rightCorners=new FourCornersConture2D(color); createRibs(color);} protected void createRibs(int color) { ribLeftRight1=new Line2D(leftCorners.p1,rightCorners.p1,color); ribLeftRight2=new Line2D(leftCorners.p2,rightCorners.p2,color); ribLeftRight3=new Line2D(leftCorners.p3,rightCorners.p3,color); ribLeftRight4=new Line2D(leftCorners.p4,rightCorners.p4,color);} public FourCornersConture2D getLeftCorners() { return leftCorners;} public FourCornersConture2D getRightCorners() { return rightCorners;}}