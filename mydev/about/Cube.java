package mydev.about; import java.util.Enumeration; import java.util.Vector; public class Cube extends Sphere implements Decompose,Turner { protected float angleX; protected float angleY; private CubeDrawSupport cds; private CubeChanges cc; public Cube(Point3D center,int r) { this(center,r,0f,0f,center.color,false);} public Cube(Point3D center,int r,int color,boolean solid) { this(center,r,0f,0f,color,solid);} public Cube(Point3D center,float r,int color,boolean solid) { this(center,(int)(r+0.5f),0f,0f,color,solid);} public Cube(Point3D center,double r,int color,boolean solid) { this(center,(float) r,0f,0f,color,solid);} public Cube(Point3D center,int r,float angleX,float angleY) { this(center,r,angleX,angleY,center.color,false);} public Cube(Point3D center,int r,float angleX,float angleY,int color) { this(center,r,angleX,angleY,color,false);} public Cube(Point3D center,int r,float angleX,float angleY,int color,boolean solid) { super(center,r,color,solid); this.angleX=angleX; this.angleY=angleY; init(color);} public Cube(Point3D center,int r,double angleX,double angleY) { this(center,r,(float) angleX,(float) angleY,center.color,false);} public Cube(Point3D center,int r,double angleX,double angleY,int color) { this(center,r,(float) angleX,(float) angleY,color,false);} public Cube(Point3D center,int r,double angleX,double angleY,int color,boolean solid) { super(center,r,color,solid); this.angleX=(float) angleX; this.angleY=(float) angleY; init(color);} public Cube(Point3D center,float r,float angleX,float angleY) { this(center,(int)(r+0.5f),angleX,angleY);} public Cube(Point3D center,float r,float angleX,float angleY,int color) { this(center,(int)(r+0.5f),angleX,angleY,color);} public Cube(Point3D center,float r,float angleX,float angleY,int color,boolean solid) { this(center,(int)(r+0.5f),angleX,angleY,color,solid);} public Cube(Point3D center,double r,double angleX,double angleY) { this(center,(float) r,(float) angleX,(float) angleY);} public Cube(Point3D center,double r,double angleX,double angleY,int color) { this(center,(float) r,(float) angleX,(float) angleY,color);} public Cube(Point3D center,double r,double angleX,double angleY,int color,boolean solid) { this(center,(float) r,(float) angleX,(float) angleY,color,solid);} public Cube(Point3D center,short r,float angleX,float angleY) { this(center,(int) r,angleX,angleY);} public Cube(Point3D center,short r,float angleX,float angleY,int color) { this(center,(int) r,angleX,angleY,color);} public Cube(Point3D center,short r,float angleX,float angleY,int color,boolean solid) { this(center,(int) r,angleX,angleY,color,solid);} public Cube(Point3D center,short r,double angleX,double angleY) { this(center,(int) r,angleX,angleY);} public Cube(Point3D center,short r,double angleX,double angleY,int color) { this(center,(int) r,angleX,angleY,color);} public Cube(Point3D center,short r,double angleX,double angleY,int color,boolean solid) { this(center,(int) r,angleX,angleY,color,solid);} public Cube(Cube c) { this(c.center,c.r,c.angleX,c.angleY,c.color,c.full);} private void init(int color) { if(cds==null) { cds=new CubeDrawSupport(color); cc=new CubeChanges(center,r,angleX,angleY);}} public void represent(Matrix2D matrix) { matrix.addCube(this);} public void toPenSolid(Canvas ics,Paint pn) { ics.fillCube(center.getX(),center.getY(),center.getZ(),r,angleX,angleY,pn);} public void toPenConture(Canvas ics,Paint pn) { if(cc.hasChanges(this)==cc.hasChanges(this)) { cubeBeyondMeasures((short) center.getX(),(short) center.getY(),(short) center.getZ(),(short) r,angleX,angleY,pn); cc.assasign(center,color,angleX,angleY);} cds.getLeftCorners().toPen(ics,pn.select(cds.getLeftCorners())); cds.getRightCorners().toPen(ics,pn.select(cds.getRightCorners())); cds.ribLeftRight1.toPen(ics,pn.select(cds.ribLeftRight1)); cds.ribLeftRight2.toPen(ics,pn.select(cds.ribLeftRight2)); cds.ribLeftRight3.toPen(ics,pn.select(cds.ribLeftRight3)); cds.ribLeftRight4.toPen(ics,pn.select(cds.ribLeftRight4));} public void turnAroundX(float dtAngleX) {} public void turnAroundY(float dtAngleY) {} public void turnAroundZ(float dtAngleZ) {} public void turnStartX(float angleX) {} public void turnStartY(float angleY) {} public void turnStartZ(float angleZ) {} public float getAngleZ() { return 0;} public float getAngleX() { return angleX;} public float getAngleY() { return angleY;} private void update(float angleX,float angleY) { this.angleX=angleX; this.angleY=angleY;} public void update(Point3D center,int r,float angleX,float angleY) { super.update(center,r); update(angleX,angleY);} public void update(Point3D center,float r,float angleX,float angleY) { super.update(center,r); update(angleX,angleY);} public void update(Point3D center,short r,float angleX,float angleY) { super.update(center,r); update(angleX,angleY);} public Sphere intSphere() { return new Sphere(center,r,color,full);} public Sphere extSphere() { return new Sphere(center,(float) Math.sqrt(r * r+r * r+r * r),color,full);} public boolean equals(Object o) { if(o !=null && o instanceof Cube) if(super.equals((Sphere) o) && angleX==((Cube) o).angleX && angleY==((Cube) o).angleY) return true; return false;} public String toString() { return "Cube("+center+", "+r+", "+angleX+", "+angleY+")";} public int x() { return center.getX();} public int y() { return center.getY();} public int z() { return center.getZ();} public Enumeration ribsIterator() { Vector ribs=new Vector(); if(cds==null) init(color); Enumeration leftRibs=cds.getLeftCorners().ribsIterator(); while(leftRibs.hasMoreElements()) ribs.addElement(leftRibs.nextElement()); Enumeration rightRibs=cds.getRightCorners().ribsIterator(); while(rightRibs.hasMoreElements()) ribs.addElement(rightRibs.nextElement()); ribs.addElement(cds.ribLeftRight1); ribs.addElement(cds.ribLeftRight2); ribs.addElement(cds.ribLeftRight3); ribs.addElement(cds.ribLeftRight4); return ribs.elements();} public Enumeration verticesIterator() { Vector verts=new Vector(); if(cds==null) init(color); verts.addElement(cds.getLeftCorners().p1); verts.addElement(cds.getLeftCorners().p2); verts.addElement(cds.getLeftCorners().p3); verts.addElement(cds.getLeftCorners().p4); verts.addElement(cds.getRightCorners().p1); verts.addElement(cds.getRightCorners().p2); verts.addElement(cds.getRightCorners().p3); verts.addElement(cds.getRightCorners().p4); return verts.elements();} public Enumeration planesIterator() { Vector planes=new Vector(); planes.addElement(getPlane(1)); planes.addElement(getPlane(2)); planes.addElement(getPlane(3)); planes.addElement(getPlane(4)); planes.addElement(getPlane(5)); planes.addElement(getPlane(6)); return planes.elements();} private Plane3D getPlane(int idx) { return null;} private void cubeBeyondMeasures(short uax,short uay,short uaz,short r,float angleX,float angleY,Paint pn) { int STEP=(7-1+1) /(1+1); Rectangle2D area=new Rectangle2D(pn.getWidth(),pn.getHeight()); float halfAreaW=area.w() / 2f; float halfAreaH=area.h() / 2f; float W12=(float)(area.w() / 100 *(STEP *(1+1))); float H12=(float)(area.h() / 100 *(STEP *(1+1))); float frontLeftX=0f; float frontTopY=0f; float frontRightX=0f; float frontBottomY=0f; float backLeftX=0f; float backTopY=0f; float backRightX=0f; float backBottomY=0f; float lx; float ly; float lx2; float ly2; float dl; int i=-uaz; lx=(float) i / 300 *(halfAreaW-W12); ly=area.h()-(float) i / 300 *(halfAreaH-H12); lx2=area.w()-(float) i / 300 *(halfAreaW-W12); ly2=(float) i / 300 *(halfAreaH-H12); lx=halfAreaW; lx2=uax; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); frontLeftX=lx-lx2; lx=halfAreaW; lx2=uax-r; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); frontRightX=lx-lx2; ly=halfAreaH; ly2=uay-r; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); frontTopY=ly+ly2; ly=halfAreaH; ly2=uay; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); frontBottomY=ly+ly2; do { dl=(float) r * H12 / halfAreaH+(r-(float) r * H12 / halfAreaH) *(float)(300-i) / 300;} while(i <= 300 && i++<= dl-uaz); lx=(float) i / 300 *(halfAreaW-W12); ly=area.h()-(float) i / 300 *(halfAreaH-H12); lx2=area.w()-(float) i / 300 *(halfAreaW-W12); ly2=(float) i / 300 *(halfAreaH-H12); lx=halfAreaW; lx2=uax; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); backLeftX=lx-lx2; lx=halfAreaW; lx2=uax-r; lx2=lx2-(float) i / 300 *(lx2-W12 / halfAreaW * lx2); backRightX=lx-lx2; ly=halfAreaH; ly2=uay-r; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); backTopY=ly+ly2; ly=halfAreaH; ly2=uay; ly2=ly2-(float) i / 300 *(ly2-H12 / halfAreaH * ly2); backBottomY=ly+ly2; cds.getLeftCorners().p1.moveTo(frontLeftX,frontTopY); cds.getLeftCorners().p2.moveTo(backLeftX,backTopY); cds.getLeftCorners().p3.moveTo(backLeftX,backBottomY); cds.getLeftCorners().p4.moveTo(frontLeftX,frontBottomY); cds.getRightCorners().p1.moveTo(frontRightX,frontTopY); cds.getRightCorners().p2.moveTo(backRightX,backTopY); cds.getRightCorners().p3.moveTo(backRightX,backBottomY); cds.getRightCorners().p4.moveTo(frontRightX,frontBottomY); cds.ribLeftRight1.updateVector(cds.getRightCorners().p1); cds.ribLeftRight2.updateVector(cds.getRightCorners().p2); cds.ribLeftRight3.updateVector(cds.getRightCorners().p3); cds.ribLeftRight4.updateVector(cds.getRightCorners().p4);} public boolean isInside(Point3D point) { return false;} public boolean intersects(Line3D line) { Point3D p1=line.getP1(); Point3D p2=line.getP2(); if(isInside(p1) && !isInside(p2)) return true; else if(!isInside(p1) && isInside(p2)) return true; return false;}} class CubeChanges { protected Point3D center; protected int r; protected float angleX; protected float angleY; public CubeChanges(Point3D center,int r,float angleX,float angleY) { super(); assasign(center,r,angleX,angleY);} public boolean hasChanges(Cube ci) { if(ci.center.equals(center)==false) return true; if(ci.r !=r) return true; if(ci.angleX !=angleX) return true; if(ci.angleY !=angleY) return true; return false;} public void assasign(Point3D center,int r,float angleX,float angleY) { this.center=center; this.r=r; this.angleX=angleX; this.angleY=angleY;}} class CubeDrawSupport { protected FourCornersConture2D leftCorners; protected FourCornersConture2D rightCorners; protected Line2D ribLeftRight1; protected Line2D ribLeftRight2; protected Line2D ribLeftRight3; protected Line2D ribLeftRight4; public CubeDrawSupport(int color) { super(); this.leftCorners=new FourCornersConture2D(color); this.rightCorners=new FourCornersConture2D(color); createRibs(color);} protected void createRibs(int color) { ribLeftRight1=new Line2D(leftCorners.p1,rightCorners.p1,color); ribLeftRight2=new Line2D(leftCorners.p2,rightCorners.p2,color); ribLeftRight3=new Line2D(leftCorners.p3,rightCorners.p3,color); ribLeftRight4=new Line2D(leftCorners.p4,rightCorners.p4,color);} public FourCornersConture2D getLeftCorners() { return leftCorners;} public FourCornersConture2D getRightCorners() { return rightCorners;}}