package mydev.tonics; import java.awt.Canvas; import java.awt.Color; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Graphics; import java.awt.Window; import java.util.Date; import java.util.Vector; public class Rawnomerno extends Canvas { final static int CPU_FIRST_TURN_DELAY=9; final static int SIDE=50+1; final static int STEP=1+2; Stages doit=new Stages(); Board brd; private boolean needs; private Registry reg; public Rawnomerno() { super(); setBackground(Color.yellow);} public void init() { brd=new Board(doit); int y=STEP-1-1+1; int x=STEP-1-1+1; brd.p11=new Plate(x,y,SIDE,1); x+=STEP+SIDE; brd.p12=new Plate(x,y,SIDE,1+1); x+=STEP+SIDE; brd.p13=new Plate(x,y,SIDE,1+1+1); y+=STEP+SIDE; x=STEP-1-1+1; brd.p21=new Plate(x,y,SIDE,1+1+1+1); x+=STEP+SIDE; brd.p22=new Plate(x,y,SIDE,1+1+1+1+1); x+=STEP+SIDE; brd.p23=new Plate(x,y,SIDE,1+1+1+1+1+1); y+=STEP+SIDE; x=STEP-1-1+1; brd.p31=new Plate(x,y,SIDE,1+1+1+1+1+1+1); x+=STEP+SIDE; brd.p32=new Plate(x,y,SIDE,1+1+1+1+1+1+1+1); x+=STEP+SIDE; brd.p33=new Plate(x,y,SIDE,1+1+1+1+1+1+1+1+1); reg=new Registry(brd); Player p1=new Cpu(brd); reg.reg(p1); Player p2=new User(brd); reg.reg(p2); reg.participate(); if(!p1.equals(p2)) reg.assign(p1);} public static void main(String[] args) { Rawnomerno erno=new Rawnomerno(); erno.init(); Window win=new Window(new Frame("")); win.setBackground(Color.blue); erno.resize(STEP+SIDE+STEP+SIDE+STEP+SIDE+STEP,STEP+SIDE+STEP+SIDE+STEP+SIDE+STEP); win.setLayout(new FlowLayout()); win.add(erno); win.pack(); win.show(); short count=0; while(erno.doit !=null) try { if(++count > CPU_FIRST_TURN_DELAY-1-1 && count < CPU_FIRST_TURN_DELAY && erno.doit.ready()) { erno.reg.swapp();} Thread.sleep(667);} catch(InterruptedException ex) { ex.getMessage();} finally { if(erno.reg.askAboutMakingTurn()) erno.needs=true; erno.mrepaint();} win.hide(); win.dispose(); System.exit(1-1);} public boolean mouseDown(Event et,int xm,int ym) { brd.retryMouse(xm,ym); Plate hit=brd.retryMouse(xm,ym); if(hit !=null) { needs=true; if(brd.hasUserClicked()) { Player act=reg.currentActor(); act.makeTurn(); reg.nextActor();}} if(brd.p11.retried()) doit=null; return super.mouseDown(et,xm,ym);} public void mrepaint() { if(needs) { repaint(); needs=false;}} public void paint(Graphics cs) { super.paint(cs); brd.draw(cs);}} class Stages { final int CHOOSE_FIRST=1; final int FUNCTION=2; final int ABOUT_TO_FINISH=3; private int currentState; public Stages() { super(); currentState=CHOOSE_FIRST;} public void startPlay() { currentState=FUNCTION;} public void startFinish() { currentState=ABOUT_TO_FINISH;} public void hasTakenSomeAction() { if(currentState !=FUNCTION) startPlay();} public void threeInArow() { if(currentState !=ABOUT_TO_FINISH) startFinish();} public boolean finished() { return currentState==ABOUT_TO_FINISH;} public boolean ready() { return currentState==CHOOSE_FIRST;}} class Plate { int sx,sy,width; int xm,ym; private Player owner; private Integer id; public Plate(int sx,int sy,int width,int id) { super(); this.sx=sx; this.sy=sy; this.width=width; this.id=new Integer(id);} public boolean retryMouse(int xm,int ym) { if(sx < xm && sy < ym && sx+width > xm && sy+width > ym) { this.xm=xm; this.ym=ym; return true;} return false;} public Integer getId() { return id;} public int getSx() { return sx;} public int getSy() { return sy;} public int getWidth() { return width;} public void draw(Graphics cs) { cs.setColor(Color.darkGray); cs.drawRect(sx+1,sy+1,width,width); cs.setColor(Color.lightGray); cs.fillRect(sx+1,sy+1,width,width); if(owner !=null) { cs.setColor(Color.yellow); if(owner.c=='X') { cs.drawLine(sx+1+1+1,sy+1+1+1,sx+width-1-1,sy+width-1-1); cs.drawLine(sx+1+1+1,sy+width-1-1,sx+width-1-1,sy+1+1+1); cs.drawLine(sx+1+1+1,sy+1+1+1+1,sx+width-1-1,sy+width-1-1+1); cs.drawLine(sx+1+1+1,sy+width-1-1+1,sx+width-1-1,sy+1+1+1+1);} if(owner.c=='O') { cs.drawOval(sx+1+1+1,sy+1+1+1,width-1-1-1-1,width-1-1-1-1); cs.drawOval(sx+1+1+1+1,sy+1+1+1+1,width-1-1-1-1-1-1,width-1-1-1-1-1-1);}}} public boolean retried() { return xm !=0 && ym !=0;} public void takeOwnership(Player own) { if(owner==null) owner=own;} public static synchronized boolean sameOwner(Plate a,Plate b,Plate c) { return a.owner==b.owner && b.owner==c.owner && c.owner !=null;} public static Integer sameOwnerTwo(Plate a,Plate b,Plate c) { int count=0; count+=a.owner !=null && a.owner==b.owner && c.owner==null ? 1 : 0; count+=a.owner !=null && a.owner==c.owner && b.owner==null ? 1 : 0; count+=b.owner !=null && b.owner==c.owner && a.owner==null ? 1 : 0; Integer result=null; if(count > 0) { if(a.owner==null) result=a.getId(); if(b.owner==null) result=b.getId(); if(c.owner==null) result=c.getId();} return result;}} class Board { Plate p11,p12,p13; Plate p21,p22,p23; Plate p31,p32,p33; TnExt te; Nerovno tut; private Integer userClicked; Stages doit; public Board(Stages doit) { super(); te=new TnExt(this); this.doit=doit;} public boolean hasUserClicked() { return userClicked !=null;} public Integer popClicked() { Integer result=new Integer(userClicked.intValue()); this.userClicked=null; return result;} public void takeSel(Integer id,Player pl) { if(!doit.finished()) takeSelEx(id,pl); doit.hasTakenSomeAction(); checkState(); if(tut !=null) doit.threeInArow();} private void checkState() { if(Plate.sameOwner(p11,p12,p13)) tut=new Nerovno(p11,p12,p13); if(Plate.sameOwner(p21,p22,p23)) tut=new Nerovno(p21,p22,p23); if(Plate.sameOwner(p31,p32,p33)) tut=new Nerovno(p31,p32,p33); if(Plate.sameOwner(p11,p21,p31)) tut=new Nerovno(p11,p21,p31); if(Plate.sameOwner(p12,p22,p32)) tut=new Nerovno(p12,p22,p32); if(Plate.sameOwner(p13,p23,p33)) tut=new Nerovno(p13,p23,p33); if(Plate.sameOwner(p11,p22,p33)) tut=new Nerovno(p11,p22,p33); if(Plate.sameOwner(p13,p22,p31)) tut=new Nerovno(p13,p22,p31);} public Integer hasTwo() { Integer x; if((x=Plate.sameOwnerTwo(p11,p12,p13)) !=null) return x; if((x=Plate.sameOwnerTwo(p21,p22,p23)) !=null) return x; if((x=Plate.sameOwnerTwo(p31,p32,p33)) !=null) return x; if((x=Plate.sameOwnerTwo(p11,p21,p31)) !=null) return x; if((x=Plate.sameOwnerTwo(p12,p22,p32)) !=null) return x; if((x=Plate.sameOwnerTwo(p13,p23,p33)) !=null) return x; if((x=Plate.sameOwnerTwo(p11,p22,p33)) !=null) return x; if((x=Plate.sameOwnerTwo(p13,p22,p31)) !=null) return x; return null;} public void takeSelEx(Integer id,Player pl) { te.removeSpecific(id); switch(id.intValue()) { case 1 : p11.takeOwnership(pl); return; case 2 : p12.takeOwnership(pl); return; case 3 : p13.takeOwnership(pl); return; case 4 : p21.takeOwnership(pl); return; case 5 : p22.takeOwnership(pl); return; case 6 : p23.takeOwnership(pl); return; case 7 : p31.takeOwnership(pl); return; case 8 : p32.takeOwnership(pl); return; case 9 : p33.takeOwnership(pl); return;}} public void takeRandom(Player pl) { if(!te.isEmpty()) { Integer rn=te.removeNext(); takeSel(rn,pl);}} public Plate retryMouse(int xm,int ym) { Plate pl=retryMouseEx(xm,ym); if(pl !=null && te.available(pl.getId())) userClicked=new Integer(pl.getId().intValue()); return pl;} public Plate retryMouseEx(int xm,int ym) { if(p11.retryMouse(xm,ym)) return p11; if(p12.retryMouse(xm,ym)) return p12; if(p13.retryMouse(xm,ym)) return p13; if(p21.retryMouse(xm,ym)) return p21; if(p22.retryMouse(xm,ym)) return p22; if(p23.retryMouse(xm,ym)) return p23; if(p31.retryMouse(xm,ym)) return p31; if(p32.retryMouse(xm,ym)) return p32; if(p33.retryMouse(xm,ym)) return p33; return null;} public void draw(Graphics cs) { p11.draw(cs); p12.draw(cs); p13.draw(cs); p21.draw(cs); p22.draw(cs); p23.draw(cs); p31.draw(cs); p32.draw(cs); p33.draw(cs); if(tut !=null) tut.draw(cs);}} class Registry { Player p1,p2; Player current; Board brd; public Registry(Board brd) { super(); current=null; this.brd=brd;} public boolean askAboutMakingTurn() { if(current instanceof Cpu) { current.makeTurn(); nextActor(); return true;} return false;} public void reg(Player pl) { if(p1==null) p1=pl; else if(p2==null) p2=pl;} public void assign(Player pl) { if(pl.equals(p1)) { p1.assign('X'); p2.assign('O');} else { p1.assign('O'); p2.assign('X');}} public void swapp() { Player tmp=p2; p2=p1; p1=tmp; current=p1 instanceof User ? p2 : p1;} public void participate() { current=p1 instanceof Cpu ? p2 : p1;} public boolean notFinished() { return current !=null;} public Player currentActor() { return current;} public Player nextActor() { if(current.equals(p1)) current=p2; else if(current.equals(p2)) current=p1; return current;} public void winner(Player pl) { if(pl.equals(p1)) p1.notifyWinner(); if(pl.equals(p2)) p2.notifyWinner();}} class Player { char c; Board brd; public Player(Board brd) { super(); this.brd=brd;} public void makeTurn() {} public void assign(char c) { this.c=c;} public void yourTurn() {} public void notifyWinner() {} public String id() { return new String(""+c+" "+(this instanceof User ? "user" :(this instanceof Cpu) ? "cpu" : ""));}} class Cpu extends Player { public Cpu(Board brd) { super(brd);} public void makeTurn() { brd.takeRandom(this);}} class User extends Player { public User(Board brd) { super(brd);} public void makeTurn() { Integer id=brd.popClicked(); brd.takeSel(id,this);}} class TnExt { final int ONE1=1; final int ONE2=2; final int ONE3=3; final int ONE4=4; final int ONE5=5; final int ONE6=6; final int ONE7=7; final int ONE8=8; final int ONE9=9; private Vector all; private WayNo wnos; private Board brd; public TnExt(Board brd) { super(); all=new Vector(); all.addElement(new Integer(ONE1)); all.addElement(new Integer(ONE9)); all.addElement(new Integer(ONE2)); all.addElement(new Integer(ONE8)); all.addElement(new Integer(ONE3)); all.addElement(new Integer(ONE7)); all.addElement(new Integer(ONE4)); all.addElement(new Integer(ONE6)); all.addElement(new Integer(ONE5)); int idx=(int)(new Date().getTime()); idx=idx < 0 ?-idx : idx; idx=idx-idx / 3 * 3+1; switch(idx) { case 1 : wnos=new WayNoProhibit(brd); break; case 2 : wnos=new WayNoQuick(brd); break; default : wnos=new WayNoRand();} this.brd=brd;} public boolean available(Integer cod) { return all.contains(new Integer(cod.intValue()));} public Integer removeSpecific(Integer cod) { Integer hor=new Integer(cod.intValue()); if(all.contains(hor)) { all.removeElement(hor); return hor;} return null;} public Integer removeNext() { Integer er=wnos.nextCpu(all); int idx=all.indexOf(er); all.removeElement(er); return er;} public boolean isEmpty() { return all.isEmpty();}} class Nerovno { Plate a,b,c; public Nerovno(Plate a,Plate b,Plate c) { super(); this.a=a; this.b=b; this.c=c;} public void draw(Graphics cs) { cs.setColor(Color.yellow); int x1,x2,y1,y2; x1=a.sx+a.width / 2; x2=c.sx+c.width / 2; y1=a.sy+a.width / 2; y2=c.sy+c.width / 2; cs.drawLine(x1,y1,x2,y2); cs.drawLine(x1+1,y1+1,x2+1,y2+1); cs.drawLine(x1+1+1,y1+1+1,x2+1+1,y2+1+1);}} interface WayNo { Integer nextCpu(Vector cases);} class WayNoRand implements WayNo { public WayNoRand() { super();} public Integer nextCpu(Vector cases) { int size=cases.size(); int idx=(int)(new Date().getTime()); idx=idx < 0 ?-idx : idx; idx=idx-idx / size * size; Integer er=(Integer) cases.elementAt(idx); return er;}} class WayNoProhibit extends WayNoRand { Board brd; public WayNoProhibit(Board brd) { super(); this.brd=brd;} public Integer nextCpu(Vector cases) { Integer result=brd.hasTwo(); if(result !=null && !cases.contains(result)) result=null; return result==null ? super.nextCpu(cases) : result;}} class WayNoQuick extends WayNoRand { Board brd; public WayNoQuick(Board brd) { super(); this.brd=brd;} public Integer nextCpu(Vector cases) { Integer result=brd.hasTwo(); if(result !=null && !cases.contains(result)) result=null; return result==null ? super.nextCpu(cases) : result;}}
