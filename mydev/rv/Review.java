package mydev.rv; import java.awt.Button; import java.awt.Canvas; import java.awt.Choice; import java.awt.Color; import java.awt.Dimension; import java.awt.Event; import java.awt.FlowLayout; import java.awt.Frame; import java.awt.Graphics; import java.awt.Image; import java.awt.Label; import java.awt.TextField; import java.awt.Toolkit; import java.awt.Window; import java.awt.image.DirectColorModel; import java.awt.image.ImageObserver; import java.awt.image.MemoryImageSource; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import mydev.vutils.Ester; import mydev.vutils.Files; import mydev.vutils.Filter; import mydev.vutils.Karta; import mydev.vutils.Spiska; import mydev.vutils.Stachko; public class Review { final static boolean D=false; static String pictureName="name.bmp"; public static void main(String[] args) { Review main=new Review(); main.setCaption("Review-F1-F2"); main.setImagePath(args.length > 0 ? args[0] : ""); main.createWindow(); main.start(); while(WorkingHolder.working) { main.refreshUpdatable(); try { Thread.sleep(123);} catch(Throwable th) { th.getMessage();}} main.destroyWindow(); System.exit(1-1);} protected void refreshUpdatable() { } public void destroyWindow() { WindowProvider.instance().destroyWindow();} public void start() { WindowProvider.instance().start();} public void createWindow() { WindowProvider.instance().createWindow();} public void setImagePath(String path) { WindowProvider.instance().setImagePath(path);} public void setCaption(String title) { WindowProvider.instance().setCaption(title);}} class WindowProvider { static WindowProvider inst; String title; String imgPath; private boolean bgMode; private BgWindow bgWindow; private NormalWindow normalWindow; WindowProvider() { super(); this.bgMode=false;} public void setCaption(String title) { this.title=title;} public void setImagePath(String imgPath) { this.imgPath=imgPath;} public static WindowProvider instance() { if(inst==null) inst=new WindowProvider(); return inst;} public void createWindow() { getCurrentWindow();} public void start() { normalWindow.start(); } public void destroyWindow() { destroyBgWindow(); destroyNormalWindow();} private AbstractWindow getCurrentWindow() { if(bgMode==true) return getBgWindow(); return getNormalWindow();} private AbstractWindow getNormalWindow() { if(bgWindow !=null) { destroyBgWindow(); bgWindow=null;} if(normalWindow==null) createNormalWindow(); return normalWindow;} private void createNormalWindow() { normalWindow=new NormalWindow(); normalWindow.setTitle(title); normalWindow.resize(Mode.N_WIDTH,Mode.N_HEIGHT); normalWindow.show();} private void destroyNormalWindow() { if(normalWindow !=null) { normalWindow.hide(); normalWindow.dispose();}} private void createBgWindow() { bgWindow=new BgWindow(BgWindow.createFrame()); bgWindow.resize(1920,1080); bgWindow.show();} private void destroyBgWindow() { if(bgWindow !=null) { bgWindow.hide(); bgWindow.dispose();}} private AbstractWindow getBgWindow() { if(normalWindow !=null) { destroyNormalWindow(); normalWindow=null;} if(bgWindow==null) createBgWindow(); return bgWindow;}} interface AbstractWindow { void cvReview(String cp); void setPath(String path); void setCaption(String string);} class BgWindowFrame extends Frame { public BgWindowFrame(String title) { super(title);} public boolean handleEvent(Event et) { return super.handleEvent(et);}} class BgWindow extends Window implements AbstractWindow { BgWindowFrame frame; public BgWindow(BgWindowFrame frame) { super(frame); this.frame=frame;} public static BgWindowFrame createFrame() { return new BgWindowFrame("");} public void cvReview(String cp) { } public void setPath(String path) { } public void setCaption(String string) { }} class NormalWindow extends Frame implements AbstractWindow,Runnable { TextField tfPath; Choice chExt; Label lbPath; Label lbPicture; Button btNext; Current c1; Button btPrev; TextField tfAuto; Button btAuto; private String autoDelay="20"; Design cv; private boolean normalMode; private boolean autoEnable; Spiska allViews=new Spiska(); int curIdx; public NormalWindow() { super(); setLayout(new FlowLayout()); setBackground(Color.yellow); add(lbPath=new Label("Pictures Path:")); lbPath.setBackground(Color.white); add(tfPath=new TextField(100-30+10-40)); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\first"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\second"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\third"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\forth"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\fifth"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\sixth"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\seventh"); tfPath.setText("C:\\Users\\fantom\\Desktop\\Leaves Days\\eighth"); add(chExt=new Choice()); chExt.addItem("*.jpg"); chExt.addItem("*.png"); chExt.addItem("*.im1"); chExt.select("*.im1"); add(btNext=new Button("Next")); add(c1=new Current("123")); add(lbPicture=new Label("")); lbPicture.setBackground(Color.white); lbPicture.setText(Review.pictureName); add(btPrev=new Button("Previous")); add(tfAuto=new TextField(4)); tfAuto.setText(autoDelay); add(btAuto=new Button("Auto")); add(cv=new Design()); allViews=new Spiska();} public void cvReview(String cp) { } public void setPath(String path) { } public void setCaption(String string) { } public boolean handleEvent(Event et) { if(et.id==Event.WINDOW_DESTROY) WorkingHolder.working=false; if(et.target==btNext && et.id==Event.ACTION_EVENT) next(); if(et.target==btPrev && et.id==Event.ACTION_EVENT) prev(); if(et.target==btAuto && et.id==Event.ACTION_EVENT) auto(); if(et.target !=null && et.target.equals(tfPath) && et.id==Event.LOST_FOCUS) start(); if(et.target !=null && et.target.equals(chExt) && et.id==Event.ACTION_EVENT) { System.out.println(" "+et); stopAuto(); start();} if(et.target !=null && et.target.equals(tfAuto) && et.id==Event.LOST_FOCUS) autoReplace(); if(et.key==Event.F1 && et.id==Event.KEY_ACTION) { if(normalMode) bgMode(); else normalMode();} if(et.key==Event.F2 && et.id==Event.KEY_ACTION) { if(autoEnable==false) { tfAuto.setText(autoDelay); auto();} else autoEnable=false;} return super.handleEvent(et);} private void next() { stopAuto(); if(Review.D) System.out.println("next"); procNext();} private void prev() { stopAuto(); if(Review.D) System.out.println("previous"); curIdx-=1; if(curIdx < 0) curIdx=(int)(allViews.size()-1); Current.update(curIdx,allViews,c1); reload();} private void reload() { if(allViews.size() > 0) { String cp; String cpName=""; cp=(String) allViews.at(curIdx); if(cp !=null) { cpName=new File(cp).getName(); lbPicture.setText(cpName);} if(Review.D) System.out.println(""+cpName); cv.review(cp);} else cv.clean();} private void stopAuto() { autoEnable=false; } private void procNext() { curIdx+=1; if(curIdx > allViews.size()-1) curIdx=0; Current.update(curIdx,allViews,c1); reload();} public void run() { while(autoEnable) { if(Review.D) System.out.println("1"); procNext(); if(Review.D) System.out.println("2"); try { int au=Integer.parseInt(autoDelay); Thread.sleep(au);} catch(InterruptedException e) { e.getMessage();} if(Review.D) System.out.println("3");}} private void auto() { if(autoEnable==false) { autoEnable=true; new Thread(this).start();}} public void start() { refresh(); curIdx=-1; if(allViews.size() > 0) curIdx=0; Current.update(curIdx,allViews,c1); reload();} protected void refresh() { allViews=new Spiska(); String curPath=tfPath.getText(); String curExt=chExt.getSelectedItem(); int iExt=curExt.lastIndexOf('*'); if(iExt >-1) curExt=curExt.substring(iExt+1); Ester[] items=new Filter().endsWithIncensitive(new Files().tree(new Ester(curPath)),new Ester(curExt)); for(int i=0; i < items.length; i++) allViews.append(items[i].toString()); System.out.println(""+allViews.size());} private void autoReplace() { this.autoDelay=tfAuto.getText();} private void normalMode() { normalMode=true; resize(Mode.N_WIDTH,Mode.N_HEIGHT); cv.soop(Mode.N_WIDTH,Mode.N_HEIGHT); System.out.println("norm");} private void bgMode() { normalMode=false; resize(1920,1080); cv.soop(1920,1080); System.out.println("bg");}} class Review2 implements Runnable { public static void main2(String[] args) { Review main=new Review(); } public void run() { } } class Design extends Canvas implements ImageObserver { Karta proxy=new Karta(); Image curImage; public Design() { super(); soop(Mode.N_WIDTH,Mode.N_HEIGHT);} public void clean() { curImage=null; invalidate(); repaint();} public void soop(int w,int h) { resize(w-100+50+20-10,h-30-40-50+20); setBackground(Color.lightGray);} protected void reloadBackupImage(String picturePath) { ImageFile file=null; try { file=ImageFile.loadImage(picturePath);} catch(ImageFileException e) { e.printStackTrace();} if(file !=null) { int bits=32; int redMask=16711680; int greenMask=65280; int blueMask=255; DirectColorModel cm=new DirectColorModel(bits,redMask,greenMask,blueMask); int width=file.getWidth(); int height=file.getHeight(); int[] pix=file.getData(); curImage=createImage(new MemoryImageSource(width,height,cm,pix,0,width)); }} public void review(String path) { if(Review.D) System.out.println("review "+path); if(path !=null && path.length() > 0) { if(proxy.containsKey(path)) curImage=(Image) proxy.get(path); else { if(path.endsWith(".im1")) { reloadBackupImage(path);} else { curImage=Toolkit.getDefaultToolkit().getImage(path); }}} invalidate(); repaint();} public void paint(Graphics ics) { super.paint(ics); Dimension d1=size(); if(curImage !=null) ics.drawImage(curImage,1,1,d1.width-1-1,d1.height-1-1,this);} public boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height) { if(Review.D) System.out.println(" "+infoflags+" "+x+" "+y+" "+width+" "+height); if(infoflags==ImageObserver.ALLBITS) { invalidate(); repaint(); return false;} return true;}} interface Mode { int N_WIDTH=640; int N_HEIGHT=480;} class ImageItem { private String fullPath; private Image image; public ImageItem(String fullPath,Image image) { super(); this.fullPath=fullPath; this.image=image;} public String getFullPath() { return fullPath;} public Image getImage() { return image;} public String getName() { return new File(fullPath).getName();}} class ImageProxy { private int curIdx; private ImageProvessor proc; public ImageProxy() { super(); this.proc=new ImageProvessor();} public ImageObserver getImageObserver() { return proc;} public void loadImage(String fullPath) { proc.pushLoading(fullPath);} public long getImageNum() { synchronized(proc.readyImages) { return proc.readyImages.size();}} public synchronized ImageItem getImage(int idx) { synchronized(proc.readyImages) { if(idx < 0) return null; if(idx >= proc.readyImages.size()) return null; if(proc.readyImages.size() < 1) return null; return((ImageWrap) proc.readyImages.at(idx)).getImageRes();}} public ImageItem nextImage() { synchronized(proc.readyImages) { curIdx+=1; if(curIdx >= proc.readyImages.size()) curIdx=0; if(proc.readyImages.size() < 1) return null; return getImage(curIdx);}} public ImageItem prevImage() { synchronized(proc.readyImages) { curIdx-=1; if(curIdx < 0) curIdx=(int) proc.readyImages.size()-1; if(proc.readyImages.size() < 1) return null; return getImage(curIdx);}} public void cancelLoading() { proc.cancelLoading();} public void clearAll() { cancelLoading(); proc.clearAll();} public ImageItem getImage(String path) { System.out.println(" ready "+proc.readyImages.size()); return(ImageItem) proc.readyImages.at(0);}} class ImageWrap { String path; Image ref; boolean ready; public ImageWrap(String path) { super(); this.path=path; this.ready=false;} public boolean isReady() { return ready;} public ImageItem getImageRes() { return new ImageItem(path,ref);} public Image getRef() { return ref;} public String getPath() { return path;} public void setRef(Image ref) { this.ref=ref;} public String getKey() { return ImageWrap.getKey(ref);} public static String getKey(Image imgRef) { if(imgRef==null) return "<null>"; return "<"+imgRef.hashCode()+">";} public void setReady() { this.ready=true;}} class ImageProvessor implements ImageObserver,Runnable { Spiska readyImages; private Stachko orders; private Karta waitingMap; private Thread worker1; private boolean loading; ImageProvessor() { super(); clearAll();} public void run() { loading=true; while(loading) { ImageWrap wrap=null; synchronized(orders) { if(orders.has()) wrap=(ImageWrap) orders.pop(); else loading=false;} if(wrap==null) continue; System.out.println("getImage() "+wrap.getPath()); wrap.setRef(Toolkit.getDefaultToolkit().getImage(wrap.getPath())); synchronized(waitingMap) { waitingMap.put(wrap.getKey(),wrap);} System.out.println("putImage() ");} worker1=null;} void clearAll() { this.loading=false; this.orders=new Stachko(); this.waitingMap=new Karta(); this.readyImages=new Spiska(); this.worker1=null;} void cancelLoading() { loading=false; worker1=null; orders=new Stachko();} void pushLoading(String fullPath) { synchronized(orders) { orders.push(new ImageWrap(fullPath)); if(worker1==null) { worker1=new Thread(this); worker1.start();}}} public boolean imageUpdate(Image img,int infoflags,int x,int y,int width,int height) { System.out.println("imageUpdate() "+img); if(infoflags==ImageObserver.ALLBITS) { ImageWrap imageWrap=null; synchronized(waitingMap) { imageWrap=(ImageWrap) waitingMap.get(ImageWrap.getKey(img));} imageWrap.setReady(); synchronized(readyImages) { readyImages.append(imageWrap);} return false;} return true;}} class Current extends Label { public Current(String text) { super(text); setBackground(Color.yellow);} public void paint(Graphics ics) { super.paint(ics); Dimension d1=size(); ics.setColor(Color.blue); ics.drawRect(0,0,d1.width-1,d1.height-1);} public static void update(int curIdx,Spiska allViews,Current c1) { String s1=""+(curIdx+1)+"/"+allViews.size(); c1.setText(s1);}} class ImageFile { protected static final int BUF_LIM=256; private String fullPath; private int width; private int height; private int pix[]; ImageFile(String fullPath) { super(); this.fullPath=fullPath;} public int[] getData() { return pix;} public String getName() { return new File(fullPath).getName();} public String getFullPath() { return fullPath;} public int getWidth() { return width;} public int getHeight() { return height;} private static int read4b(FileInputStream is) throws IOException { int s=0; int r1=is.read(); int r2=is.read(); int r3=is.read(); int r4=is.read(); s=((r4 * 255+r3) * 255+r2) * 255+r1; return s;} public static ImageFile loadImage(String fullPath) throws ImageFileException { try { ImageFile imageFile=new ImageFile(fullPath); File file=new File(fullPath); FileInputStream is=new FileInputStream(file); imageFile.width=read4b(is); imageFile.height=read4b(is); imageFile.pix=new int[imageFile.width * imageFile.height]; ParserAdapter parser=new ParserAdapter(imageFile.pix); byte[] buf=new byte[4 * BUF_LIM]; int count; do { count=is.read(buf); if(count > 0) parser.push(buf,count);} while(count >= 0); is.close(); return imageFile;} catch(IOException ex) { throw new ImageFileException("Can't load. "+ex.getMessage());}}} class ImageFileException extends Exception { public ImageFileException() { super();} public ImageFileException(String message) { super(message);}} class ParserAdapter { int s; int r1; int r2; int r3; int r4; int n=0; int idx=0; int[] pix; public ParserAdapter(int[] pix) { this.pix=pix;} public void push(int b) { switch(n) { case 0 : r1=b; break; case 1 : r2=b; break; case 2 : r3=b; break; default : r4=b; break;} n++; if(n==4) { n=0; s=((r4 * 255+r3) * 255+r2) * 255+r1; pix[idx++]=s;}} public void push(byte[] buf,int count) { for(int j=0; j < count; j++) push(buf[j]);}} class WorkingHolder { static boolean working=true;}
