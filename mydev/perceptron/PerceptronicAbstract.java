package mydev.perceptron; import mydev.vutils.Queue; abstract class PerceptronicAbstract implements Perceptronic { protected Queue learnItems; protected int amountInputs; protected int amountAverages; protected PerceptronicAbstract(int amountInputs,int amountAverages) { super(); this.learnItems=new Queue(); this.amountInputs=amountInputs; this.amountAverages=amountAverages; createNeuronicNodes();} protected abstract void createNeuronicNodes(); public int getAmountInputs() { return amountInputs;} public int getAmountAverages() { return amountAverages;} public int countItemsLearned() { return(int) learnItems.sizeOfQueue();} public void clear() { learnItems.clearQueue();} protected abstract ClassificationResult getAnswer(ClassificationProbe sample); protected NeuronicNode obtainInputNode(InputProviderConfig inputConfig) { if(inputConfig.isWithMult()) return new NodeInput(inputConfig.getInputProvider(),inputConfig.getInputMult()); return new NodeInput(inputConfig.getInputProvider());} protected NeuronicNode obtainIntermediateNode(double multSum) { return new NodeIntermediate(multSum);} protected NeuronicNode obtainOutputNode() { return new NodeResultingOutput();}} class LearningItem { private ClassificationProbe recognition; private ClassificationResult pattern; public LearningItem(ClassificationProbe recognition,ClassificationResult pattern) { super(); this.recognition=recognition; this.pattern=pattern;} public ClassificationProbe getRecognition() { return recognition;} public ClassificationResult getPattern() { return pattern;}}