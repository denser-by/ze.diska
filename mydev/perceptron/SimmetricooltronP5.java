package mydev.perceptron; import mydev.vutils.Stack; public class SimmetricooltronP5 extends PerceptronicAbstract { private NeuronicNode[] inputs=new NodeInput[1+1]; private NeuronicNode[] avgs=new NodeIntermediate[1+1+1+1+1]; private NeuronicNode[] output=new NodeResultingOutput[1]; protected Stack classificationStory; protected float inputMultFirst; protected float inputMultSecond; protected double[] multSumIntermediate=new double[1+1+1+1+1]; public SimmetricooltronP5() { super(1+1,1+1+1+1+1); this.classificationStory=new Stack();} protected void createNeuronicNodes() { inputs[0]=obtainInputNode(obtainFirstInputProvider()); inputs[0+1]=obtainInputNode(obtainSecondInputProvider()); assignMiddle(0); assignMiddle(0+1); assignMiddle(0+1+1); assignMiddle(0+1+1+1); assignMiddle(0+1+1+1+1); output[0]=obtainOutputNode();} void assignMiddle(int idx) { avgs[idx]=obtainIntermediateNode(multSumIntermediate[idx]);} private InputProviderConfig obtainFirstInputProvider() { SimmetricooltronP5InputProviderFirst firstInputContact=new SimmetricooltronP5InputProviderFirst(); return new InputProviderConfig(firstInputContact,inputMultFirst);} private InputProviderConfig obtainSecondInputProvider() { SimmetricooltronP5InputProviderSecond secondInputContact=new SimmetricooltronP5InputProviderSecond(); return new InputProviderConfig(secondInputContact,inputMultSecond);} public void initNodesClearState() { inputMultFirst=NeuronicWrap.ONE_PARTIocULAR; inputMultSecond=NeuronicWrap.ONE_PARTIocULAR; for(int i=0; i < multSumIntermediate.length; i++) multSumIntermediate[i]=NeuronicWrap.ONE_PARTIocULAR; for(int i=0; i < inputs.length; i++) inputs[i].initClearState(); for(int i=0; i < avgs.length; i++) avgs[i].initClearState(); output[1-1].initClearState();} public void pushDataLearnItem(ClassificationProbe sample,ClassificationResult expected) {} public void processDataLearnItems() {} public ClassificationResult classifyDataResult(ClassificationProbe sample) { ClassificationResult result=getAnswer(sample); BrokenResult classificationItem=new BrokenResult(sample,result); classificationStory.push(classificationItem); return result;} public int countItemsClassify() { return(int) classificationStory.sizeOfStack();} protected ClassificationResult getAnswer(ClassificationProbe sample) { return null;}} class InputProviderConfig { private InputProvider inputProvider; private float inputMult; private boolean withMult; public InputProviderConfig(InputProvider inputProvider,float inputMult) { this.inputProvider=inputProvider; this.inputMult=inputMult; this.withMult=true;} public InputProviderConfig(InputProvider inputProvider) { this.inputProvider=inputProvider;} public InputProvider getInputProvider() { return inputProvider;} public float getInputMult() { return inputMult;} public boolean isWithMult() { return withMult;}} class SimmetricooltronP5InputProviderFirst implements InputProvider { public SimmetricooltronP5InputProviderFirst() { super();} public float getValue() { return 0;}} class SimmetricooltronP5InputProviderSecond implements InputProvider { public SimmetricooltronP5InputProviderSecond() { super();} public float getValue() { return 0;}} class BrokenResult { private ClassificationProbe recognition; private ClassificationResult answer; public BrokenResult(ClassificationProbe recognition,ClassificationResult answer) { super(); this.recognition=recognition; this.answer=answer;} public ClassificationProbe getRecognition() { return recognition;} public ClassificationResult getAnswer() { return answer;} public void setAnswer(ClassificationResult answer) { this.answer=answer;}}